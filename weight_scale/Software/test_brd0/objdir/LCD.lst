   1               		.file	"LCD.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	_ZN3LCDC2Eb
  12               	_ZN3LCDC2Eb:
  13               	.LFB7:
  14               		.file 1 "LCD.cpp"
   1:LCD.cpp       **** #include "LCD.h"
   2:LCD.cpp       **** 
   3:LCD.cpp       **** const uint8_t LCD::NbMap[]={0x3F,0x6,0x5B,0x4F,0x66,0x6D,0x7D,0x7,0x7F,0x6F};
   4:LCD.cpp       **** LCD::digit LCD::digits[]={
   5:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   6:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   7:LCD.cpp       **** 		{{6,6,6,7,7,7,7},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   8:LCD.cpp       **** 		{{4,4,4,5,5,5,5},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   9:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
  10:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}}};
  11:LCD.cpp       **** 
  12:LCD.cpp       **** LCD::LCD(bool lowP){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LBB10:
  13:LCD.cpp       **** 	DDRB |= (1 << PB0);
  23               		.loc 1 13 0
  24 0000 209A      		sbi 0x4,0
  14:LCD.cpp       **** 	PORTB |= (1<<PB0);
  25               		.loc 1 14 0
  26 0002 289A      		sbi 0x5,0
  15:LCD.cpp       **** 	LCDCRB|=(1<<LCDMUX1)|(1<<LCDMUX0);
  27               		.loc 1 15 0
  28 0004 8091 E500 		lds r24,229
  29               	.LVL1:
  30 0008 8063      		ori r24,lo8(48)
  31 000a 8093 E500 		sts 229,r24
  32               	.LBE10:
  33               	.LBB11:
  34               	.LBB12:
  16:LCD.cpp       **** 	
  17:LCD.cpp       **** 	if(lowP){
  18:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  35               		.loc 1 18 0
  36 000e 8091 E600 		lds r24,230
  37               	.LBE12:
  38               	.LBE11:
  39               	.LBB14:
  17:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  40               		.loc 1 17 0
  41 0012 6623      		tst r22
  42 0014 01F0      		breq .L2
  43               	.LVL2:
  44               	.LBE14:
  45               	.LBB15:
  46               	.LBB13:
  47               		.loc 1 18 0
  48 0016 8767      		ori r24,lo8(119)
  49 0018 8093 E600 		sts 230,r24
  19:LCD.cpp       **** 		LCDCCR|=(1<<LCDDC0);// 2.6V 70µs
  50               		.loc 1 19 0
  51 001c 8091 E700 		lds r24,231
  52 0020 8062      		ori r24,lo8(32)
  53 0022 8093 E700 		sts 231,r24
  20:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN)|(1<<LCDAB);//LCDAB=low power waveform
  54               		.loc 1 20 0
  55 0026 8091 E400 		lds r24,228
  56 002a 806C      		ori r24,lo8(-64)
  57               	.LVL3:
  58               	.L4:
  59               	.LBE13:
  60               	.LBE15:
  61               	.LBB16:
  21:LCD.cpp       **** 	}else{
  22:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD2)|(1<<LCDCD0); // prescaler 409
  23:LCD.cpp       **** 		LCDCCR|=(1<<LCDCC1)|(1<<LCDCC2)|(1<<LCDDC1);//2.7V 1150µs
  24:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN);
  62               		.loc 1 24 0
  63 002c 8093 E400 		sts 228,r24
  64               	/* epilogue start */
  65               	.LBE16:
  25:LCD.cpp       **** 	}
  26:LCD.cpp       **** }
  66               		.loc 1 26 0
  67 0030 0895      		ret
  68               	.L2:
  69               	.LBB17:
  22:LCD.cpp       **** 		LCDCCR|=(1<<LCDCC1)|(1<<LCDCC2)|(1<<LCDDC1);//2.7V 1150µs
  70               		.loc 1 22 0
  71 0032 8567      		ori r24,lo8(117)
  72 0034 8093 E600 		sts 230,r24
  23:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN);
  73               		.loc 1 23 0
  74 0038 8091 E700 		lds r24,231
  75 003c 8664      		ori r24,lo8(70)
  76 003e 8093 E700 		sts 231,r24
  24:LCD.cpp       **** 	}
  77               		.loc 1 24 0
  78 0042 8091 E400 		lds r24,228
  79 0046 8068      		ori r24,lo8(-128)
  80 0048 00C0      		rjmp .L4
  81               	.LBE17:
  82               		.cfi_endproc
  83               	.LFE7:
  85               	.global	_ZN3LCDC1Eb
  86               		.set	_ZN3LCDC1Eb,_ZN3LCDC2Eb
  87               	.global	_ZN3LCDD2Ev
  89               	_ZN3LCDD2Ev:
  90               	.LFB10:
  27:LCD.cpp       **** 
  28:LCD.cpp       **** LCD::~LCD() {
  91               		.loc 1 28 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  98               	.LBB18:
  29:LCD.cpp       **** 	LCDCRA|=(1<<LCDBL);
  99               		.loc 1 29 0
 100 004a E4EE      		ldi r30,lo8(-28)
 101 004c F0E0      		ldi r31,0
 102 004e 8081      		ld r24,Z
 103               	.LVL5:
 104 0050 8160      		ori r24,lo8(1)
 105 0052 8083      		st Z,r24
 106               	.LVL6:
 107               	.LBB19:
 108               	.LBB20:
 109               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 110               		.loc 2 187 0
 111 0054 2FEF      		ldi r18,lo8(799999)
 112 0056 84E3      		ldi r24,hi8(799999)
 113 0058 9CE0      		ldi r25,hlo8(799999)
 114 005a 2150      	1:	subi r18,1
 115 005c 8040      		sbci r24,0
 116 005e 9040      		sbci r25,0
 117 0060 01F4      		brne 1b
 118 0062 00C0      		rjmp .
 119 0064 0000      		nop
 120               	.LVL7:
 121               	.LBE20:
 122               	.LBE19:
  30:LCD.cpp       **** 	_delay_ms(500);
  31:LCD.cpp       **** 	LCDCRA&=~(1<<LCDEN);
 123               		.loc 1 31 0
 124 0066 8081      		ld r24,Z
 125 0068 8F77      		andi r24,lo8(127)
 126 006a 8083      		st Z,r24
 127               	/* epilogue start */
 128               	.LBE18:
  32:LCD.cpp       **** }
 129               		.loc 1 32 0
 130 006c 0895      		ret
 131               		.cfi_endproc
 132               	.LFE10:
 134               	.global	_ZN3LCDD1Ev
 135               		.set	_ZN3LCDD1Ev,_ZN3LCDD2Ev
 136               	.global	_ZN3LCD8setDigitEhh
 138               	_ZN3LCD8setDigitEhh:
 139               	.LFB12:
  33:LCD.cpp       **** 
  34:LCD.cpp       **** void LCD::setDigit(uint8_t dig, uint8_t nb) {
 140               		.loc 1 34 0
 141               		.cfi_startproc
 142               	.LVL8:
 143 006e 1F93      		push r17
 144               	.LCFI0:
 145               		.cfi_def_cfa_offset 3
 146               		.cfi_offset 17, -2
 147 0070 CF93      		push r28
 148               	.LCFI1:
 149               		.cfi_def_cfa_offset 4
 150               		.cfi_offset 28, -3
 151 0072 DF93      		push r29
 152               	.LCFI2:
 153               		.cfi_def_cfa_offset 5
 154               		.cfi_offset 29, -4
 155               	/* prologue: function */
 156               	/* frame size = 0 */
 157               	/* stack size = 3 */
 158               	.L__stack_usage = 3
 159               	.LVL9:
 160               	.LBB21:
  35:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  36:LCD.cpp       **** 		if(NbMap[nb] & (1<<j)){
 161               		.loc 1 36 0
 162 0074 E62F      		mov r30,r22
 163 0076 F0E0      		ldi r31,0
 164 0078 E050      		subi r30,lo8(-(_ZN3LCD5NbMapE))
 165 007a F040      		sbci r31,hi8(-(_ZN3LCD5NbMapE))
 166 007c 6081      		ld r22,Z
 167               	.LVL10:
 168 007e 70E0      		ldi r23,0
 169 0080 15E1      		ldi r17,lo8(21)
 170 0082 819F      		mul r24,r17
 171 0084 C001      		movw r24,r0
 172 0086 1124      		clr __zero_reg__
 173               	.LVL11:
 174 0088 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 175 008a 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 176 008c 30E0      		ldi r19,0
 177 008e 20E0      		ldi r18,0
 178 0090 A1E0      		ldi r26,lo8(1)
 179 0092 B0E0      		ldi r27,0
 180               	.LVL12:
 181               	.L9:
 182 0094 F901      		movw r30,r18
 183 0096 EE0F      		lsl r30
 184 0098 FF1F      		rol r31
 185 009a E80F      		add r30,r24
 186 009c F91F      		adc r31,r25
 187 009e 0780      		ldd __tmp_reg__,Z+7
 188 00a0 F085      		ldd r31,Z+8
 189 00a2 E02D      		mov r30,__tmp_reg__
 190 00a4 EC01      		movw r28,r24
 191 00a6 C20F      		add r28,r18
 192 00a8 D31F      		adc r29,r19
 193 00aa 4881      		ld r20,Y
 194 00ac ED01      		movw r28,r26
 195 00ae 00C0      		rjmp 2f
 196               		1:
 197 00b0 CC0F      		lsl r28
 198 00b2 DD1F      		rol r29
 199               		2:
 200 00b4 4A95      		dec r20
 201 00b6 02F4      		brpl 1b
 202 00b8 AE01      		movw r20,r28
 203 00ba EB01      		movw r28,r22
 204 00bc 022E      		mov r0,r18
 205 00be 00C0      		rjmp 2f
 206               		1:
 207 00c0 D595      		asr r29
 208 00c2 C795      		ror r28
 209               		2:
 210 00c4 0A94      		dec r0
 211 00c6 02F4      		brpl 1b
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 212               		.loc 1 37 0
 213 00c8 5081      		ld r21,Z
  36:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 214               		.loc 1 36 0
 215 00ca C0FF      		sbrs r28,0
 216 00cc 00C0      		rjmp .L7
 217               		.loc 1 37 0
 218 00ce 452B      		or r20,r21
 219               	.L11:
  38:LCD.cpp       **** 		}else{
  39:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 220               		.loc 1 39 0
 221 00d0 4083      		st Z,r20
 222               	.LVL13:
 223 00d2 2F5F      		subi r18,-1
 224 00d4 3F4F      		sbci r19,-1
 225               	.LVL14:
  35:LCD.cpp       **** 		if(NbMap[nb] & (1<<j)){
 226               		.loc 1 35 0
 227 00d6 2830      		cpi r18,8
 228 00d8 3105      		cpc r19,__zero_reg__
 229 00da 01F4      		brne .L9
 230               	/* epilogue start */
 231               	.LBE21:
  40:LCD.cpp       **** 		}	
  41:LCD.cpp       **** 	}
  42:LCD.cpp       **** }
 232               		.loc 1 42 0
 233 00dc DF91      		pop r29
 234 00de CF91      		pop r28
 235 00e0 1F91      		pop r17
 236 00e2 0895      		ret
 237               	.L7:
 238               	.LBB22:
  39:LCD.cpp       **** 		}	
 239               		.loc 1 39 0
 240 00e4 4095      		com r20
 241 00e6 4523      		and r20,r21
 242 00e8 00C0      		rjmp .L11
 243               	.LBE22:
 244               		.cfi_endproc
 245               	.LFE12:
 247               	.global	_ZN3LCD8setDigitEhNS_6SymbolE
 249               	_ZN3LCD8setDigitEhNS_6SymbolE:
 250               	.LFB13:
  43:LCD.cpp       **** 
  44:LCD.cpp       **** void LCD::setDigit(uint8_t dig, Symbol sy) {
 251               		.loc 1 44 0
 252               		.cfi_startproc
 253               	.LVL15:
 254 00ea 1F93      		push r17
 255               	.LCFI3:
 256               		.cfi_def_cfa_offset 3
 257               		.cfi_offset 17, -2
 258 00ec CF93      		push r28
 259               	.LCFI4:
 260               		.cfi_def_cfa_offset 4
 261               		.cfi_offset 28, -3
 262 00ee DF93      		push r29
 263               	.LCFI5:
 264               		.cfi_def_cfa_offset 5
 265               		.cfi_offset 29, -4
 266               	/* prologue: function */
 267               	/* frame size = 0 */
 268               	/* stack size = 3 */
 269               	.L__stack_usage = 3
 270               	.LVL16:
 271 00f0 15E1      		ldi r17,lo8(21)
 272 00f2 819F      		mul r24,r17
 273 00f4 C001      		movw r24,r0
 274 00f6 1124      		clr __zero_reg__
 275               	.LVL17:
 276 00f8 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 277 00fa 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 278               		.loc 1 44 0
 279 00fc 30E0      		ldi r19,0
 280 00fe 20E0      		ldi r18,0
 281 0100 A1E0      		ldi r26,lo8(1)
 282 0102 B0E0      		ldi r27,0
 283               	.LBB23:
  45:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  46:LCD.cpp       **** 		if(sy & (1<<j)){
 284               		.loc 1 46 0
 285 0104 70E0      		ldi r23,0
 286               	.LVL18:
 287               	.L15:
 288 0106 F901      		movw r30,r18
 289 0108 EE0F      		lsl r30
 290 010a FF1F      		rol r31
 291 010c E80F      		add r30,r24
 292 010e F91F      		adc r31,r25
 293 0110 0780      		ldd __tmp_reg__,Z+7
 294 0112 F085      		ldd r31,Z+8
 295 0114 E02D      		mov r30,__tmp_reg__
 296 0116 EC01      		movw r28,r24
 297 0118 C20F      		add r28,r18
 298 011a D31F      		adc r29,r19
 299 011c 4881      		ld r20,Y
 300 011e ED01      		movw r28,r26
 301 0120 00C0      		rjmp 2f
 302               		1:
 303 0122 CC0F      		lsl r28
 304 0124 DD1F      		rol r29
 305               		2:
 306 0126 4A95      		dec r20
 307 0128 02F4      		brpl 1b
 308 012a AE01      		movw r20,r28
 309 012c EB01      		movw r28,r22
 310 012e 022E      		mov r0,r18
 311 0130 00C0      		rjmp 2f
 312               		1:
 313 0132 D595      		asr r29
 314 0134 C795      		ror r28
 315               		2:
 316 0136 0A94      		dec r0
 317 0138 02F4      		brpl 1b
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 318               		.loc 1 47 0
 319 013a 5081      		ld r21,Z
  46:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 320               		.loc 1 46 0
 321 013c C0FF      		sbrs r28,0
 322 013e 00C0      		rjmp .L13
 323               		.loc 1 47 0
 324 0140 452B      		or r20,r21
 325               	.L17:
  48:LCD.cpp       **** 		}else{
  49:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 326               		.loc 1 49 0
 327 0142 4083      		st Z,r20
 328               	.LVL19:
 329 0144 2F5F      		subi r18,-1
 330 0146 3F4F      		sbci r19,-1
 331               	.LVL20:
  45:LCD.cpp       **** 		if(sy & (1<<j)){
 332               		.loc 1 45 0
 333 0148 2830      		cpi r18,8
 334 014a 3105      		cpc r19,__zero_reg__
 335 014c 01F4      		brne .L15
 336               	/* epilogue start */
 337               	.LBE23:
  50:LCD.cpp       **** 		}
  51:LCD.cpp       **** 	}
  52:LCD.cpp       **** }
 338               		.loc 1 52 0
 339 014e DF91      		pop r29
 340 0150 CF91      		pop r28
 341 0152 1F91      		pop r17
 342 0154 0895      		ret
 343               	.L13:
 344               	.LBB24:
  49:LCD.cpp       **** 		}
 345               		.loc 1 49 0
 346 0156 4095      		com r20
 347 0158 4523      		and r20,r21
 348 015a 00C0      		rjmp .L17
 349               	.LBE24:
 350               		.cfi_endproc
 351               	.LFE13:
 353               	.global	_ZN3LCD10setBatteryENS_7BatteryE
 355               	_ZN3LCD10setBatteryENS_7BatteryE:
 356               	.LFB14:
  53:LCD.cpp       **** 
  54:LCD.cpp       **** void LCD::setBattery(Battery b) {
 357               		.loc 1 54 0
 358               		.cfi_startproc
 359               	.LVL21:
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
  55:LCD.cpp       **** 	switch(b){
 364               		.loc 1 55 0
 365 015c 8830      		cpi r24,lo8(8)
 366 015e 00F0      		brlo .+2
 367 0160 00C0      		rjmp .L18
 368 0162 E82F      		mov r30,r24
 369 0164 F0E0      		ldi r31,0
 370 0166 E050      		subi r30,lo8(-(gs(.L21)))
 371 0168 F040      		sbci r31,hi8(-(gs(.L21)))
  56:LCD.cpp       **** 	case NONE:
  57:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  58:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  59:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  60:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  61:LCD.cpp       **** 		break;
  62:LCD.cpp       **** 	case EMPTY:
  63:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  64:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  65:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  66:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  67:LCD.cpp       **** 		break;
  68:LCD.cpp       **** 	case FIRST:
  69:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  70:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  71:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  72:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  73:LCD.cpp       **** 		break;
  74:LCD.cpp       **** 	case SECOND:
  75:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  76:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  77:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  78:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  79:LCD.cpp       **** 		break;
  80:LCD.cpp       **** 	case THIRD:
  81:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  82:LCD.cpp       **** 		LCDDR6 |=(1<<4);
  83:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  84:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  85:LCD.cpp       **** 		break;
  86:LCD.cpp       **** 	case ONEBAR:
  87:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  88:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  89:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  90:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  91:LCD.cpp       **** 		break;
  92:LCD.cpp       **** 	case TWOBAR:
  93:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  94:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  95:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  96:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  97:LCD.cpp       **** 		break;
  98:LCD.cpp       **** 	case FULL:
  99:LCD.cpp       **** 		LCDDR1 |=(1<<4);
 372               		.loc 1 99 0
 373 016a 8091 ED00 		lds r24,237
 374               	.LVL22:
  55:LCD.cpp       **** 	switch(b){
 375               		.loc 1 55 0
 376 016e 0C94 0000 		jmp __tablejump2__
 377               		.p2align	1
 378               	.L21:
 379 0172 0000      		.word gs(.L20)
 380 0174 0000      		.word gs(.L22)
 381 0176 0000      		.word gs(.L23)
 382 0178 0000      		.word gs(.L24)
 383 017a 0000      		.word gs(.L25)
 384 017c 0000      		.word gs(.L26)
 385 017e 0000      		.word gs(.L27)
 386 0180 0000      		.word gs(.L28)
 387               	.L20:
  57:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 388               		.loc 1 57 0
 389 0182 8F7E      		andi r24,lo8(-17)
 390               	.L35:
  63:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 391               		.loc 1 63 0
 392 0184 8093 ED00 		sts 237,r24
  64:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 393               		.loc 1 64 0
 394 0188 8091 F200 		lds r24,242
 395 018c 8F7E      		andi r24,lo8(-17)
 396               	.L33:
  82:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 397               		.loc 1 82 0
 398 018e 8093 F200 		sts 242,r24
  83:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 399               		.loc 1 83 0
 400 0192 8091 F700 		lds r24,247
 401 0196 8F7E      		andi r24,lo8(-17)
 402 0198 00C0      		rjmp .L34
 403               	.L22:
  63:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 404               		.loc 1 63 0
 405 019a 8061      		ori r24,lo8(16)
 406 019c 00C0      		rjmp .L35
 407               	.L23:
  69:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 408               		.loc 1 69 0
 409 019e 8F7E      		andi r24,lo8(-17)
 410               	.L32:
  87:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 411               		.loc 1 87 0
 412 01a0 8093 ED00 		sts 237,r24
  88:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 413               		.loc 1 88 0
 414 01a4 8091 F200 		lds r24,242
 415 01a8 8F7E      		andi r24,lo8(-17)
 416 01aa 8093 F200 		sts 242,r24
  89:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 417               		.loc 1 89 0
 418 01ae 8091 F700 		lds r24,247
 419 01b2 8F7E      		andi r24,lo8(-17)
 420               	.L31:
 100:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 101:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 421               		.loc 1 101 0
 422 01b4 8093 F700 		sts 247,r24
 102:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 423               		.loc 1 102 0
 424 01b8 8091 FC00 		lds r24,252
 425 01bc 8061      		ori r24,lo8(16)
 426 01be 00C0      		rjmp .L29
 427               	.L24:
  75:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 428               		.loc 1 75 0
 429 01c0 8F7E      		andi r24,lo8(-17)
 430 01c2 8093 ED00 		sts 237,r24
  76:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 431               		.loc 1 76 0
 432 01c6 8091 F200 		lds r24,242
 433 01ca 8F7E      		andi r24,lo8(-17)
 434 01cc 8093 F200 		sts 242,r24
  77:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 435               		.loc 1 77 0
 436 01d0 8091 F700 		lds r24,247
 437 01d4 8061      		ori r24,lo8(16)
 438               	.L34:
  83:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 439               		.loc 1 83 0
 440 01d6 8093 F700 		sts 247,r24
  84:LCD.cpp       **** 		break;
 441               		.loc 1 84 0
 442 01da 8091 FC00 		lds r24,252
 443 01de 8F7E      		andi r24,lo8(-17)
 444               	.L29:
 445               		.loc 1 102 0
 446 01e0 8093 FC00 		sts 252,r24
 447               	.L18:
 448               	/* epilogue start */
 103:LCD.cpp       **** 		break;
 104:LCD.cpp       **** 	}
 105:LCD.cpp       **** }
 449               		.loc 1 105 0
 450 01e4 0895      		ret
 451               	.L25:
  81:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 452               		.loc 1 81 0
 453 01e6 8F7E      		andi r24,lo8(-17)
 454 01e8 8093 ED00 		sts 237,r24
  82:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 455               		.loc 1 82 0
 456 01ec 8091 F200 		lds r24,242
 457 01f0 8061      		ori r24,lo8(16)
 458 01f2 00C0      		rjmp .L33
 459               	.L26:
  87:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 460               		.loc 1 87 0
 461 01f4 8061      		ori r24,lo8(16)
 462 01f6 00C0      		rjmp .L32
 463               	.L27:
  93:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 464               		.loc 1 93 0
 465 01f8 8061      		ori r24,lo8(16)
 466 01fa 8093 ED00 		sts 237,r24
  94:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 467               		.loc 1 94 0
 468 01fe 8091 F200 		lds r24,242
 469 0202 8F7E      		andi r24,lo8(-17)
 470               	.L30:
 100:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 471               		.loc 1 100 0
 472 0204 8093 F200 		sts 242,r24
 101:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 473               		.loc 1 101 0
 474 0208 8091 F700 		lds r24,247
 475 020c 8061      		ori r24,lo8(16)
 476 020e 00C0      		rjmp .L31
 477               	.L28:
  99:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 478               		.loc 1 99 0
 479 0210 8061      		ori r24,lo8(16)
 480 0212 8093 ED00 		sts 237,r24
 100:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 481               		.loc 1 100 0
 482 0216 8091 F200 		lds r24,242
 483 021a 8061      		ori r24,lo8(16)
 484 021c 00C0      		rjmp .L30
 485               		.cfi_endproc
 486               	.LFE14:
 488               	.global	_ZN3LCD5setDPEb
 490               	_ZN3LCD5setDPEb:
 491               	.LFB15:
 106:LCD.cpp       **** 
 107:LCD.cpp       **** void LCD::setDP(bool b) {
 492               		.loc 1 107 0
 493               		.cfi_startproc
 494               	.LVL23:
 495               	/* prologue: function */
 496               	/* frame size = 0 */
 497               	/* stack size = 0 */
 498               	.L__stack_usage = 0
 108:LCD.cpp       **** 	if(b){
 499               		.loc 1 108 0
 500 021e 8823      		tst r24
 501 0220 01F0      		breq .L37
 502               	.LVL24:
 503               	.LBB27:
 504               	.LBB28:
 109:LCD.cpp       **** 		LCDDR15|=(1<<4);
 505               		.loc 1 109 0
 506 0222 8091 FB00 		lds r24,251
 507               	.LVL25:
 508 0226 8061      		ori r24,lo8(16)
 509               	.LVL26:
 510               	.L39:
 511               	.LBE28:
 512               	.LBE27:
 110:LCD.cpp       **** 	}else{
 111:LCD.cpp       **** 		LCDDR15&=~(1<<4);
 513               		.loc 1 111 0
 514 0228 8093 FB00 		sts 251,r24
 515               	/* epilogue start */
 112:LCD.cpp       **** 	}
 113:LCD.cpp       **** }
 516               		.loc 1 113 0
 517 022c 0895      		ret
 518               	.LVL27:
 519               	.L37:
 111:LCD.cpp       **** 	}
 520               		.loc 1 111 0
 521 022e 8091 FB00 		lds r24,251
 522               	.LVL28:
 523 0232 8F7E      		andi r24,lo8(-17)
 524 0234 00C0      		rjmp .L39
 525               		.cfi_endproc
 526               	.LFE15:
 528               	.global	_ZN3LCD6setClkEb
 530               	_ZN3LCD6setClkEb:
 531               	.LFB16:
 114:LCD.cpp       **** 
 115:LCD.cpp       **** void LCD::setClk(bool b) {
 532               		.loc 1 115 0
 533               		.cfi_startproc
 534               	.LVL29:
 535               	/* prologue: function */
 536               	/* frame size = 0 */
 537               	/* stack size = 0 */
 538               	.L__stack_usage = 0
 116:LCD.cpp       **** 	if(b){
 539               		.loc 1 116 0
 540 0236 8823      		tst r24
 541 0238 01F0      		breq .L41
 542               	.LVL30:
 543               	.LBB31:
 544               	.LBB32:
 117:LCD.cpp       **** 		LCDDR16|=1;
 545               		.loc 1 117 0
 546 023a 8091 FC00 		lds r24,252
 547               	.LVL31:
 548 023e 8160      		ori r24,lo8(1)
 549               	.LVL32:
 550               	.L43:
 551               	.LBE32:
 552               	.LBE31:
 118:LCD.cpp       **** 	}else{
 119:LCD.cpp       **** 		LCDDR16&=~1;
 553               		.loc 1 119 0
 554 0240 8093 FC00 		sts 252,r24
 555               	/* epilogue start */
 120:LCD.cpp       **** 	}
 121:LCD.cpp       **** }
 556               		.loc 1 121 0
 557 0244 0895      		ret
 558               	.LVL33:
 559               	.L41:
 119:LCD.cpp       **** 	}
 560               		.loc 1 119 0
 561 0246 8091 FC00 		lds r24,252
 562               	.LVL34:
 563 024a 8E7F      		andi r24,lo8(-2)
 564 024c 00C0      		rjmp .L43
 565               		.cfi_endproc
 566               	.LFE16:
 568               	.global	_ZN3LCD5getDPEv
 570               	_ZN3LCD5getDPEv:
 571               	.LFB17:
 122:LCD.cpp       **** 
 123:LCD.cpp       **** bool LCD::getDP(void) {
 572               		.loc 1 123 0
 573               		.cfi_startproc
 574               	/* prologue: function */
 575               	/* frame size = 0 */
 576               	/* stack size = 0 */
 577               	.L__stack_usage = 0
 124:LCD.cpp       **** 	return (LCDDR15 & (1<<4));
 578               		.loc 1 124 0
 579 024e 8091 FB00 		lds r24,251
 125:LCD.cpp       **** }
 580               		.loc 1 125 0
 581 0252 8295      		swap r24
 582 0254 8170      		andi r24,1
 583               	/* epilogue start */
 584 0256 0895      		ret
 585               		.cfi_endproc
 586               	.LFE17:
 588               	.global	_ZN3LCD6getClkEv
 590               	_ZN3LCD6getClkEv:
 591               	.LFB18:
 126:LCD.cpp       **** 
 127:LCD.cpp       **** bool LCD::getClk(void) {
 592               		.loc 1 127 0
 593               		.cfi_startproc
 594               	/* prologue: function */
 595               	/* frame size = 0 */
 596               	/* stack size = 0 */
 597               	.L__stack_usage = 0
 128:LCD.cpp       **** 	return (LCDDR16 & 1);
 598               		.loc 1 128 0
 599 0258 8091 FC00 		lds r24,252
 129:LCD.cpp       **** }
 600               		.loc 1 129 0
 601 025c 8170      		andi r24,lo8(1)
 602               	/* epilogue start */
 603 025e 0895      		ret
 604               		.cfi_endproc
 605               	.LFE18:
 607               	.global	_ZN3LCD5setNbElh
 609               	_ZN3LCD5setNbElh:
 610               	.LFB19:
 130:LCD.cpp       **** 
 131:LCD.cpp       **** 
 132:LCD.cpp       **** 
 133:LCD.cpp       **** uint8_t LCD::setNb(int32_t nb, uint8_t dig) {
 611               		.loc 1 133 0
 612               		.cfi_startproc
 613               	.LVL35:
 614 0260 4F92      		push r4
 615               	.LCFI6:
 616               		.cfi_def_cfa_offset 3
 617               		.cfi_offset 4, -2
 618 0262 5F92      		push r5
 619               	.LCFI7:
 620               		.cfi_def_cfa_offset 4
 621               		.cfi_offset 5, -3
 622 0264 6F92      		push r6
 623               	.LCFI8:
 624               		.cfi_def_cfa_offset 5
 625               		.cfi_offset 6, -4
 626 0266 7F92      		push r7
 627               	.LCFI9:
 628               		.cfi_def_cfa_offset 6
 629               		.cfi_offset 7, -5
 630 0268 8F92      		push r8
 631               	.LCFI10:
 632               		.cfi_def_cfa_offset 7
 633               		.cfi_offset 8, -6
 634 026a 9F92      		push r9
 635               	.LCFI11:
 636               		.cfi_def_cfa_offset 8
 637               		.cfi_offset 9, -7
 638 026c AF92      		push r10
 639               	.LCFI12:
 640               		.cfi_def_cfa_offset 9
 641               		.cfi_offset 10, -8
 642 026e BF92      		push r11
 643               	.LCFI13:
 644               		.cfi_def_cfa_offset 10
 645               		.cfi_offset 11, -9
 646 0270 CF92      		push r12
 647               	.LCFI14:
 648               		.cfi_def_cfa_offset 11
 649               		.cfi_offset 12, -10
 650 0272 DF92      		push r13
 651               	.LCFI15:
 652               		.cfi_def_cfa_offset 12
 653               		.cfi_offset 13, -11
 654 0274 EF92      		push r14
 655               	.LCFI16:
 656               		.cfi_def_cfa_offset 13
 657               		.cfi_offset 14, -12
 658 0276 FF92      		push r15
 659               	.LCFI17:
 660               		.cfi_def_cfa_offset 14
 661               		.cfi_offset 15, -13
 662 0278 0F93      		push r16
 663               	.LCFI18:
 664               		.cfi_def_cfa_offset 15
 665               		.cfi_offset 16, -14
 666 027a 1F93      		push r17
 667               	.LCFI19:
 668               		.cfi_def_cfa_offset 16
 669               		.cfi_offset 17, -15
 670 027c CF93      		push r28
 671               	.LCFI20:
 672               		.cfi_def_cfa_offset 17
 673               		.cfi_offset 28, -16
 674 027e DF93      		push r29
 675               	.LCFI21:
 676               		.cfi_def_cfa_offset 18
 677               		.cfi_offset 29, -17
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 16 */
 681               	.L__stack_usage = 16
 682 0280 6B01      		movw r12,r22
 683 0282 7C01      		movw r14,r24
 684 0284 C42F      		mov r28,r20
 134:LCD.cpp       **** 	if(nb>999999 || nb <-99999){
 685               		.loc 1 134 0
 686 0286 DC01      		movw r26,r24
 687 0288 CB01      		movw r24,r22
 688 028a 8156      		subi r24,97
 689 028c 9947      		sbci r25,121
 690 028e AE4F      		sbci r26,-2
 691 0290 BF4F      		sbci r27,-1
 692 0292 8F3D      		cpi r24,-33
 693 0294 984C      		sbci r25,-56
 694 0296 A041      		sbci r26,16
 695 0298 B105      		cpc r27,__zero_reg__
 696 029a 00F0      		brlo .+2
 697 029c 00C0      		rjmp .L53
 698               	.LVL36:
 699               	.LBB35:
 700               	.LBB36:
 135:LCD.cpp       **** 		return 1;
 136:LCD.cpp       **** 	}
 137:LCD.cpp       **** 	int8_t d=5;
 138:LCD.cpp       **** 	uint8_t min=6-dig;
 701               		.loc 1 138 0
 702 029e 86E0      		ldi r24,lo8(6)
 703 02a0 841B      		sub r24,r20
 704               	.LVL37:
 139:LCD.cpp       **** 	if(nb<0){
 705               		.loc 1 139 0
 706 02a2 F7FE      		sbrs r15,7
 707 02a4 00C0      		rjmp .L48
 140:LCD.cpp       **** 		setDigit(min,Minus);
 708               		.loc 1 140 0
 709 02a6 60E4      		ldi r22,lo8(64)
 710               	.LVL38:
 711 02a8 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 712               	.LVL39:
 141:LCD.cpp       **** 		min++;
 713               		.loc 1 141 0
 714 02ac 87E0      		ldi r24,lo8(7)
 715               	.LVL40:
 716 02ae 8C1B      		sub r24,r28
 717               	.LVL41:
 142:LCD.cpp       **** 		nb=(~nb)+1;
 718               		.loc 1 142 0
 719 02b0 F094      		com r15
 720 02b2 E094      		com r14
 721 02b4 D094      		com r13
 722 02b6 C094      		com r12
 723 02b8 C11C      		adc r12,__zero_reg__
 724 02ba D11C      		adc r13,__zero_reg__
 725 02bc E11C      		adc r14,__zero_reg__
 726 02be F11C      		adc r15,__zero_reg__
 727               	.LVL42:
 728               	.L48:
 729               	.LBE36:
 730               	.LBE35:
 133:LCD.cpp       **** 	if(nb>999999 || nb <-99999){
 731               		.loc 1 133 0
 732 02c0 15E0      		ldi r17,lo8(5)
 733               	.LBB39:
 734               	.LBB37:
 143:LCD.cpp       **** 	}
 144:LCD.cpp       **** 	while(d>=min){
 735               		.loc 1 144 0
 736 02c2 C82F      		mov r28,r24
 737               	.LVL43:
 738 02c4 D0E0      		ldi r29,0
 145:LCD.cpp       **** 		setDigit(d--,nb%10);
 739               		.loc 1 145 0
 740 02c6 8AE0      		ldi r24,lo8(10)
 741 02c8 482E      		mov r4,r24
 742 02ca 512C      		mov r5,__zero_reg__
 743 02cc 612C      		mov r6,__zero_reg__
 744 02ce 712C      		mov r7,__zero_reg__
 745               	.LVL44:
 746               	.L50:
 144:LCD.cpp       **** 		setDigit(d--,nb%10);
 747               		.loc 1 144 0
 748 02d0 812F      		mov r24,r17
 749 02d2 012E      		mov __tmp_reg__,r17
 750 02d4 000C      		lsl r0
 751 02d6 990B      		sbc r25,r25
 752 02d8 8C17      		cp r24,r28
 753 02da 9D07      		cpc r25,r29
 754 02dc 04F4      		brge .L49
 755               	.LVL45:
 756               	.L51:
 757               	.LBE37:
 758               	.LBE39:
 135:LCD.cpp       **** 	}
 759               		.loc 1 135 0
 760 02de 80E0      		ldi r24,0
 761               	.LVL46:
 762               	.L46:
 763               	/* epilogue start */
 146:LCD.cpp       **** 		nb/=10;
 147:LCD.cpp       **** 		if(nb==0)break;
 148:LCD.cpp       **** 	}
 149:LCD.cpp       **** 	while(d>=min)setDigit(d--,Blank);
 150:LCD.cpp       **** 	return 0;
 151:LCD.cpp       **** }
 764               		.loc 1 151 0
 765 02e0 DF91      		pop r29
 766 02e2 CF91      		pop r28
 767 02e4 1F91      		pop r17
 768 02e6 0F91      		pop r16
 769 02e8 FF90      		pop r15
 770 02ea EF90      		pop r14
 771 02ec DF90      		pop r13
 772 02ee CF90      		pop r12
 773 02f0 BF90      		pop r11
 774 02f2 AF90      		pop r10
 775 02f4 9F90      		pop r9
 776 02f6 8F90      		pop r8
 777 02f8 7F90      		pop r7
 778 02fa 6F90      		pop r6
 779 02fc 5F90      		pop r5
 780 02fe 4F90      		pop r4
 781 0300 0895      		ret
 782               	.LVL47:
 783               	.L49:
 784               	.LBB40:
 785               	.LBB38:
 145:LCD.cpp       **** 		nb/=10;
 786               		.loc 1 145 0
 787 0302 C701      		movw r24,r14
 788 0304 B601      		movw r22,r12
 789 0306 A301      		movw r20,r6
 790 0308 9201      		movw r18,r4
 791 030a 0E94 0000 		call __divmodsi4
 792 030e 4901      		movw r8,r18
 793 0310 5A01      		movw r10,r20
 794 0312 812F      		mov r24,r17
 795 0314 1150      		subi r17,lo8(-(-1))
 796               	.LVL48:
 797 0316 0E94 0000 		call _ZN3LCD8setDigitEhh
 798               	.LVL49:
 146:LCD.cpp       **** 		nb/=10;
 799               		.loc 1 146 0
 800 031a 6401      		movw r12,r8
 801               	.LVL50:
 802 031c 7501      		movw r14,r10
 803               	.LVL51:
 147:LCD.cpp       **** 	}
 804               		.loc 1 147 0
 805 031e C114      		cp r12,__zero_reg__
 806 0320 D104      		cpc r13,__zero_reg__
 807 0322 E104      		cpc r14,__zero_reg__
 808 0324 F104      		cpc r15,__zero_reg__
 809 0326 01F4      		brne .L50
 810               	.LVL52:
 811               	.L52:
 149:LCD.cpp       **** 	return 0;
 812               		.loc 1 149 0
 813 0328 812F      		mov r24,r17
 814 032a 012E      		mov __tmp_reg__,r17
 815 032c 000C      		lsl r0
 816 032e 990B      		sbc r25,r25
 817 0330 8C17      		cp r24,r28
 818 0332 9D07      		cpc r25,r29
 819 0334 04F0      		brlt .L51
 820               	.LVL53:
 821 0336 60E0      		ldi r22,0
 822 0338 812F      		mov r24,r17
 823 033a 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 824               	.LVL54:
 825 033e 1150      		subi r17,lo8(-(-1))
 826               	.LVL55:
 827 0340 00C0      		rjmp .L52
 828               	.LVL56:
 829               	.L53:
 830               	.LBE38:
 831               	.LBE40:
 135:LCD.cpp       **** 	}
 832               		.loc 1 135 0
 833 0342 81E0      		ldi r24,lo8(1)
 834 0344 00C0      		rjmp .L46
 835               		.cfi_endproc
 836               	.LFE19:
 838               	.global	_ZN3LCD5setNbEl
 840               	_ZN3LCD5setNbEl:
 841               	.LFB20:
 152:LCD.cpp       **** 
 153:LCD.cpp       **** uint8_t LCD::setNb(int32_t nb) {
 842               		.loc 1 153 0
 843               		.cfi_startproc
 844               	.LVL57:
 845               	/* prologue: function */
 846               	/* frame size = 0 */
 847               	/* stack size = 0 */
 848               	.L__stack_usage = 0
 154:LCD.cpp       **** 	return setNb(nb,6);
 849               		.loc 1 154 0
 850 0346 46E0      		ldi r20,lo8(6)
 851 0348 0C94 0000 		jmp _ZN3LCD5setNbElh
 852               	.LVL58:
 853               		.cfi_endproc
 854               	.LFE20:
 856               	.global	_ZN3LCD5clearEb
 858               	_ZN3LCD5clearEb:
 859               	.LFB22:
 155:LCD.cpp       **** }
 156:LCD.cpp       **** 
 157:LCD.cpp       **** void LCD::clear(void) {
 158:LCD.cpp       **** 	clear(true);
 159:LCD.cpp       **** }
 160:LCD.cpp       **** void LCD::clear(bool clearBatt) {
 860               		.loc 1 160 0
 861               		.cfi_startproc
 862               	.LVL59:
 863 034c CF93      		push r28
 864               	.LCFI22:
 865               		.cfi_def_cfa_offset 3
 866               		.cfi_offset 28, -2
 867               	/* prologue: function */
 868               	/* frame size = 0 */
 869               	/* stack size = 1 */
 870               	.L__stack_usage = 1
 161:LCD.cpp       **** 	if(clearBatt)setBattery(NONE);
 871               		.loc 1 161 0
 872 034e 8823      		tst r24
 873 0350 01F0      		breq .L57
 874               		.loc 1 161 0 is_stmt 0 discriminator 1
 875 0352 80E0      		ldi r24,0
 876               	.LVL60:
 877 0354 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 878               	.LVL61:
 879               	.L57:
 162:LCD.cpp       **** 	setClk(false);
 880               		.loc 1 162 0 is_stmt 1
 881 0358 80E0      		ldi r24,0
 882 035a 0E94 0000 		call _ZN3LCD6setClkEb
 883               	.LVL62:
 163:LCD.cpp       **** 	setDP(false);
 884               		.loc 1 163 0
 885 035e 80E0      		ldi r24,0
 886 0360 0E94 0000 		call _ZN3LCD5setDPEb
 887               	.LVL63:
 888               	.LBB41:
 164:LCD.cpp       **** 	for(int8_t i=5;i>=0;i--)setDigit(i,Blank);
 889               		.loc 1 164 0
 890 0364 C5E0      		ldi r28,lo8(5)
 891               	.LVL64:
 892               	.L58:
 893               		.loc 1 164 0 is_stmt 0 discriminator 2
 894 0366 60E0      		ldi r22,0
 895 0368 8C2F      		mov r24,r28
 896 036a 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 897               	.LVL65:
 898               	.LVL66:
 899 036e C150      		subi r28,1
 900 0370 00F4      		brcc .L58
 901               	/* epilogue start */
 902               	.LBE41:
 165:LCD.cpp       **** }
 903               		.loc 1 165 0 is_stmt 1
 904 0372 CF91      		pop r28
 905               	.LVL67:
 906 0374 0895      		ret
 907               		.cfi_endproc
 908               	.LFE22:
 910               	.global	_ZN3LCD5clearEv
 912               	_ZN3LCD5clearEv:
 913               	.LFB21:
 157:LCD.cpp       **** 	clear(true);
 914               		.loc 1 157 0
 915               		.cfi_startproc
 916               	/* prologue: function */
 917               	/* frame size = 0 */
 918               	/* stack size = 0 */
 919               	.L__stack_usage = 0
 158:LCD.cpp       **** }
 920               		.loc 1 158 0
 921 0376 81E0      		ldi r24,lo8(1)
 922 0378 0C94 0000 		jmp _ZN3LCD5clearEb
 923               	.LVL68:
 924               		.cfi_endproc
 925               	.LFE21:
 927               	.global	_ZN3LCD6digitsE
 928               		.data
 931               	_ZN3LCD6digitsE:
 932 0000 02        		.byte	2
 933 0001 02        		.byte	2
 934 0002 02        		.byte	2
 935 0003 03        		.byte	3
 936 0004 03        		.byte	3
 937 0005 03        		.byte	3
 938 0006 03        		.byte	3
 939 0007 ED00      		.word	237
 940 0009 F200      		.word	242
 941 000b F700      		.word	247
 942 000d FC00      		.word	252
 943 000f F700      		.word	247
 944 0011 ED00      		.word	237
 945 0013 F200      		.word	242
 946 0015 00        		.byte	0
 947 0016 00        		.byte	0
 948 0017 00        		.byte	0
 949 0018 01        		.byte	1
 950 0019 01        		.byte	1
 951 001a 01        		.byte	1
 952 001b 01        		.byte	1
 953 001c ED00      		.word	237
 954 001e F200      		.word	242
 955 0020 F700      		.word	247
 956 0022 FC00      		.word	252
 957 0024 F700      		.word	247
 958 0026 ED00      		.word	237
 959 0028 F200      		.word	242
 960 002a 06        		.byte	6
 961 002b 06        		.byte	6
 962 002c 06        		.byte	6
 963 002d 07        		.byte	7
 964 002e 07        		.byte	7
 965 002f 07        		.byte	7
 966 0030 07        		.byte	7
 967 0031 EC00      		.word	236
 968 0033 F100      		.word	241
 969 0035 F600      		.word	246
 970 0037 FB00      		.word	251
 971 0039 F600      		.word	246
 972 003b EC00      		.word	236
 973 003d F100      		.word	241
 974 003f 04        		.byte	4
 975 0040 04        		.byte	4
 976 0041 04        		.byte	4
 977 0042 05        		.byte	5
 978 0043 05        		.byte	5
 979 0044 05        		.byte	5
 980 0045 05        		.byte	5
 981 0046 EC00      		.word	236
 982 0048 F100      		.word	241
 983 004a F600      		.word	246
 984 004c FB00      		.word	251
 985 004e F600      		.word	246
 986 0050 EC00      		.word	236
 987 0052 F100      		.word	241
 988 0054 02        		.byte	2
 989 0055 02        		.byte	2
 990 0056 02        		.byte	2
 991 0057 03        		.byte	3
 992 0058 03        		.byte	3
 993 0059 03        		.byte	3
 994 005a 03        		.byte	3
 995 005b EC00      		.word	236
 996 005d F100      		.word	241
 997 005f F600      		.word	246
 998 0061 FB00      		.word	251
 999 0063 F600      		.word	246
 1000 0065 EC00      		.word	236
 1001 0067 F100      		.word	241
 1002 0069 00        		.byte	0
 1003 006a 00        		.byte	0
 1004 006b 00        		.byte	0
 1005 006c 01        		.byte	1
 1006 006d 01        		.byte	1
 1007 006e 01        		.byte	1
 1008 006f 01        		.byte	1
 1009 0070 EC00      		.word	236
 1010 0072 F100      		.word	241
 1011 0074 F600      		.word	246
 1012 0076 FB00      		.word	251
 1013 0078 F600      		.word	246
 1014 007a EC00      		.word	236
 1015 007c F100      		.word	241
 1016               	.global	_ZN3LCD5NbMapE
 1017               		.section	.rodata
 1020               	_ZN3LCD5NbMapE:
 1021 0000 3F        		.byte	63
 1022 0001 06        		.byte	6
 1023 0002 5B        		.byte	91
 1024 0003 4F        		.byte	79
 1025 0004 66        		.byte	102
 1026 0005 6D        		.byte	109
 1027 0006 7D        		.byte	125
 1028 0007 07        		.byte	7
 1029 0008 7F        		.byte	127
 1030 0009 6F        		.byte	111
 1031               		.text
 1032               	.Letext0:
 1033               		.file 3 "/usr/lib/avr/include/stdint.h"
 1034               		.file 4 "LCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD.cpp
     /tmp/ccWIwtrb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccWIwtrb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccWIwtrb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccWIwtrb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccWIwtrb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccWIwtrb.s:12     .text:0000000000000000 _ZN3LCDC2Eb
     /tmp/ccWIwtrb.s:12     .text:0000000000000000 _ZN3LCDC1Eb
     /tmp/ccWIwtrb.s:89     .text:000000000000004a _ZN3LCDD2Ev
     /tmp/ccWIwtrb.s:89     .text:000000000000004a _ZN3LCDD1Ev
     /tmp/ccWIwtrb.s:138    .text:000000000000006e _ZN3LCD8setDigitEhh
     /tmp/ccWIwtrb.s:1020   .rodata:0000000000000000 _ZN3LCD5NbMapE
     /tmp/ccWIwtrb.s:931    .data:0000000000000000 _ZN3LCD6digitsE
     /tmp/ccWIwtrb.s:249    .text:00000000000000ea _ZN3LCD8setDigitEhNS_6SymbolE
     /tmp/ccWIwtrb.s:355    .text:000000000000015c _ZN3LCD10setBatteryENS_7BatteryE
     /tmp/ccWIwtrb.s:490    .text:000000000000021e _ZN3LCD5setDPEb
     /tmp/ccWIwtrb.s:530    .text:0000000000000236 _ZN3LCD6setClkEb
     /tmp/ccWIwtrb.s:570    .text:000000000000024e _ZN3LCD5getDPEv
     /tmp/ccWIwtrb.s:590    .text:0000000000000258 _ZN3LCD6getClkEv
     /tmp/ccWIwtrb.s:609    .text:0000000000000260 _ZN3LCD5setNbElh
     /tmp/ccWIwtrb.s:840    .text:0000000000000346 _ZN3LCD5setNbEl
     /tmp/ccWIwtrb.s:858    .text:000000000000034c _ZN3LCD5clearEb
     /tmp/ccWIwtrb.s:912    .text:0000000000000376 _ZN3LCD5clearEv

UNDEFINED SYMBOLS
__tablejump2__
__divmodsi4
__do_copy_data
