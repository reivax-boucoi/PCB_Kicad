   1               		.file	"main.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 5374 6172 		.string	"Start verbose streaming"
  12      7420 7665 
  12      7262 6F73 
  12      6520 7374 
  12      7265 616D 
  13               		.section	.text.startup,"ax",@progbits
  14               	.global	main
  16               	main:
  17               	.LFB10:
  18               		.file 1 "main.cpp"
   1:main.cpp      **** #include <avr/io.h>
   2:main.cpp      **** #include <avr/interrupt.h>
   3:main.cpp      **** #include <avr/sleep.h>
   4:main.cpp      **** #include <util/delay.h>
   5:main.cpp      **** #include <stdlib.h> //for itoa
   6:main.cpp      **** 
   7:main.cpp      **** #include "state_machine.h"
   8:main.cpp      **** #include "LCD.h"
   9:main.cpp      **** #include "UART.h"
  10:main.cpp      **** 
  11:main.cpp      **** #define LED0_ON (PORTD|=(1<<6))
  12:main.cpp      **** #define LED0_OFF (PORTD&=~(1<<6))
  13:main.cpp      **** #define LED0_Toggle (PORTD^=(1<<6))
  14:main.cpp      **** 
  15:main.cpp      **** #define LED1_ON (PORTD|=(1<<7))
  16:main.cpp      **** #define LED1_OFF (PORTD&=~(1<<7))
  17:main.cpp      **** #define LED1_Toggle (PORTD^=(1<<7))
  18:main.cpp      **** 
  19:main.cpp      **** #define BTN0 (PIND&(1<<4))
  20:main.cpp      **** #define BTN1 (PIND&(1<<5))
  21:main.cpp      **** 
  22:main.cpp      **** #define IRQ_STATE (PINE&(1<<7))
  23:main.cpp      **** 
  24:main.cpp      **** #define PWR_en_ON (PORTE|=(1<<5))
  25:main.cpp      **** #define PWR_en_OFF (PORTE&=~(1<<6))
  26:main.cpp      **** #define LoadCell_en_ON (PORTE|=(1<<7))
  27:main.cpp      **** #define LoadCell_en_OFF (PORTE&=~(1<<7))
  28:main.cpp      **** 
  29:main.cpp      **** #define BATT_CUTOUT 295
  30:main.cpp      **** #define BATT_EMPTY 305
  31:main.cpp      **** #define BATT_ONEBAR 315
  32:main.cpp      **** #define BATT_TWOBAR 325
  33:main.cpp      **** #define BATT_FULL 335
  34:main.cpp      **** 
  35:main.cpp      **** UART uart;
  36:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
  37:main.cpp      **** //Scale myScale=Scale(&uart);
  38:main.cpp      **** //SM mySM(&uart, &myScale,&myLCD);
  39:main.cpp      **** 
  40:main.cpp      **** //Fuses -U lfuse:w:0xe2:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m 
  41:main.cpp      **** //Int RC osc, 6CK+65ms startup time
  42:main.cpp      **** //No Clock div by 8
  43:main.cpp      **** //Brown out detection enabled, 1.8V
  44:main.cpp      **** //For BoD at 2.7V, use Efuse=FB instead of FD
  45:main.cpp      **** 
  46:main.cpp      **** volatile uint8_t loop_cnt=0;
  47:main.cpp      **** volatile uint8_t btn_state=0;
  48:main.cpp      **** 
  49:main.cpp      **** int main(void){
  19               		.loc 1 49 0
  20               		.cfi_startproc
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  50:main.cpp      **** 	
  51:main.cpp      **** 	DDRD=0b11000000; 	//LED0, LED1 as outputs, BTN 0/1 as inputs
  25               		.loc 1 51 0
  26 0000 80EC      		ldi r24,lo8(-64)
  27 0002 8AB9      		out 0xa,r24
  52:main.cpp      **** 	PORTD=0b00110000;			//LED initial state:low, enable BTN pullups
  28               		.loc 1 52 0
  29 0004 80E3      		ldi r24,lo8(48)
  30 0006 8BB9      		out 0xb,r24
  53:main.cpp      **** 	
  54:main.cpp      **** 	DDRE=0b01100011;//IRQ as input, LoadCell_en/PWR_en as outputs, TX as output, RX as input
  31               		.loc 1 54 0
  32 0008 83E6      		ldi r24,lo8(99)
  33 000a 8DB9      		out 0xd,r24
  55:main.cpp      **** 	PORTE=0b11100000;//Enable IRQ pullup, set LoadCell_en/PWR_en to 1
  34               		.loc 1 55 0
  35 000c 80EE      		ldi r24,lo8(-32)
  36 000e 8EB9      		out 0xe,r24
  56:main.cpp      **** 	
  57:main.cpp      **** 	LED0_ON;
  37               		.loc 1 57 0
  38 0010 5E9A      		sbi 0xb,6
  58:main.cpp      **** 	LED1_ON;
  39               		.loc 1 58 0
  40 0012 5F9A      		sbi 0xb,7
  59:main.cpp      **** 	//PRR|=(1<<PRTIM1);//Shut down clock to Timer1
  60:main.cpp      **** 	
  61:main.cpp      **** 	ADMUX|=(1<<REFS0)|0b11110;//Set AVCC as reference voltage for ADC, ADC MUX input to 1.1V BG
  41               		.loc 1 61 0
  42 0014 8091 7C00 		lds r24,124
  43 0018 8E65      		ori r24,lo8(94)
  44 001a 8093 7C00 		sts 124,r24
  62:main.cpp      **** 	ADCSRA|=(1<<ADEN)|(1<<ADIE)|(1<<ADPS1);//Enable conversin complete interrupt, Clock prescaler 12MH
  45               		.loc 1 62 0
  46 001e 8091 7A00 		lds r24,122
  47 0022 8A68      		ori r24,lo8(-118)
  48 0024 8093 7A00 		sts 122,r24
  63:main.cpp      **** 	sei();
  49               		.loc 1 63 0
  50               	/* #APP */
  51               	 ;  63 "main.cpp" 1
  52 0028 7894      		sei
  53               	 ;  0 "" 2
  64:main.cpp      **** 	
  65:main.cpp      **** 	myLCD.setNb(12345,5);
  54               		.loc 1 65 0
  55               	/* #NOAPP */
  56 002a 45E0      		ldi r20,lo8(5)
  57 002c 69E3      		ldi r22,lo8(57)
  58 002e 70E3      		ldi r23,lo8(48)
  59 0030 80E0      		ldi r24,0
  60 0032 90E0      		ldi r25,0
  61 0034 0E94 0000 		call _ZN3LCD5setNbElh
  62               	.LVL0:
  66:main.cpp      **** 	myLCD.setBattery(LCD::FULL);
  63               		.loc 1 66 0
  64 0038 87E0      		ldi r24,lo8(7)
  65 003a 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
  66               	.LVL1:
  67               	.LBB9:
  67:main.cpp      **** 	
  68:main.cpp      **** 	while(1){
  69:main.cpp      **** 	
  70:main.cpp      **** 		_delay_ms(10);
  71:main.cpp      **** 		loop_cnt++;
  72:main.cpp      **** 		if(loop_cnt>9){
  73:main.cpp      **** 			loop_cnt=0;
  74:main.cpp      **** 			//mySM.update();
  75:main.cpp      **** 		}
  76:main.cpp      **** 
  77:main.cpp      **** 		if(BTN0!=btn_state){
  78:main.cpp      **** 			btn_state=BTN0;
  79:main.cpp      **** 			if(btn_state){
  80:main.cpp      **** 				LED0_Toggle;
  68               		.loc 1 80 0
  69 003e C0E4      		ldi r28,lo8(64)
  70               	.L6:
  71               	.LVL2:
  72               	.LBB10:
  73               	.LBB11:
  74               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  75               		.loc 2 187 0
  76 0040 8FE1      		ldi r24,lo8(19999)
  77 0042 9EE4      		ldi r25,hi8(19999)
  78 0044 0197      	1:	sbiw r24,1
  79 0046 01F4      		brne 1b
  80 0048 00C0      		rjmp .
  81 004a 0000      		nop
  82               	.LVL3:
  83               	.LBE11:
  84               	.LBE10:
  71:main.cpp      **** 		if(loop_cnt>9){
  85               		.loc 1 71 0
  86 004c 8091 0000 		lds r24,loop_cnt
  87 0050 8F5F      		subi r24,lo8(-(1))
  88 0052 8093 0000 		sts loop_cnt,r24
  72:main.cpp      **** 			loop_cnt=0;
  89               		.loc 1 72 0
  90 0056 8091 0000 		lds r24,loop_cnt
  91 005a 8A30      		cpi r24,lo8(10)
  92 005c 00F0      		brlo .L2
  73:main.cpp      **** 			//mySM.update();
  93               		.loc 1 73 0
  94 005e 1092 0000 		sts loop_cnt,__zero_reg__
  95               	.L2:
  77:main.cpp      **** 			btn_state=BTN0;
  96               		.loc 1 77 0
  97 0062 89B1      		in r24,0x9
  98 0064 9091 0000 		lds r25,btn_state
  99 0068 8071      		andi r24,lo8(16)
 100 006a 8917      		cp r24,r25
 101 006c 01F0      		breq .L4
  78:main.cpp      **** 			if(btn_state){
 102               		.loc 1 78 0
 103 006e 89B1      		in r24,0x9
 104 0070 8071      		andi r24,lo8(16)
 105 0072 8093 0000 		sts btn_state,r24
  79:main.cpp      **** 				LED0_Toggle;
 106               		.loc 1 79 0
 107 0076 8091 0000 		lds r24,btn_state
 108 007a 8823      		tst r24
 109 007c 01F0      		breq .L4
 110               		.loc 1 80 0
 111 007e 8BB1      		in r24,0xb
 112 0080 8C27      		eor r24,r28
 113 0082 8BB9      		out 0xb,r24
 114               	.L4:
 115               	.LBB12:
  81:main.cpp      **** 			}
  82:main.cpp      **** 		}
  83:main.cpp      **** 		if(uart.isDataAvailable()){
 116               		.loc 1 83 0
 117 0084 80E0      		ldi r24,lo8(uart)
 118 0086 90E0      		ldi r25,hi8(uart)
 119 0088 0E94 0000 		call _ZN4UART15isDataAvailableEv
 120               	.LVL4:
 121 008c 8823      		tst r24
 122 008e 01F0      		breq .L6
 123               	.LBB13:
  84:main.cpp      **** 			char *cmd=uart.retrieve();
 124               		.loc 1 84 0
 125 0090 80E0      		ldi r24,lo8(uart)
 126 0092 90E0      		ldi r25,hi8(uart)
 127 0094 0E94 0000 		call _ZN4UART8retrieveEv
 128               	.LVL5:
  85:main.cpp      **** 			uart.sendString("Start verbose streaming",true);
 129               		.loc 1 85 0
 130 0098 41E0      		ldi r20,lo8(1)
 131 009a 60E0      		ldi r22,lo8(.LC0)
 132 009c 70E0      		ldi r23,hi8(.LC0)
 133 009e 80E0      		ldi r24,lo8(uart)
 134 00a0 90E0      		ldi r25,hi8(uart)
 135 00a2 0E94 0000 		call _ZN4UART10sendStringEPcb
 136               	.LVL6:
 137               	.LBE13:
 138 00a6 00C0      		rjmp .L6
 139               	.LBE12:
 140               	.LBE9:
 141               		.cfi_endproc
 142               	.LFE10:
 144               	.global	__floatunsisf
 145               	.global	__divsf3
 146               	.global	__fixunssfsi
 147               		.text
 148               	.global	__vector_19
 150               	__vector_19:
 151               	.LFB11:
  86:main.cpp      **** 		}
  87:main.cpp      **** 	}
  88:main.cpp      **** 
  89:main.cpp      **** 	return 0;
  90:main.cpp      **** }
  91:main.cpp      **** 
  92:main.cpp      **** 
  93:main.cpp      **** 
  94:main.cpp      **** 
  95:main.cpp      **** ISR(ADC_vect){
 152               		.loc 1 95 0
 153               		.cfi_startproc
 154 0000 1F92      		push r1
 155               	.LCFI0:
 156               		.cfi_def_cfa_offset 3
 157               		.cfi_offset 1, -2
 158 0002 0F92      		push r0
 159               	.LCFI1:
 160               		.cfi_def_cfa_offset 4
 161               		.cfi_offset 0, -3
 162 0004 0FB6      		in r0,__SREG__
 163 0006 0F92      		push r0
 164 0008 1124      		clr __zero_reg__
 165 000a CF92      		push r12
 166               	.LCFI2:
 167               		.cfi_def_cfa_offset 5
 168               		.cfi_offset 12, -4
 169 000c DF92      		push r13
 170               	.LCFI3:
 171               		.cfi_def_cfa_offset 6
 172               		.cfi_offset 13, -5
 173 000e EF92      		push r14
 174               	.LCFI4:
 175               		.cfi_def_cfa_offset 7
 176               		.cfi_offset 14, -6
 177 0010 FF92      		push r15
 178               	.LCFI5:
 179               		.cfi_def_cfa_offset 8
 180               		.cfi_offset 15, -7
 181 0012 2F93      		push r18
 182               	.LCFI6:
 183               		.cfi_def_cfa_offset 9
 184               		.cfi_offset 18, -8
 185 0014 3F93      		push r19
 186               	.LCFI7:
 187               		.cfi_def_cfa_offset 10
 188               		.cfi_offset 19, -9
 189 0016 4F93      		push r20
 190               	.LCFI8:
 191               		.cfi_def_cfa_offset 11
 192               		.cfi_offset 20, -10
 193 0018 5F93      		push r21
 194               	.LCFI9:
 195               		.cfi_def_cfa_offset 12
 196               		.cfi_offset 21, -11
 197 001a 6F93      		push r22
 198               	.LCFI10:
 199               		.cfi_def_cfa_offset 13
 200               		.cfi_offset 22, -12
 201 001c 7F93      		push r23
 202               	.LCFI11:
 203               		.cfi_def_cfa_offset 14
 204               		.cfi_offset 23, -13
 205 001e 8F93      		push r24
 206               	.LCFI12:
 207               		.cfi_def_cfa_offset 15
 208               		.cfi_offset 24, -14
 209 0020 9F93      		push r25
 210               	.LCFI13:
 211               		.cfi_def_cfa_offset 16
 212               		.cfi_offset 25, -15
 213 0022 AF93      		push r26
 214               	.LCFI14:
 215               		.cfi_def_cfa_offset 17
 216               		.cfi_offset 26, -16
 217 0024 BF93      		push r27
 218               	.LCFI15:
 219               		.cfi_def_cfa_offset 18
 220               		.cfi_offset 27, -17
 221 0026 EF93      		push r30
 222               	.LCFI16:
 223               		.cfi_def_cfa_offset 19
 224               		.cfi_offset 30, -18
 225 0028 FF93      		push r31
 226               	.LCFI17:
 227               		.cfi_def_cfa_offset 20
 228               		.cfi_offset 31, -19
 229               	/* prologue: Signal */
 230               	/* frame size = 0 */
 231               	/* stack size = 19 */
 232               	.L__stack_usage = 19
  96:main.cpp      **** 	uint16_t ADC_val=ADCL;
 233               		.loc 1 96 0
 234 002a 6091 7800 		lds r22,120
 235               	.LVL7:
  97:main.cpp      **** 	ADC_val+=ADCH<<8;
 236               		.loc 1 97 0
 237 002e 8091 7900 		lds r24,121
 238               	.LVL8:
 239 0032 90E0      		ldi r25,0
 240 0034 982F      		mov r25,r24
 241 0036 8827      		clr r24
 242               	.LVL9:
 243 0038 680F      		add r22,r24
 244 003a 792F      		mov r23,r25
 245 003c 711D      		adc r23,__zero_reg__
  98:main.cpp      **** 	
  99:main.cpp      **** 	//CNT=1.1*1024/Vref
 100:main.cpp      **** 	//Vref=1.1*1024/CNT
 101:main.cpp      **** 	//1.02578
 102:main.cpp      **** 	//1.0127
 103:main.cpp      **** 	//
 104:main.cpp      **** 	uint32_t cnt=(109875.0)/ADC_val;// in tens of mV, i.e. 330=>3.30V
 246               		.loc 1 104 0
 247 003e 90E0      		ldi r25,0
 248 0040 80E0      		ldi r24,0
 249 0042 0E94 0000 		call __floatunsisf
 250               	.LVL10:
 251 0046 9B01      		movw r18,r22
 252 0048 AC01      		movw r20,r24
 253 004a 60E8      		ldi r22,lo8(-128)
 254 004c 79E9      		ldi r23,lo8(-103)
 255 004e 86ED      		ldi r24,lo8(-42)
 256 0050 97E4      		ldi r25,lo8(71)
 257 0052 0E94 0000 		call __divsf3
 258               	.LVL11:
 259 0056 0E94 0000 		call __fixunssfsi
 260               	.LVL12:
 261 005a 6B01      		movw r12,r22
 262 005c 7C01      		movw r14,r24
 263               	.LVL13:
 105:main.cpp      **** 	myLCD.setNb(cnt,3);
 264               		.loc 1 105 0
 265 005e 43E0      		ldi r20,lo8(3)
 266 0060 0E94 0000 		call _ZN3LCD5setNbElh
 267               	.LVL14:
 106:main.cpp      **** 	if(cnt>=BATT_FULL){
 268               		.loc 1 106 0
 269 0064 8FE4      		ldi r24,79
 270 0066 C816      		cp r12,r24
 271 0068 81E0      		ldi r24,1
 272 006a D806      		cpc r13,r24
 273 006c E104      		cpc r14,__zero_reg__
 274 006e F104      		cpc r15,__zero_reg__
 275 0070 00F0      		brlo .L14
 107:main.cpp      **** 		myLCD.setBattery(LCD::FULL);
 276               		.loc 1 107 0
 277 0072 87E0      		ldi r24,lo8(7)
 278               	.L19:
 108:main.cpp      **** 	}else if(cnt>=BATT_TWOBAR){
 109:main.cpp      **** 		myLCD.setBattery(LCD::TWOBAR);
 110:main.cpp      **** 	}else if(cnt>=BATT_ONEBAR){
 111:main.cpp      **** 		myLCD.setBattery(LCD::ONEBAR);
 112:main.cpp      **** 	}else if(cnt>=BATT_EMPTY){
 113:main.cpp      **** 		myLCD.setBattery(LCD::EMPTY);
 114:main.cpp      **** 	}else{
 115:main.cpp      **** 		myLCD.setBattery(LCD::NONE);
 279               		.loc 1 115 0
 280 0074 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 281               	.LVL15:
 282               	/* epilogue start */
 116:main.cpp      **** 		//we should shutdown here
 117:main.cpp      **** 	}
 118:main.cpp      **** }
 283               		.loc 1 118 0
 284 0078 FF91      		pop r31
 285 007a EF91      		pop r30
 286 007c BF91      		pop r27
 287 007e AF91      		pop r26
 288 0080 9F91      		pop r25
 289 0082 8F91      		pop r24
 290 0084 7F91      		pop r23
 291 0086 6F91      		pop r22
 292 0088 5F91      		pop r21
 293 008a 4F91      		pop r20
 294 008c 3F91      		pop r19
 295 008e 2F91      		pop r18
 296 0090 FF90      		pop r15
 297 0092 EF90      		pop r14
 298 0094 DF90      		pop r13
 299 0096 CF90      		pop r12
 300               	.LVL16:
 301 0098 0F90      		pop r0
 302 009a 0FBE      		out __SREG__,r0
 303 009c 0F90      		pop r0
 304 009e 1F90      		pop r1
 305 00a0 1895      		reti
 306               	.LVL17:
 307               	.L14:
 108:main.cpp      **** 	}else if(cnt>=BATT_TWOBAR){
 308               		.loc 1 108 0
 309 00a2 85E4      		ldi r24,69
 310 00a4 C816      		cp r12,r24
 311 00a6 81E0      		ldi r24,1
 312 00a8 D806      		cpc r13,r24
 313 00aa E104      		cpc r14,__zero_reg__
 314 00ac F104      		cpc r15,__zero_reg__
 315 00ae 00F0      		brlo .L16
 109:main.cpp      **** 	}else if(cnt>=BATT_ONEBAR){
 316               		.loc 1 109 0
 317 00b0 86E0      		ldi r24,lo8(6)
 318 00b2 00C0      		rjmp .L19
 319               	.L16:
 110:main.cpp      **** 		myLCD.setBattery(LCD::ONEBAR);
 320               		.loc 1 110 0
 321 00b4 8BE3      		ldi r24,59
 322 00b6 C816      		cp r12,r24
 323 00b8 81E0      		ldi r24,1
 324 00ba D806      		cpc r13,r24
 325 00bc E104      		cpc r14,__zero_reg__
 326 00be F104      		cpc r15,__zero_reg__
 327 00c0 00F0      		brlo .L17
 111:main.cpp      **** 	}else if(cnt>=BATT_EMPTY){
 328               		.loc 1 111 0
 329 00c2 85E0      		ldi r24,lo8(5)
 330 00c4 00C0      		rjmp .L19
 331               	.L17:
 112:main.cpp      **** 		myLCD.setBattery(LCD::EMPTY);
 332               		.loc 1 112 0
 333 00c6 81E3      		ldi r24,49
 334 00c8 C816      		cp r12,r24
 335 00ca 81E0      		ldi r24,1
 336 00cc D806      		cpc r13,r24
 337 00ce E104      		cpc r14,__zero_reg__
 338 00d0 F104      		cpc r15,__zero_reg__
 339 00d2 00F0      		brlo .L18
 113:main.cpp      **** 	}else{
 340               		.loc 1 113 0
 341 00d4 81E0      		ldi r24,lo8(1)
 342 00d6 00C0      		rjmp .L19
 343               	.L18:
 115:main.cpp      **** 		//we should shutdown here
 344               		.loc 1 115 0
 345 00d8 80E0      		ldi r24,0
 346 00da 00C0      		rjmp .L19
 347               		.cfi_endproc
 348               	.LFE11:
 350               	.global	__vector_13
 352               	__vector_13:
 353               	.LFB12:
 119:main.cpp      **** 
 120:main.cpp      **** ISR(USART0_RX_vect){
 354               		.loc 1 120 0
 355               		.cfi_startproc
 356 00dc 1F92      		push r1
 357               	.LCFI18:
 358               		.cfi_def_cfa_offset 3
 359               		.cfi_offset 1, -2
 360 00de 0F92      		push r0
 361               	.LCFI19:
 362               		.cfi_def_cfa_offset 4
 363               		.cfi_offset 0, -3
 364 00e0 0FB6      		in r0,__SREG__
 365 00e2 0F92      		push r0
 366 00e4 1124      		clr __zero_reg__
 367 00e6 2F93      		push r18
 368               	.LCFI20:
 369               		.cfi_def_cfa_offset 5
 370               		.cfi_offset 18, -4
 371 00e8 3F93      		push r19
 372               	.LCFI21:
 373               		.cfi_def_cfa_offset 6
 374               		.cfi_offset 19, -5
 375 00ea 4F93      		push r20
 376               	.LCFI22:
 377               		.cfi_def_cfa_offset 7
 378               		.cfi_offset 20, -6
 379 00ec 5F93      		push r21
 380               	.LCFI23:
 381               		.cfi_def_cfa_offset 8
 382               		.cfi_offset 21, -7
 383 00ee 6F93      		push r22
 384               	.LCFI24:
 385               		.cfi_def_cfa_offset 9
 386               		.cfi_offset 22, -8
 387 00f0 7F93      		push r23
 388               	.LCFI25:
 389               		.cfi_def_cfa_offset 10
 390               		.cfi_offset 23, -9
 391 00f2 8F93      		push r24
 392               	.LCFI26:
 393               		.cfi_def_cfa_offset 11
 394               		.cfi_offset 24, -10
 395 00f4 9F93      		push r25
 396               	.LCFI27:
 397               		.cfi_def_cfa_offset 12
 398               		.cfi_offset 25, -11
 399 00f6 AF93      		push r26
 400               	.LCFI28:
 401               		.cfi_def_cfa_offset 13
 402               		.cfi_offset 26, -12
 403 00f8 BF93      		push r27
 404               	.LCFI29:
 405               		.cfi_def_cfa_offset 14
 406               		.cfi_offset 27, -13
 407 00fa EF93      		push r30
 408               	.LCFI30:
 409               		.cfi_def_cfa_offset 15
 410               		.cfi_offset 30, -14
 411 00fc FF93      		push r31
 412               	.LCFI31:
 413               		.cfi_def_cfa_offset 16
 414               		.cfi_offset 31, -15
 415               	/* prologue: Signal */
 416               	/* frame size = 0 */
 417               	/* stack size = 15 */
 418               	.L__stack_usage = 15
 121:main.cpp      **** 	uart.receive();
 419               		.loc 1 121 0
 420 00fe 80E0      		ldi r24,lo8(uart)
 421 0100 90E0      		ldi r25,hi8(uart)
 422 0102 0E94 0000 		call _ZN4UART7receiveEv
 423               	.LVL18:
 424               	/* epilogue start */
 122:main.cpp      **** }
 425               		.loc 1 122 0
 426 0106 FF91      		pop r31
 427 0108 EF91      		pop r30
 428 010a BF91      		pop r27
 429 010c AF91      		pop r26
 430 010e 9F91      		pop r25
 431 0110 8F91      		pop r24
 432 0112 7F91      		pop r23
 433 0114 6F91      		pop r22
 434 0116 5F91      		pop r21
 435 0118 4F91      		pop r20
 436 011a 3F91      		pop r19
 437 011c 2F91      		pop r18
 438 011e 0F90      		pop r0
 439 0120 0FBE      		out __SREG__,r0
 440 0122 0F90      		pop r0
 441 0124 1F90      		pop r1
 442 0126 1895      		reti
 443               		.cfi_endproc
 444               	.LFE12:
 446               		.section	.text.startup
 448               	_GLOBAL__sub_I_uart:
 449               	.LFB14:
 450               		.loc 1 122 0
 451               		.cfi_startproc
 452               	/* prologue: function */
 453               	/* frame size = 0 */
 454               	/* stack size = 0 */
 455               	.L__stack_usage = 0
 456               	.LVL19:
 457               	.LBB16:
 458               	.LBB17:
  35:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
 459               		.loc 1 35 0
 460 00a8 80E0      		ldi r24,lo8(uart)
 461 00aa 90E0      		ldi r25,hi8(uart)
 462 00ac 0E94 0000 		call _ZN4UARTC1Ev
 463               	.LVL20:
  36:main.cpp      **** //Scale myScale=Scale(&uart);
 464               		.loc 1 36 0
 465 00b0 60E0      		ldi r22,0
 466 00b2 80E0      		ldi r24,lo8(myLCD)
 467 00b4 90E0      		ldi r25,hi8(myLCD)
 468 00b6 0C94 0000 		jmp _ZN3LCDC1Eb
 469               	.LVL21:
 470               	.LBE17:
 471               	.LBE16:
 472               		.cfi_endproc
 473               	.LFE14:
 475               		.global __do_global_ctors
 476               		.section .ctors,"a",@progbits
 477               		.p2align	1
 478 0000 0000      		.word	gs(_GLOBAL__sub_I_uart)
 479               		.section	.text.exit,"ax",@progbits
 481               	_GLOBAL__sub_D_uart:
 482               	.LFB15:
 483               		.loc 1 122 0
 484               		.cfi_startproc
 485               	/* prologue: function */
 486               	/* frame size = 0 */
 487               	/* stack size = 0 */
 488               	.L__stack_usage = 0
 489               	.LVL22:
 490               	.LBB22:
 491               	.LBB23:
 492               	.LBB24:
  36:main.cpp      **** //Scale myScale=Scale(&uart);
 493               		.loc 1 36 0
 494 0000 80E0      		ldi r24,lo8(myLCD)
 495 0002 90E0      		ldi r25,hi8(myLCD)
 496 0004 0E94 0000 		call _ZN3LCDD1Ev
 497               	.LVL23:
  35:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
 498               		.loc 1 35 0
 499 0008 80E0      		ldi r24,lo8(uart)
 500 000a 90E0      		ldi r25,hi8(uart)
 501 000c 0C94 0000 		jmp _ZN4UARTD1Ev
 502               	.LVL24:
 503               	.LBE24:
 504               	.LBE23:
 505               	.LBE22:
 506               		.cfi_endproc
 507               	.LFE15:
 509               		.global __do_global_dtors
 510               		.section .dtors,"a",@progbits
 511               		.p2align	1
 512 0000 0000      		.word	gs(_GLOBAL__sub_D_uart)
 513               	.global	btn_state
 514               		.section .bss
 517               	btn_state:
 518 0000 00        		.zero	1
 519               	.global	loop_cnt
 522               	loop_cnt:
 523 0001 00        		.zero	1
 524               	.global	myLCD
 527               	myLCD:
 528 0002 00        		.zero	1
 529               	.global	uart
 532               	uart:
 533 0003 0000 0000 		.zero	22
 533      0000 0000 
 533      0000 0000 
 533      0000 0000 
 533      0000 0000 
 534               		.text
 535               	.Letext0:
 536               		.file 3 "/usr/lib/avr/include/stdint.h"
 537               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 538               		.file 5 "/usr/lib/avr/include/stdlib.h"
 539               		.file 6 "UART.h"
 540               		.file 7 "LCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.cpp
     /tmp/cchmOMeE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cchmOMeE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cchmOMeE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cchmOMeE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cchmOMeE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cchmOMeE.s:16     .text.startup:0000000000000000 main
     /tmp/cchmOMeE.s:522    .bss:0000000000000001 loop_cnt
     /tmp/cchmOMeE.s:517    .bss:0000000000000000 btn_state
     /tmp/cchmOMeE.s:532    .bss:0000000000000003 uart
     /tmp/cchmOMeE.s:150    .text:0000000000000000 __vector_19
     /tmp/cchmOMeE.s:352    .text:00000000000000dc __vector_13
     /tmp/cchmOMeE.s:448    .text.startup:00000000000000a8 _GLOBAL__sub_I_uart
     /tmp/cchmOMeE.s:527    .bss:0000000000000002 myLCD
     /tmp/cchmOMeE.s:481    .text.exit:0000000000000000 _GLOBAL__sub_D_uart

UNDEFINED SYMBOLS
_ZN3LCD5setNbElh
_ZN3LCD10setBatteryENS_7BatteryE
_ZN4UART15isDataAvailableEv
_ZN4UART8retrieveEv
_ZN4UART10sendStringEPcb
__floatunsisf
__divsf3
__fixunssfsi
_ZN4UART7receiveEv
_ZN4UARTC1Ev
_ZN3LCDC1Eb
__do_global_ctors
_ZN3LCDD1Ev
_ZN4UARTD1Ev
__do_global_dtors
__do_copy_data
__do_clear_bss
