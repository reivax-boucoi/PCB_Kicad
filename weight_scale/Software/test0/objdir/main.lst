   1               		.file	"main.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB10:
  15               		.file 1 "main.cpp"
   1:main.cpp      **** #include <avr/io.h>
   2:main.cpp      **** #include <avr/interrupt.h>
   3:main.cpp      **** #include <avr/sleep.h>
   4:main.cpp      **** #include <util/delay.h>
   5:main.cpp      **** #include <stdlib.h> //for itoa
   6:main.cpp      **** 
   7:main.cpp      **** #include "LCD.h"
   8:main.cpp      **** #include "UART.h"
   9:main.cpp      **** #include "ADC.h"
  10:main.cpp      **** #include "state_machine.h"
  11:main.cpp      **** 
  12:main.cpp      **** UART uart;
  13:main.cpp      **** MCP3462 myADC;
  14:main.cpp      **** SM mySM;
  15:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
  16:main.cpp      **** 
  17:main.cpp      **** //Fuses -U lfuse:w:0xe2:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m 
  18:main.cpp      **** //Int RC osc, 6CK+65ms startup time
  19:main.cpp      **** //No Clock div by 8
  20:main.cpp      **** //Brown out detection enabled, 1.8V
  21:main.cpp      **** //For BoD at 2.7V, use Efuse=FB instead of FD
  22:main.cpp      **** 
  23:main.cpp      **** #define LED0_ON (PORTD|=(1<<6))
  24:main.cpp      **** #define LED0_OFF (PORTD&=~(1<<6))
  25:main.cpp      **** #define LED0_Toggle (PORTD^=(1<<6))
  26:main.cpp      **** 
  27:main.cpp      **** #define LED1_ON (PORTD|=(1<<7))
  28:main.cpp      **** #define LED1_OFF (PORTD&=~(1<<7))
  29:main.cpp      **** #define LED1_Toggle (PORTD^=(1<<7))
  30:main.cpp      **** 
  31:main.cpp      **** #define BTN0 (PINB&(1<<6)) //PCINT14
  32:main.cpp      **** #define BTN1 (PINB&(1<<7)) //PCINT15
  33:main.cpp      **** 
  34:main.cpp      **** #define BATT_CUTOUT 3200
  35:main.cpp      **** #define BATT_EMPTY 3500
  36:main.cpp      **** #define BATT_ONEBAR 3600
  37:main.cpp      **** #define BATT_TWOBAR 3750
  38:main.cpp      **** #define BATT_FULL 3900
  39:main.cpp      **** 
  40:main.cpp      **** 
  41:main.cpp      **** 
  42:main.cpp      **** volatile uint32_t cnt=59650;
  43:main.cpp      **** volatile uint8_t state=1;
  44:main.cpp      **** 
  45:main.cpp      **** int main(void){
  16               		.loc 1 45 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  46:main.cpp      **** 	
  47:main.cpp      **** 	DDRD=0b11000000; 	//LED0, LED1 as outputs
  42               		.loc 1 47 0
  43 0014 80EC      		ldi r24,lo8(-64)
  44 0016 8AB9      		out 0xa,r24
  48:main.cpp      **** 	PORTD=0x00;			//LED initial state:low
  45               		.loc 1 48 0
  46 0018 1BB8      		out 0xb,__zero_reg__
  49:main.cpp      **** 	DDRB=0x00; 			//BTN0, BTN1 as inputs
  47               		.loc 1 49 0
  48 001a 14B8      		out 0x4,__zero_reg__
  50:main.cpp      **** 	PORTB=0b11000000;	//BTN0, BTN1 activate internal pullups
  49               		.loc 1 50 0
  50 001c 85B9      		out 0x5,r24
  51:main.cpp      **** 	
  52:main.cpp      **** 	DDRE=0x00;
  51               		.loc 1 52 0
  52 001e 1DB8      		out 0xd,__zero_reg__
  53:main.cpp      **** 	PORTE=0xFF;
  53               		.loc 1 53 0
  54 0020 8FEF      		ldi r24,lo8(-1)
  55 0022 8EB9      		out 0xe,r24
  54:main.cpp      **** 	DDRB=0x00;
  56               		.loc 1 54 0
  57 0024 14B8      		out 0x4,__zero_reg__
  55:main.cpp      **** 	PORTB=0xFF;
  58               		.loc 1 55 0
  59 0026 85B9      		out 0x5,r24
  56:main.cpp      **** 	
  57:main.cpp      **** 	LED0_ON;
  60               		.loc 1 57 0
  61 0028 5E9A      		sbi 0xb,6
  58:main.cpp      **** 	PRR|=(1<<PRTIM1)|(1<<PRSPI)|(1<<PRUSART0);//Shut down clock to Timer1, SPI, UART
  62               		.loc 1 58 0
  63 002a 8091 6400 		lds r24,100
  64 002e 8E60      		ori r24,lo8(14)
  65 0030 8093 6400 		sts 100,r24
  59:main.cpp      **** 	
  60:main.cpp      **** 	ADMUX|=(1<<REFS0)|0b11110;//Set AVCC as reference voltage for ADC, ADC MUX input to 1.1V BG
  66               		.loc 1 60 0
  67 0034 8091 7C00 		lds r24,124
  68 0038 8E65      		ori r24,lo8(94)
  69 003a 8093 7C00 		sts 124,r24
  61:main.cpp      **** 	ADCSRA|=(1<<ADEN)|(1<<ADIE)|(1<<ADPS1);//Enable conversin complete interrupt, Clock prescaler 12MH
  70               		.loc 1 61 0
  71 003e 8091 7A00 		lds r24,122
  72 0042 8A68      		ori r24,lo8(-118)
  73 0044 8093 7A00 		sts 122,r24
  62:main.cpp      **** 	EIMSK=0b00100000;//Enable pin change interrupt PCINT8-15 WARNING Avrdude is not up to date with ch
  74               		.loc 1 62 0
  75 0048 80E2      		ldi r24,lo8(32)
  76 004a 8DBB      		out 0x1d,r24
  63:main.cpp      **** 	PCMSK1=(1<<PCINT14);//Enable BTN0 interrupt
  77               		.loc 1 63 0
  78 004c 80E4      		ldi r24,lo8(64)
  79 004e 8093 6C00 		sts 108,r24
  64:main.cpp      **** 	sei();
  80               		.loc 1 64 0
  81               	/* #APP */
  82               	 ;  64 "main.cpp" 1
  83 0052 7894      		sei
  84               	 ;  0 "" 2
  85               	/* #NOAPP */
  86               	.LBB17:
  87               	.LBB18:
  88               	.LBB19:
  65:main.cpp      **** 	
  66:main.cpp      **** 	
  67:main.cpp      **** 	while(1){
  68:main.cpp      **** 	
  69:main.cpp      **** 		_delay_ms(100);
  70:main.cpp      **** 		switch(state){
  71:main.cpp      **** 			case 0:
  72:main.cpp      **** 				ADCSRA&=~(1<<ADEN);//Disable ADC
  73:main.cpp      **** 				PRR|=(1<<PRTIM1)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRADC);//Shut down clock to Timer1, SPI, UART, AD
  74:main.cpp      **** 				
  75:main.cpp      **** 				set_sleep_mode(SLEEP_MODE_PWR_SAVE);
  76:main.cpp      **** 				//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  77:main.cpp      **** 				cli();
  78:main.cpp      **** 				if (1){
  79:main.cpp      **** 					sleep_enable();
  80:main.cpp      **** 					sei();
  81:main.cpp      **** 					sleep_cpu();
  82:main.cpp      **** 					sleep_disable();
  83:main.cpp      **** 				}
  84:main.cpp      **** 				PRR&=~(1<<PRADC);//Enable power to ADC again
  85:main.cpp      **** 				ADCSRA|=(1<<ADEN);//Enable ADC again
  86:main.cpp      **** 				sei();
  87:main.cpp      **** 				state=1;
  89               		.loc 1 87 0
  90 0054 11E0      		ldi r17,lo8(1)
  88:main.cpp      **** 				break;
  89:main.cpp      **** 				
  90:main.cpp      **** 			case 1:
  91:main.cpp      **** 				LED0_Toggle;
  91               		.loc 1 91 0
  92 0056 00E4      		ldi r16,lo8(64)
  93               	.L2:
  94               	.LVL0:
  95               	.LBE19:
  96               	.LBE18:
  97               	.LBB25:
  98               	.LBB26:
  99               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 100               		.loc 2 187 0
 101 0058 2FEF      		ldi r18,lo8(159999)
 102 005a 80E7      		ldi r24,hi8(159999)
 103 005c 92E0      		ldi r25,hlo8(159999)
 104 005e 2150      	1:	subi r18,1
 105 0060 8040      		sbci r24,0
 106 0062 9040      		sbci r25,0
 107 0064 01F4      		brne 1b
 108 0066 00C0      		rjmp .
 109 0068 0000      		nop
 110               	.LVL1:
 111               	.LBE26:
 112               	.LBE25:
 113               	.LBB27:
  70:main.cpp      **** 			case 0:
 114               		.loc 1 70 0
 115 006a 8091 0000 		lds r24,state
 116 006e 8823      		tst r24
 117 0070 01F0      		breq .L4
 118 0072 8130      		cpi r24,lo8(1)
 119 0074 01F0      		breq .L5
 120 0076 00C0      		rjmp .L3
 121               	.L4:
 122               	.LBB24:
  72:main.cpp      **** 				PRR|=(1<<PRTIM1)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRADC);//Shut down clock to Timer1, SPI, UART, AD
 123               		.loc 1 72 0
 124 0078 8091 7A00 		lds r24,122
 125 007c 8F77      		andi r24,lo8(127)
 126 007e 8093 7A00 		sts 122,r24
  73:main.cpp      **** 				
 127               		.loc 1 73 0
 128 0082 8091 6400 		lds r24,100
 129 0086 8F60      		ori r24,lo8(15)
 130 0088 8093 6400 		sts 100,r24
  75:main.cpp      **** 				//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 131               		.loc 1 75 0
 132 008c 83B7      		in r24,0x33
 133 008e 817F      		andi r24,lo8(-15)
 134 0090 8660      		ori r24,lo8(6)
 135 0092 83BF      		out 0x33,r24
  77:main.cpp      **** 				if (1){
 136               		.loc 1 77 0
 137               	/* #APP */
 138               	 ;  77 "main.cpp" 1
 139 0094 F894      		cli
 140               	 ;  0 "" 2
  79:main.cpp      **** 					sei();
 141               		.loc 1 79 0
 142               	/* #NOAPP */
 143 0096 83B7      		in r24,0x33
 144 0098 8160      		ori r24,lo8(1)
 145 009a 83BF      		out 0x33,r24
  80:main.cpp      **** 					sleep_cpu();
 146               		.loc 1 80 0
 147               	/* #APP */
 148               	 ;  80 "main.cpp" 1
 149 009c 7894      		sei
 150               	 ;  0 "" 2
  81:main.cpp      **** 					sleep_disable();
 151               		.loc 1 81 0
 152               	 ;  81 "main.cpp" 1
 153 009e 8895      		sleep
 154               		
 155               	 ;  0 "" 2
  82:main.cpp      **** 				}
 156               		.loc 1 82 0
 157               	/* #NOAPP */
 158 00a0 83B7      		in r24,0x33
 159 00a2 8E7F      		andi r24,lo8(-2)
 160 00a4 83BF      		out 0x33,r24
  84:main.cpp      **** 				ADCSRA|=(1<<ADEN);//Enable ADC again
 161               		.loc 1 84 0
 162 00a6 8091 6400 		lds r24,100
 163 00aa 8E7F      		andi r24,lo8(-2)
 164 00ac 8093 6400 		sts 100,r24
  85:main.cpp      **** 				sei();
 165               		.loc 1 85 0
 166 00b0 8091 7A00 		lds r24,122
 167 00b4 8068      		ori r24,lo8(-128)
 168 00b6 8093 7A00 		sts 122,r24
  86:main.cpp      **** 				state=1;
 169               		.loc 1 86 0
 170               	/* #APP */
 171               	 ;  86 "main.cpp" 1
 172 00ba 7894      		sei
 173               	 ;  0 "" 2
  87:main.cpp      **** 				break;
 174               		.loc 1 87 0
 175               	/* #NOAPP */
 176 00bc 1093 0000 		sts state,r17
  88:main.cpp      **** 				
 177               		.loc 1 88 0
 178 00c0 00C0      		rjmp .L3
 179               	.L5:
 180               		.loc 1 91 0
 181 00c2 8BB1      		in r24,0xb
 182 00c4 8027      		eor r24,r16
 183 00c6 8BB9      		out 0xb,r24
  92:main.cpp      **** 				ADCSRA|=(1<<ADSC); //Start single ADC conversion
 184               		.loc 1 92 0
 185 00c8 8091 7A00 		lds r24,122
 186 00cc 8064      		ori r24,lo8(64)
 187 00ce 8093 7A00 		sts 122,r24
 188               	.LBB20:
  93:main.cpp      **** 				if(myADC.isDataReady()){
 189               		.loc 1 93 0
 190 00d2 0E94 0000 		call _ZN7MCP346211isDataReadyEv
 191               	.LVL2:
 192 00d6 8823      		tst r24
 193 00d8 01F0      		breq .L3
 194               	.LBB21:
  94:main.cpp      **** 					uint32_t d=myADC.getDirectData();
 195               		.loc 1 94 0
 196 00da 0E94 0000 		call _ZN7MCP346213getDirectDataEv
 197               	.LVL3:
 198 00de DC01      		movw r26,r24
 199 00e0 CB01      		movw r24,r22
 200               	.LVL4:
 201               	.LBB22:
 202               	.LBB23:
 203               		.file 3 "/usr/lib/avr/include/stdlib.h"
   1:/usr/lib/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/lib/avr/include/stdlib.h **** 
   4:/usr/lib/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/lib/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/lib/avr/include/stdlib.h **** 
   7:/usr/lib/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/lib/avr/include/stdlib.h **** 
   9:/usr/lib/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/lib/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/lib/avr/include/stdlib.h **** 
  12:/usr/lib/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/lib/avr/include/stdlib.h **** 
  15:/usr/lib/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/lib/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/lib/avr/include/stdlib.h ****      distribution.
  19:/usr/lib/avr/include/stdlib.h **** 
  20:/usr/lib/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/lib/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/lib/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/lib/avr/include/stdlib.h **** 
  24:/usr/lib/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/lib/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/lib/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/lib/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/lib/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/lib/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/lib/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/lib/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/lib/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/lib/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/lib/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/lib/avr/include/stdlib.h **** 
  36:/usr/lib/avr/include/stdlib.h ****   $Id$
  37:/usr/lib/avr/include/stdlib.h **** */
  38:/usr/lib/avr/include/stdlib.h **** 
  39:/usr/lib/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/lib/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/lib/avr/include/stdlib.h **** 
  42:/usr/lib/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/lib/avr/include/stdlib.h **** 
  44:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/lib/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/lib/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/lib/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/lib/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/lib/avr/include/stdlib.h **** 
  50:/usr/lib/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/lib/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/lib/avr/include/stdlib.h **** #endif
  53:/usr/lib/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/lib/avr/include/stdlib.h **** 
  55:/usr/lib/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/lib/avr/include/stdlib.h **** extern "C" {
  57:/usr/lib/avr/include/stdlib.h **** #endif
  58:/usr/lib/avr/include/stdlib.h **** 
  59:/usr/lib/avr/include/stdlib.h **** /** \file */
  60:/usr/lib/avr/include/stdlib.h **** 
  61:/usr/lib/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/lib/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/lib/avr/include/stdlib.h **** 
  64:/usr/lib/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/lib/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/lib/avr/include/stdlib.h **** */
  67:/usr/lib/avr/include/stdlib.h **** 
  68:/usr/lib/avr/include/stdlib.h **** /*@{*/
  69:/usr/lib/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/lib/avr/include/stdlib.h **** typedef struct {
  71:/usr/lib/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/lib/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/lib/avr/include/stdlib.h **** } div_t;
  74:/usr/lib/avr/include/stdlib.h **** 
  75:/usr/lib/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/lib/avr/include/stdlib.h **** typedef struct {
  77:/usr/lib/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/lib/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/lib/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/lib/avr/include/stdlib.h **** 
  81:/usr/lib/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/lib/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/lib/avr/include/stdlib.h **** 
  84:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/lib/avr/include/stdlib.h **** 
  86:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/lib/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/lib/avr/include/stdlib.h **** #endif
  89:/usr/lib/avr/include/stdlib.h **** 
  90:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/lib/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/lib/avr/include/stdlib.h **** #endif
  93:/usr/lib/avr/include/stdlib.h **** 
  94:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/lib/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/lib/avr/include/stdlib.h **** #endif
  97:/usr/lib/avr/include/stdlib.h **** 
  98:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/lib/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/lib/avr/include/stdlib.h **** #endif
 101:/usr/lib/avr/include/stdlib.h **** 
 102:/usr/lib/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/lib/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/lib/avr/include/stdlib.h **** # else
 106:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/lib/avr/include/stdlib.h **** # endif
 108:/usr/lib/avr/include/stdlib.h **** #endif
 109:/usr/lib/avr/include/stdlib.h **** 
 110:/usr/lib/avr/include/stdlib.h **** #endif
 111:/usr/lib/avr/include/stdlib.h **** 
 112:/usr/lib/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/lib/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/lib/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/lib/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/lib/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/lib/avr/include/stdlib.h **** 
 118:/usr/lib/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/lib/avr/include/stdlib.h **** */
 121:/usr/lib/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/lib/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/lib/avr/include/stdlib.h **** #endif
 125:/usr/lib/avr/include/stdlib.h **** 
 126:/usr/lib/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/lib/avr/include/stdlib.h ****     \c i.
 128:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/lib/avr/include/stdlib.h **** */
 130:/usr/lib/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/lib/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/lib/avr/include/stdlib.h **** #endif
 134:/usr/lib/avr/include/stdlib.h **** 
 135:/usr/lib/avr/include/stdlib.h **** /**
 136:/usr/lib/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/lib/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/lib/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/lib/avr/include/stdlib.h **** 
 141:/usr/lib/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/lib/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/lib/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/lib/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/lib/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/lib/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/lib/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/lib/avr/include/stdlib.h **** 
 149:/usr/lib/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/lib/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/lib/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/lib/avr/include/stdlib.h **** */
 153:/usr/lib/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/lib/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/lib/avr/include/stdlib.h **** 
 156:/usr/lib/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/lib/avr/include/stdlib.h **** /**
 158:/usr/lib/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/lib/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/lib/avr/include/stdlib.h **** */
 162:/usr/lib/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/lib/avr/include/stdlib.h **** /**
 164:/usr/lib/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/lib/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/lib/avr/include/stdlib.h **** */
 168:/usr/lib/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/lib/avr/include/stdlib.h **** 
 170:/usr/lib/avr/include/stdlib.h **** /**
 171:/usr/lib/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/lib/avr/include/stdlib.h ****      quicksort.
 173:/usr/lib/avr/include/stdlib.h **** 
 174:/usr/lib/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/lib/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/lib/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/lib/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/lib/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/lib/avr/include/stdlib.h **** 
 181:/usr/lib/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/lib/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/lib/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/lib/avr/include/stdlib.h **** */
 185:/usr/lib/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/lib/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/lib/avr/include/stdlib.h **** 
 188:/usr/lib/avr/include/stdlib.h **** /**
 189:/usr/lib/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/lib/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/lib/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/lib/avr/include/stdlib.h **** 
 193:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/lib/avr/include/stdlib.h **** 
 200:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/lib/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/lib/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/lib/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/lib/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/lib/avr/include/stdlib.h **** 
 206:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/lib/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/lib/avr/include/stdlib.h **** 
 212:/usr/lib/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/lib/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/lib/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/lib/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/lib/avr/include/stdlib.h **** */
 218:/usr/lib/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/lib/avr/include/stdlib.h **** 
 220:/usr/lib/avr/include/stdlib.h **** /**
 221:/usr/lib/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/lib/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/lib/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/lib/avr/include/stdlib.h ****     special value 0.
 225:/usr/lib/avr/include/stdlib.h **** 
 226:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/lib/avr/include/stdlib.h **** 
 233:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/lib/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/lib/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/lib/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/lib/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/lib/avr/include/stdlib.h **** 
 239:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/lib/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/lib/avr/include/stdlib.h **** 
 245:/usr/lib/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/lib/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/lib/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/lib/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/lib/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/lib/avr/include/stdlib.h **** */
 252:/usr/lib/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/lib/avr/include/stdlib.h **** 
 254:/usr/lib/avr/include/stdlib.h **** /**
 255:/usr/lib/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/lib/avr/include/stdlib.h **** 
 258:/usr/lib/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/lib/avr/include/stdlib.h **** 
 260:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/lib/avr/include/stdlib.h **** */
 264:/usr/lib/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/lib/avr/include/stdlib.h **** 
 266:/usr/lib/avr/include/stdlib.h **** /**
 267:/usr/lib/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/lib/avr/include/stdlib.h **** 
 270:/usr/lib/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/lib/avr/include/stdlib.h **** 
 272:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/lib/avr/include/stdlib.h **** */
 276:/usr/lib/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/lib/avr/include/stdlib.h **** 
 278:/usr/lib/avr/include/stdlib.h **** /**
 279:/usr/lib/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/lib/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/lib/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/lib/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/lib/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/lib/avr/include/stdlib.h **** 
 285:/usr/lib/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/lib/avr/include/stdlib.h ****    execution.
 287:/usr/lib/avr/include/stdlib.h **** */
 288:/usr/lib/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/lib/avr/include/stdlib.h **** 
 290:/usr/lib/avr/include/stdlib.h **** /**
 291:/usr/lib/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/lib/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/lib/avr/include/stdlib.h **** 
 294:/usr/lib/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/lib/avr/include/stdlib.h ****    zero bytes.
 296:/usr/lib/avr/include/stdlib.h **** 
 297:/usr/lib/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/lib/avr/include/stdlib.h ****    details.
 299:/usr/lib/avr/include/stdlib.h **** */
 300:/usr/lib/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/lib/avr/include/stdlib.h **** 
 302:/usr/lib/avr/include/stdlib.h **** /**
 303:/usr/lib/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/lib/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/lib/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/lib/avr/include/stdlib.h **** */
 307:/usr/lib/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/lib/avr/include/stdlib.h **** 
 309:/usr/lib/avr/include/stdlib.h **** /**
 310:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/lib/avr/include/stdlib.h **** */
 312:/usr/lib/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/lib/avr/include/stdlib.h **** 
 314:/usr/lib/avr/include/stdlib.h **** /**
 315:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/lib/avr/include/stdlib.h **** */
 317:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/lib/avr/include/stdlib.h **** 
 319:/usr/lib/avr/include/stdlib.h **** /**
 320:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/lib/avr/include/stdlib.h **** */
 322:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/lib/avr/include/stdlib.h **** 
 324:/usr/lib/avr/include/stdlib.h **** /**
 325:/usr/lib/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/lib/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/lib/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/lib/avr/include/stdlib.h **** */
 329:/usr/lib/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/lib/avr/include/stdlib.h **** 
 331:/usr/lib/avr/include/stdlib.h **** /**
 332:/usr/lib/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/lib/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/lib/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/lib/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/lib/avr/include/stdlib.h ****    region.
 337:/usr/lib/avr/include/stdlib.h **** 
 338:/usr/lib/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/lib/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/lib/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/lib/avr/include/stdlib.h **** 
 342:/usr/lib/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/lib/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/lib/avr/include/stdlib.h **** 
 345:/usr/lib/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/lib/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/lib/avr/include/stdlib.h **** */
 348:/usr/lib/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/lib/avr/include/stdlib.h **** 
 350:/usr/lib/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/lib/avr/include/stdlib.h **** 
 352:/usr/lib/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/lib/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/lib/avr/include/stdlib.h **** 
 355:/usr/lib/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/lib/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/lib/avr/include/stdlib.h **** 
 358:/usr/lib/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/lib/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/lib/avr/include/stdlib.h ****  */
 361:/usr/lib/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/lib/avr/include/stdlib.h **** 
 363:/usr/lib/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/lib/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/lib/avr/include/stdlib.h **** 
 366:/usr/lib/avr/include/stdlib.h **** /**
 367:/usr/lib/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/lib/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/lib/avr/include/stdlib.h **** 
 370:/usr/lib/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/lib/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/lib/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/lib/avr/include/stdlib.h **** 
 374:/usr/lib/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/lib/avr/include/stdlib.h ****      a value of 1.
 376:/usr/lib/avr/include/stdlib.h **** 
 377:/usr/lib/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/lib/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/lib/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/lib/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/lib/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/lib/avr/include/stdlib.h **** */
 383:/usr/lib/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/lib/avr/include/stdlib.h **** /**
 385:/usr/lib/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/lib/avr/include/stdlib.h **** */
 387:/usr/lib/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/lib/avr/include/stdlib.h **** 
 389:/usr/lib/avr/include/stdlib.h **** /**
 390:/usr/lib/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/lib/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/lib/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/lib/avr/include/stdlib.h **** */
 394:/usr/lib/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/lib/avr/include/stdlib.h **** /*@}*/
 396:/usr/lib/avr/include/stdlib.h **** 
 397:/usr/lib/avr/include/stdlib.h **** /*@{*/
 398:/usr/lib/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/lib/avr/include/stdlib.h **** */
 401:/usr/lib/avr/include/stdlib.h **** /**
 402:/usr/lib/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/lib/avr/include/stdlib.h **** 
 404:/usr/lib/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/lib/avr/include/stdlib.h **** 
 408:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/lib/avr/include/stdlib.h **** 
 414:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/lib/avr/include/stdlib.h **** 
 416:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/lib/avr/include/stdlib.h ****     
 421:/usr/lib/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/lib/avr/include/stdlib.h **** 
 423:/usr/lib/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/lib/avr/include/stdlib.h **** */
 425:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/lib/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/lib/avr/include/stdlib.h **** #else
 428:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/lib/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/lib/avr/include/stdlib.h **** {
 431:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/lib/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/lib/avr/include/stdlib.h **** 	return __s;
 437:/usr/lib/avr/include/stdlib.h ****     } else {
 438:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/lib/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 204               		.loc 3 439 0
 205 00e2 4AE0      		ldi r20,lo8(10)
 206 00e4 BE01      		movw r22,r28
 207               	.LVL5:
 208 00e6 6F5F      		subi r22,-1
 209 00e8 7F4F      		sbci r23,-1
 210 00ea 0E94 0000 		call __itoa_ncheck
 211               	.LVL6:
 212               	.LBE23:
 213               	.LBE22:
  95:main.cpp      **** 					char buffer [11];//32 bits in decimal is 4milions, 10 digits
  96:main.cpp      **** 					itoa(d,buffer,10);
  97:main.cpp      **** 					uart.sendString(buffer);
 214               		.loc 1 97 0
 215 00ee BE01      		movw r22,r28
 216 00f0 6F5F      		subi r22,-1
 217 00f2 7F4F      		sbci r23,-1
 218 00f4 80E0      		ldi r24,lo8(uart)
 219 00f6 90E0      		ldi r25,hi8(uart)
 220 00f8 0E94 0000 		call _ZN4UART10sendStringEPc
 221               	.LVL7:
 222               	.L3:
 223               	.LBE21:
 224               	.LBE20:
 225               	.LBE24:
 226               	.LBE27:
  98:main.cpp      **** 				}
  99:main.cpp      **** 		}
 100:main.cpp      **** 		
 101:main.cpp      **** 		if(cnt>=BATT_FULL){
 227               		.loc 1 101 0
 228 00fc 8091 0000 		lds r24,cnt
 229 0100 9091 0000 		lds r25,cnt+1
 230 0104 A091 0000 		lds r26,cnt+2
 231 0108 B091 0000 		lds r27,cnt+3
 232 010c 8C33      		cpi r24,60
 233 010e 9F40      		sbci r25,15
 234 0110 A105      		cpc r26,__zero_reg__
 235 0112 B105      		cpc r27,__zero_reg__
 236 0114 00F0      		brlo .L6
 102:main.cpp      **** 			myLCD.setBattery(LCD::FULL);
 237               		.loc 1 102 0
 238 0116 87E0      		ldi r24,lo8(7)
 239 0118 00C0      		rjmp .L14
 240               	.L6:
 103:main.cpp      **** 		}else if(cnt>=BATT_TWOBAR){
 241               		.loc 1 103 0
 242 011a 8091 0000 		lds r24,cnt
 243 011e 9091 0000 		lds r25,cnt+1
 244 0122 A091 0000 		lds r26,cnt+2
 245 0126 B091 0000 		lds r27,cnt+3
 246 012a 863A      		cpi r24,-90
 247 012c 9E40      		sbci r25,14
 248 012e A105      		cpc r26,__zero_reg__
 249 0130 B105      		cpc r27,__zero_reg__
 250 0132 00F0      		brlo .L8
 104:main.cpp      **** 			myLCD.setBattery(LCD::TWOBAR);
 251               		.loc 1 104 0
 252 0134 86E0      		ldi r24,lo8(6)
 253 0136 00C0      		rjmp .L14
 254               	.L8:
 105:main.cpp      **** 		}else if(cnt>=BATT_ONEBAR){
 255               		.loc 1 105 0
 256 0138 8091 0000 		lds r24,cnt
 257 013c 9091 0000 		lds r25,cnt+1
 258 0140 A091 0000 		lds r26,cnt+2
 259 0144 B091 0000 		lds r27,cnt+3
 260 0148 8031      		cpi r24,16
 261 014a 9E40      		sbci r25,14
 262 014c A105      		cpc r26,__zero_reg__
 263 014e B105      		cpc r27,__zero_reg__
 264 0150 00F0      		brlo .L9
 106:main.cpp      **** 			myLCD.setBattery(LCD::ONEBAR);
 265               		.loc 1 106 0
 266 0152 85E0      		ldi r24,lo8(5)
 267 0154 00C0      		rjmp .L14
 268               	.L9:
 107:main.cpp      **** 		}else if(cnt>=BATT_EMPTY){
 269               		.loc 1 107 0
 270 0156 8091 0000 		lds r24,cnt
 271 015a 9091 0000 		lds r25,cnt+1
 272 015e A091 0000 		lds r26,cnt+2
 273 0162 B091 0000 		lds r27,cnt+3
 274 0166 8C3A      		cpi r24,-84
 275 0168 9D40      		sbci r25,13
 276 016a A105      		cpc r26,__zero_reg__
 277 016c B105      		cpc r27,__zero_reg__
 278 016e 00F0      		brlo .L10
 108:main.cpp      **** 			myLCD.setBattery(LCD::EMPTY);
 279               		.loc 1 108 0
 280 0170 81E0      		ldi r24,lo8(1)
 281 0172 00C0      		rjmp .L14
 282               	.L10:
 109:main.cpp      **** 		}else{
 110:main.cpp      **** 			myLCD.setBattery(LCD::NONE);
 283               		.loc 1 110 0
 284 0174 80E0      		ldi r24,0
 285               	.L14:
 286 0176 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 287               	.LVL8:
 288 017a 00C0      		rjmp .L2
 289               	.LBE17:
 290               		.cfi_endproc
 291               	.LFE10:
 293               		.text
 294               	.global	__vector_3
 296               	__vector_3:
 297               	.LFB11:
 111:main.cpp      **** 			//we should shutdown here
 112:main.cpp      **** 		}
 113:main.cpp      **** 	}
 114:main.cpp      **** 
 115:main.cpp      **** 	return 0;
 116:main.cpp      **** }
 117:main.cpp      **** 
 118:main.cpp      **** 
 119:main.cpp      **** 
 120:main.cpp      **** ISR(PCINT1_vect){
 298               		.loc 1 120 0
 299               		.cfi_startproc
 300 0000 1F92      		push r1
 301               	.LCFI4:
 302               		.cfi_def_cfa_offset 3
 303               		.cfi_offset 1, -2
 304 0002 0F92      		push r0
 305               	.LCFI5:
 306               		.cfi_def_cfa_offset 4
 307               		.cfi_offset 0, -3
 308 0004 0FB6      		in r0,__SREG__
 309 0006 0F92      		push r0
 310 0008 1124      		clr __zero_reg__
 311 000a 8F93      		push r24
 312               	.LCFI6:
 313               		.cfi_def_cfa_offset 5
 314               		.cfi_offset 24, -4
 315               	/* prologue: Signal */
 316               	/* frame size = 0 */
 317               	/* stack size = 4 */
 318               	.L__stack_usage = 4
 121:main.cpp      **** 	if(BTN0){
 319               		.loc 1 121 0
 320 000c 1E9B      		sbis 0x3,6
 321 000e 00C0      		rjmp .L16
 122:main.cpp      **** 		if(state==1){
 322               		.loc 1 122 0
 323 0010 8091 0000 		lds r24,state
 324 0014 8130      		cpi r24,lo8(1)
 325 0016 01F4      		brne .L18
 123:main.cpp      **** 			LED0_OFF;
 326               		.loc 1 123 0
 327 0018 5E98      		cbi 0xb,6
 124:main.cpp      **** 			state=0;
 328               		.loc 1 124 0
 329 001a 1092 0000 		sts state,__zero_reg__
 330 001e 00C0      		rjmp .L16
 331               	.L18:
 125:main.cpp      **** 		}else{
 126:main.cpp      **** 			LED0_ON;
 332               		.loc 1 126 0
 333 0020 5E9A      		sbi 0xb,6
 334               	.L16:
 335               	/* epilogue start */
 127:main.cpp      **** 		}
 128:main.cpp      **** 	}
 129:main.cpp      **** }
 336               		.loc 1 129 0
 337 0022 8F91      		pop r24
 338 0024 0F90      		pop r0
 339 0026 0FBE      		out __SREG__,r0
 340 0028 0F90      		pop r0
 341 002a 1F90      		pop r1
 342 002c 1895      		reti
 343               		.cfi_endproc
 344               	.LFE11:
 346               	.global	__floatunsisf
 347               	.global	__divsf3
 348               	.global	__fixunssfsi
 349               	.global	__vector_19
 351               	__vector_19:
 352               	.LFB12:
 130:main.cpp      **** 
 131:main.cpp      **** ISR(ADC_vect){
 353               		.loc 1 131 0
 354               		.cfi_startproc
 355 002e 1F92      		push r1
 356               	.LCFI7:
 357               		.cfi_def_cfa_offset 3
 358               		.cfi_offset 1, -2
 359 0030 0F92      		push r0
 360               	.LCFI8:
 361               		.cfi_def_cfa_offset 4
 362               		.cfi_offset 0, -3
 363 0032 0FB6      		in r0,__SREG__
 364 0034 0F92      		push r0
 365 0036 1124      		clr __zero_reg__
 366 0038 2F93      		push r18
 367               	.LCFI9:
 368               		.cfi_def_cfa_offset 5
 369               		.cfi_offset 18, -4
 370 003a 3F93      		push r19
 371               	.LCFI10:
 372               		.cfi_def_cfa_offset 6
 373               		.cfi_offset 19, -5
 374 003c 4F93      		push r20
 375               	.LCFI11:
 376               		.cfi_def_cfa_offset 7
 377               		.cfi_offset 20, -6
 378 003e 5F93      		push r21
 379               	.LCFI12:
 380               		.cfi_def_cfa_offset 8
 381               		.cfi_offset 21, -7
 382 0040 6F93      		push r22
 383               	.LCFI13:
 384               		.cfi_def_cfa_offset 9
 385               		.cfi_offset 22, -8
 386 0042 7F93      		push r23
 387               	.LCFI14:
 388               		.cfi_def_cfa_offset 10
 389               		.cfi_offset 23, -9
 390 0044 8F93      		push r24
 391               	.LCFI15:
 392               		.cfi_def_cfa_offset 11
 393               		.cfi_offset 24, -10
 394 0046 9F93      		push r25
 395               	.LCFI16:
 396               		.cfi_def_cfa_offset 12
 397               		.cfi_offset 25, -11
 398 0048 AF93      		push r26
 399               	.LCFI17:
 400               		.cfi_def_cfa_offset 13
 401               		.cfi_offset 26, -12
 402 004a BF93      		push r27
 403               	.LCFI18:
 404               		.cfi_def_cfa_offset 14
 405               		.cfi_offset 27, -13
 406 004c EF93      		push r30
 407               	.LCFI19:
 408               		.cfi_def_cfa_offset 15
 409               		.cfi_offset 30, -14
 410 004e FF93      		push r31
 411               	.LCFI20:
 412               		.cfi_def_cfa_offset 16
 413               		.cfi_offset 31, -15
 414               	/* prologue: Signal */
 415               	/* frame size = 0 */
 416               	/* stack size = 15 */
 417               	.L__stack_usage = 15
 132:main.cpp      **** 	uint16_t ADC_val=ADCL;
 418               		.loc 1 132 0
 419 0050 8091 7800 		lds r24,120
 420               	.LVL9:
 133:main.cpp      **** 	ADC_val+=ADCH<<8;
 421               		.loc 1 133 0
 422 0054 6091 7900 		lds r22,121
 423               	.LVL10:
 134:main.cpp      **** 	
 135:main.cpp      **** 	//CNT=1.1*1024/Vref
 136:main.cpp      **** 	//Vref=1.1*1024/CNT
 137:main.cpp      **** 	cnt=(1024.0*1100.0)/ADC_val;
 424               		.loc 1 137 0
 425 0058 70E0      		ldi r23,0
 426 005a 762F      		mov r23,r22
 427 005c 6627      		clr r22
 428               	.LVL11:
 429 005e 680F      		add r22,r24
 430 0060 711D      		adc r23,__zero_reg__
 431 0062 80E0      		ldi r24,0
 432 0064 90E0      		ldi r25,0
 433 0066 0E94 0000 		call __floatunsisf
 434               	.LVL12:
 435 006a 9B01      		movw r18,r22
 436 006c AC01      		movw r20,r24
 437 006e 60E0      		ldi r22,0
 438 0070 70E8      		ldi r23,lo8(-128)
 439 0072 89E8      		ldi r24,lo8(-119)
 440 0074 99E4      		ldi r25,lo8(73)
 441 0076 0E94 0000 		call __divsf3
 442               	.LVL13:
 443 007a 0E94 0000 		call __fixunssfsi
 444               	.LVL14:
 445 007e 6093 0000 		sts cnt,r22
 446 0082 7093 0000 		sts cnt+1,r23
 447 0086 8093 0000 		sts cnt+2,r24
 448 008a 9093 0000 		sts cnt+3,r25
 138:main.cpp      **** 	myLCD.setNb(cnt);
 449               		.loc 1 138 0
 450 008e 6091 0000 		lds r22,cnt
 451 0092 7091 0000 		lds r23,cnt+1
 452 0096 8091 0000 		lds r24,cnt+2
 453 009a 9091 0000 		lds r25,cnt+3
 454 009e 0E94 0000 		call _ZN3LCD5setNbEl
 455               	.LVL15:
 456               	/* epilogue start */
 139:main.cpp      **** }
 457               		.loc 1 139 0
 458 00a2 FF91      		pop r31
 459 00a4 EF91      		pop r30
 460 00a6 BF91      		pop r27
 461 00a8 AF91      		pop r26
 462 00aa 9F91      		pop r25
 463 00ac 8F91      		pop r24
 464 00ae 7F91      		pop r23
 465 00b0 6F91      		pop r22
 466 00b2 5F91      		pop r21
 467 00b4 4F91      		pop r20
 468 00b6 3F91      		pop r19
 469 00b8 2F91      		pop r18
 470 00ba 0F90      		pop r0
 471 00bc 0FBE      		out __SREG__,r0
 472 00be 0F90      		pop r0
 473 00c0 1F90      		pop r1
 474 00c2 1895      		reti
 475               		.cfi_endproc
 476               	.LFE12:
 478               	.global	USART_RX_vect
 480               	USART_RX_vect:
 481               	.LFB13:
 140:main.cpp      **** 
 141:main.cpp      **** ISR(USART_RX_vect){
 482               		.loc 1 141 0
 483               		.cfi_startproc
 484 00c4 1F92      		push r1
 485               	.LCFI21:
 486               		.cfi_def_cfa_offset 3
 487               		.cfi_offset 1, -2
 488 00c6 0F92      		push r0
 489               	.LCFI22:
 490               		.cfi_def_cfa_offset 4
 491               		.cfi_offset 0, -3
 492 00c8 0FB6      		in r0,__SREG__
 493 00ca 0F92      		push r0
 494 00cc 1124      		clr __zero_reg__
 495 00ce 2F93      		push r18
 496               	.LCFI23:
 497               		.cfi_def_cfa_offset 5
 498               		.cfi_offset 18, -4
 499 00d0 3F93      		push r19
 500               	.LCFI24:
 501               		.cfi_def_cfa_offset 6
 502               		.cfi_offset 19, -5
 503 00d2 4F93      		push r20
 504               	.LCFI25:
 505               		.cfi_def_cfa_offset 7
 506               		.cfi_offset 20, -6
 507 00d4 5F93      		push r21
 508               	.LCFI26:
 509               		.cfi_def_cfa_offset 8
 510               		.cfi_offset 21, -7
 511 00d6 6F93      		push r22
 512               	.LCFI27:
 513               		.cfi_def_cfa_offset 9
 514               		.cfi_offset 22, -8
 515 00d8 7F93      		push r23
 516               	.LCFI28:
 517               		.cfi_def_cfa_offset 10
 518               		.cfi_offset 23, -9
 519 00da 8F93      		push r24
 520               	.LCFI29:
 521               		.cfi_def_cfa_offset 11
 522               		.cfi_offset 24, -10
 523 00dc 9F93      		push r25
 524               	.LCFI30:
 525               		.cfi_def_cfa_offset 12
 526               		.cfi_offset 25, -11
 527 00de AF93      		push r26
 528               	.LCFI31:
 529               		.cfi_def_cfa_offset 13
 530               		.cfi_offset 26, -12
 531 00e0 BF93      		push r27
 532               	.LCFI32:
 533               		.cfi_def_cfa_offset 14
 534               		.cfi_offset 27, -13
 535 00e2 EF93      		push r30
 536               	.LCFI33:
 537               		.cfi_def_cfa_offset 15
 538               		.cfi_offset 30, -14
 539 00e4 FF93      		push r31
 540               	.LCFI34:
 541               		.cfi_def_cfa_offset 16
 542               		.cfi_offset 31, -15
 543               	/* prologue: Signal */
 544               	/* frame size = 0 */
 545               	/* stack size = 15 */
 546               	.L__stack_usage = 15
 142:main.cpp      **** 	uint8_t data=uart.getChar();
 547               		.loc 1 142 0
 548 00e6 80E0      		ldi r24,lo8(uart)
 549 00e8 90E0      		ldi r25,hi8(uart)
 550 00ea 0E94 0000 		call _ZN4UART7getCharEv
 551               	.LVL16:
 552               	/* epilogue start */
 143:main.cpp      **** }
 553               		.loc 1 143 0
 554 00ee FF91      		pop r31
 555 00f0 EF91      		pop r30
 556 00f2 BF91      		pop r27
 557 00f4 AF91      		pop r26
 558 00f6 9F91      		pop r25
 559 00f8 8F91      		pop r24
 560 00fa 7F91      		pop r23
 561 00fc 6F91      		pop r22
 562 00fe 5F91      		pop r21
 563 0100 4F91      		pop r20
 564 0102 3F91      		pop r19
 565 0104 2F91      		pop r18
 566 0106 0F90      		pop r0
 567 0108 0FBE      		out __SREG__,r0
 568 010a 0F90      		pop r0
 569 010c 1F90      		pop r1
 570 010e 1895      		reti
 571               		.cfi_endproc
 572               	.LFE13:
 574               		.section	.text.startup
 576               	_GLOBAL__sub_I_uart:
 577               	.LFB15:
 578               		.loc 1 143 0
 579               		.cfi_startproc
 580               	/* prologue: function */
 581               	/* frame size = 0 */
 582               	/* stack size = 0 */
 583               	.L__stack_usage = 0
 584               	.LVL17:
 585               	.LBB30:
 586               	.LBB31:
  12:main.cpp      **** MCP3462 myADC;
 587               		.loc 1 12 0
 588 017c 80E0      		ldi r24,lo8(uart)
 589 017e 90E0      		ldi r25,hi8(uart)
 590 0180 0E94 0000 		call _ZN4UARTC1Ev
 591               	.LVL18:
  13:main.cpp      **** SM mySM;
 592               		.loc 1 13 0
 593 0184 80E0      		ldi r24,lo8(myADC)
 594 0186 90E0      		ldi r25,hi8(myADC)
 595 0188 0E94 0000 		call _ZN7MCP3462C1Ev
 596               	.LVL19:
  14:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
 597               		.loc 1 14 0
 598 018c 80E0      		ldi r24,lo8(mySM)
 599 018e 90E0      		ldi r25,hi8(mySM)
 600 0190 0E94 0000 		call _ZN2SMC1Ev
 601               	.LVL20:
  15:main.cpp      **** 
 602               		.loc 1 15 0
 603 0194 60E0      		ldi r22,0
 604 0196 80E0      		ldi r24,lo8(myLCD)
 605 0198 90E0      		ldi r25,hi8(myLCD)
 606 019a 0C94 0000 		jmp _ZN3LCDC1Eb
 607               	.LVL21:
 608               	.LBE31:
 609               	.LBE30:
 610               		.cfi_endproc
 611               	.LFE15:
 613               		.global __do_global_ctors
 614               		.section .ctors,"a",@progbits
 615               		.p2align	1
 616 0000 0000      		.word	gs(_GLOBAL__sub_I_uart)
 617               		.section	.text.exit,"ax",@progbits
 619               	_GLOBAL__sub_D_uart:
 620               	.LFB16:
 621               		.loc 1 143 0
 622               		.cfi_startproc
 623               	/* prologue: function */
 624               	/* frame size = 0 */
 625               	/* stack size = 0 */
 626               	.L__stack_usage = 0
 627               	.LVL22:
 628               	.LBB36:
 629               	.LBB37:
 630               	.LBB38:
  15:main.cpp      **** 
 631               		.loc 1 15 0
 632 0000 80E0      		ldi r24,lo8(myLCD)
 633 0002 90E0      		ldi r25,hi8(myLCD)
 634 0004 0E94 0000 		call _ZN3LCDD1Ev
 635               	.LVL23:
  14:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
 636               		.loc 1 14 0
 637 0008 80E0      		ldi r24,lo8(mySM)
 638 000a 90E0      		ldi r25,hi8(mySM)
 639 000c 0E94 0000 		call _ZN2SMD1Ev
 640               	.LVL24:
  13:main.cpp      **** SM mySM;
 641               		.loc 1 13 0
 642 0010 80E0      		ldi r24,lo8(myADC)
 643 0012 90E0      		ldi r25,hi8(myADC)
 644 0014 0E94 0000 		call _ZN7MCP3462D1Ev
 645               	.LVL25:
  12:main.cpp      **** MCP3462 myADC;
 646               		.loc 1 12 0
 647 0018 80E0      		ldi r24,lo8(uart)
 648 001a 90E0      		ldi r25,hi8(uart)
 649 001c 0C94 0000 		jmp _ZN4UARTD1Ev
 650               	.LVL26:
 651               	.LBE38:
 652               	.LBE37:
 653               	.LBE36:
 654               		.cfi_endproc
 655               	.LFE16:
 657               		.global __do_global_dtors
 658               		.section .dtors,"a",@progbits
 659               		.p2align	1
 660 0000 0000      		.word	gs(_GLOBAL__sub_D_uart)
 661               	.global	state
 662               		.data
 665               	state:
 666 0000 01        		.byte	1
 667               	.global	cnt
 670               	cnt:
 671 0001 02        		.byte	2
 672 0002 E9        		.byte	-23
 673 0003 00        		.byte	0
 674 0004 00        		.byte	0
 675               	.global	myLCD
 676               		.section .bss
 679               	myLCD:
 680 0000 00        		.zero	1
 681               	.global	mySM
 684               	mySM:
 685 0001 0000      		.zero	2
 686               	.global	myADC
 689               	myADC:
 690 0003 00        		.zero	1
 691               	.global	uart
 694               	uart:
 695 0004 00        		.zero	1
 696               		.text
 697               	.Letext0:
 698               		.file 4 "/usr/lib/avr/include/stdint.h"
 699               		.file 5 "LCD.h"
 700               		.file 6 "UART.h"
 701               		.file 7 "ADC.h"
 702               		.file 8 "state_machine.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.cpp
     /tmp/cc1tvWc5.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1tvWc5.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1tvWc5.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1tvWc5.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1tvWc5.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1tvWc5.s:13     .text.startup:0000000000000000 main
     /tmp/cc1tvWc5.s:665    .data:0000000000000000 state
     /tmp/cc1tvWc5.s:694    .bss:0000000000000004 uart
     /tmp/cc1tvWc5.s:670    .data:0000000000000001 cnt
     /tmp/cc1tvWc5.s:296    .text:0000000000000000 __vector_3
     /tmp/cc1tvWc5.s:351    .text:000000000000002e __vector_19
     /tmp/cc1tvWc5.s:480    .text:00000000000000c4 USART_RX_vect
     /tmp/cc1tvWc5.s:576    .text.startup:000000000000017c _GLOBAL__sub_I_uart
     /tmp/cc1tvWc5.s:689    .bss:0000000000000003 myADC
     /tmp/cc1tvWc5.s:684    .bss:0000000000000001 mySM
     /tmp/cc1tvWc5.s:679    .bss:0000000000000000 myLCD
     /tmp/cc1tvWc5.s:619    .text.exit:0000000000000000 _GLOBAL__sub_D_uart

UNDEFINED SYMBOLS
_ZN7MCP346211isDataReadyEv
_ZN7MCP346213getDirectDataEv
__itoa_ncheck
_ZN4UART10sendStringEPc
_ZN3LCD10setBatteryENS_7BatteryE
__floatunsisf
__divsf3
__fixunssfsi
_ZN3LCD5setNbEl
_ZN4UART7getCharEv
_ZN4UARTC1Ev
_ZN7MCP3462C1Ev
_ZN2SMC1Ev
_ZN3LCDC1Eb
__do_global_ctors
_ZN3LCDD1Ev
_ZN2SMD1Ev
_ZN7MCP3462D1Ev
_ZN4UARTD1Ev
__do_global_dtors
__do_copy_data
__do_clear_bss
