   1               		.file	"main.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 5374 6172 		.string	"Start verbose streaming"
  12      7420 7665 
  12      7262 6F73 
  12      6520 7374 
  12      7265 616D 
  13               	.LC1:
  14 0018 5374 6172 		.string	"Start minimal streaming"
  14      7420 6D69 
  14      6E69 6D61 
  14      6C20 7374 
  14      7265 616D 
  15               	.LC2:
  16 0030 5374 6F70 		.string	"Stop streaming"
  16      2073 7472 
  16      6561 6D69 
  16      6E67 00
  17               	.LC3:
  18 003f 4375 7272 		.string	"Current tare is: "
  18      656E 7420 
  18      7461 7265 
  18      2069 733A 
  18      2000 
  19               	.LC4:
  20 0051 4E65 7720 		.string	"New tare set to: "
  20      7461 7265 
  20      2073 6574 
  20      2074 6F3A 
  20      2000 
  21               	.LC5:
  22 0063 4375 7272 		.string	"Current gain is: "
  22      656E 7420 
  22      6761 696E 
  22      2069 733A 
  22      2000 
  23               	.LC6:
  24 0075 4E65 7720 		.string	"New gain set to: "
  24      6761 696E 
  24      2073 6574 
  24      2074 6F3A 
  24      2000 
  25               	.LC7:
  26 0087 436F 6D6D 		.string	"Command not recognized !"
  26      616E 6420 
  26      6E6F 7420 
  26      7265 636F 
  26      676E 697A 
  27               		.section	.text.startup,"ax",@progbits
  28               	.global	main
  30               	main:
  31               	.LFB10:
  32               		.file 1 "main.cpp"
   1:main.cpp      **** #include <avr/io.h>
   2:main.cpp      **** #include <avr/interrupt.h>
   3:main.cpp      **** #include <avr/sleep.h>
   4:main.cpp      **** #include <util/delay.h>
   5:main.cpp      **** #include <stdlib.h> //for itoa
   6:main.cpp      **** 
   7:main.cpp      **** #include "state_machine.h"
   8:main.cpp      **** #include "LCD.h"
   9:main.cpp      **** #include "UART.h"
  10:main.cpp      **** 
  11:main.cpp      **** #define LED0_ON (PORTD|=(1<<6))
  12:main.cpp      **** #define LED0_OFF (PORTD&=~(1<<6))
  13:main.cpp      **** #define LED0_Toggle (PORTD^=(1<<6))
  14:main.cpp      **** 
  15:main.cpp      **** #define LED1_ON (PORTD|=(1<<7))
  16:main.cpp      **** #define LED1_OFF (PORTD&=~(1<<7))
  17:main.cpp      **** #define LED1_Toggle (PORTD^=(1<<7))
  18:main.cpp      **** 
  19:main.cpp      **** #define BTN0 (PIND&(1<<4))
  20:main.cpp      **** #define BTN1 (PIND&(1<<5))
  21:main.cpp      **** 
  22:main.cpp      **** #define IRQ_STATE (PINE&(1<<7))
  23:main.cpp      **** 
  24:main.cpp      **** #define PWR_en_ON (PORTE|=(1<<5))
  25:main.cpp      **** #define PWR_en_OFF (PORTE&=~(1<<6))
  26:main.cpp      **** #define LoadCell_en_ON (PORTE|=(1<<7))
  27:main.cpp      **** #define LoadCell_en_OFF (PORTE&=~(1<<7))
  28:main.cpp      **** 
  29:main.cpp      **** #define BATT_CUTOUT 295
  30:main.cpp      **** #define BATT_EMPTY 305
  31:main.cpp      **** #define BATT_ONEBAR 315
  32:main.cpp      **** #define BATT_TWOBAR 325
  33:main.cpp      **** #define BATT_FULL 335
  34:main.cpp      **** 
  35:main.cpp      **** UART uart;
  36:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
  37:main.cpp      **** Scale myScale=Scale(&uart);
  38:main.cpp      **** SM mySM(&uart, &myScale,&myLCD);
  39:main.cpp      **** 
  40:main.cpp      **** //Fuses -U lfuse:w:0xe2:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m 
  41:main.cpp      **** //Int RC osc, 6CK+65ms startup time
  42:main.cpp      **** //No Clock div by 8
  43:main.cpp      **** //Brown out detection enabled, 1.8V
  44:main.cpp      **** //For BoD at 2.7V, use Efuse=FB instead of FD
  45:main.cpp      **** 
  46:main.cpp      **** volatile uint8_t loop_cnt=0;
  47:main.cpp      **** volatile uint8_t btn_state=0;
  48:main.cpp      **** 
  49:main.cpp      **** int main(void){
  33               		.loc 1 49 0
  34               		.cfi_startproc
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 0 */
  38               	.L__stack_usage = 0
  50:main.cpp      **** 	
  51:main.cpp      **** 	DDRD=0b11000000; 	//LED0, LED1 as outputs, BTN 0/1 as inputs
  39               		.loc 1 51 0
  40 0000 80EC      		ldi r24,lo8(-64)
  41 0002 8AB9      		out 0xa,r24
  52:main.cpp      **** 	PORTD=0b00110000;			//LED initial state:low, enable BTN pullups
  42               		.loc 1 52 0
  43 0004 80E3      		ldi r24,lo8(48)
  44 0006 8BB9      		out 0xb,r24
  53:main.cpp      **** 	
  54:main.cpp      **** 	DDRE=0b01100011;//IRQ as input, LoadCell_en/PWR_en as outputs, TX as output, RX as input
  45               		.loc 1 54 0
  46 0008 83E6      		ldi r24,lo8(99)
  47 000a 8DB9      		out 0xd,r24
  55:main.cpp      **** 	PORTE=0b11100000;//Enable IRQ pullup, set LoadCell_en/PWR_en to 1
  48               		.loc 1 55 0
  49 000c 80EE      		ldi r24,lo8(-32)
  50 000e 8EB9      		out 0xe,r24
  56:main.cpp      **** 	
  57:main.cpp      **** 	LED0_ON;
  51               		.loc 1 57 0
  52 0010 5E9A      		sbi 0xb,6
  58:main.cpp      **** 	PRR|=(1<<PRTIM1);//Shut down clock to Timer1
  53               		.loc 1 58 0
  54 0012 8091 6400 		lds r24,100
  55 0016 8860      		ori r24,lo8(8)
  56 0018 8093 6400 		sts 100,r24
  59:main.cpp      **** 	
  60:main.cpp      **** 	ADMUX|=(1<<REFS0)|0b11110;//Set AVCC as reference voltage for ADC, ADC MUX input to 1.1V BG
  57               		.loc 1 60 0
  58 001c 8091 7C00 		lds r24,124
  59 0020 8E65      		ori r24,lo8(94)
  60 0022 8093 7C00 		sts 124,r24
  61:main.cpp      **** 	ADCSRA|=(1<<ADEN)|(1<<ADIE)|(1<<ADPS1);//Enable conversin complete interrupt, Clock prescaler 12MH
  61               		.loc 1 61 0
  62 0026 8091 7A00 		lds r24,122
  63 002a 8A68      		ori r24,lo8(-118)
  64 002c 8093 7A00 		sts 122,r24
  62:main.cpp      **** 	sei();
  65               		.loc 1 62 0
  66               	/* #APP */
  67               	 ;  62 "main.cpp" 1
  68 0030 7894      		sei
  69               	 ;  0 "" 2
  70               	/* #NOAPP */
  71               	.LBB15:
  63:main.cpp      **** 	
  64:main.cpp      **** 	
  65:main.cpp      **** 	while(1){
  66:main.cpp      **** 	
  67:main.cpp      **** 		_delay_ms(10);
  68:main.cpp      **** 		loop_cnt++;
  69:main.cpp      **** 		if(loop_cnt>9){
  70:main.cpp      **** 			loop_cnt=0;
  71:main.cpp      **** 			mySM.update();
  72:main.cpp      **** 		}
  73:main.cpp      **** 
  74:main.cpp      **** 		if(BTN0!=btn_state){
  75:main.cpp      **** 			btn_state=BTN0;
  76:main.cpp      **** 			if(btn_state){
  77:main.cpp      **** 				LED0_Toggle;
  72               		.loc 1 77 0
  73 0032 00E4      		ldi r16,lo8(64)
  74               	.LBB16:
  75               	.LBB17:
  76               	.LBB18:
  77               	.LBB19:
  78               	.LBB20:
  79               	.LBB21:
  78:main.cpp      **** 			}
  79:main.cpp      **** 		}
  80:main.cpp      **** 		if(uart.isDataAvailable()){
  81:main.cpp      **** 			char *cmd=uart.retrieve();
  82:main.cpp      **** 			switch(cmd[0]){
  83:main.cpp      **** 				case 'R':
  84:main.cpp      **** 					mySM.stream(1,1);
  85:main.cpp      **** 					uart.sendString("Start verbose streaming",true);
  86:main.cpp      **** 					break;
  87:main.cpp      **** 					
  88:main.cpp      **** 				case 'r':
  89:main.cpp      **** 					mySM.stream(1,0);
  90:main.cpp      **** 					uart.sendString("Start minimal streaming",true);
  91:main.cpp      **** 					break;
  92:main.cpp      **** 					
  93:main.cpp      **** 				case 'q':
  94:main.cpp      **** 				case 'Q':
  95:main.cpp      **** 					mySM.stream(0,0);
  96:main.cpp      **** 					uart.sendString("Stop streaming",true);
  97:main.cpp      **** 					break;
  98:main.cpp      **** 					
  99:main.cpp      **** 				case 't':
 100:main.cpp      **** 				case 'T':
 101:main.cpp      **** 					if(cmd[1]=='?'){
 102:main.cpp      **** 						uart.sendString("Current tare is: ");
 103:main.cpp      **** 						uart.sendNb(mySM.myScale->offset);
 104:main.cpp      **** 					}else{
 105:main.cpp      **** 						uart.sendString("New tare set to: ");
 106:main.cpp      **** 						cmd[0]=' ';
  80               		.loc 1 106 0
  81 0034 10E2      		ldi r17,lo8(32)
  82               	.L7:
  83               	.LVL0:
  84               	.LBE21:
  85               	.LBE20:
  86               	.LBE19:
  87               	.LBE18:
  88               	.LBE17:
  89               	.LBE16:
  90               	.LBB29:
  91               	.LBB30:
  92               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  93               		.loc 2 187 0
  94 0036 8FE1      		ldi r24,lo8(19999)
  95 0038 9EE4      		ldi r25,hi8(19999)
  96 003a 0197      	1:	sbiw r24,1
  97 003c 01F4      		brne 1b
  98 003e 00C0      		rjmp .
  99 0040 0000      		nop
 100               	.LVL1:
 101               	.LBE30:
 102               	.LBE29:
  68:main.cpp      **** 		if(loop_cnt>9){
 103               		.loc 1 68 0
 104 0042 8091 0000 		lds r24,loop_cnt
 105 0046 8F5F      		subi r24,lo8(-(1))
 106 0048 8093 0000 		sts loop_cnt,r24
  69:main.cpp      **** 			loop_cnt=0;
 107               		.loc 1 69 0
 108 004c 8091 0000 		lds r24,loop_cnt
 109 0050 8A30      		cpi r24,lo8(10)
 110 0052 00F0      		brlo .L3
  70:main.cpp      **** 			mySM.update();
 111               		.loc 1 70 0
 112 0054 1092 0000 		sts loop_cnt,__zero_reg__
  71:main.cpp      **** 		}
 113               		.loc 1 71 0
 114 0058 80E0      		ldi r24,lo8(mySM)
 115 005a 90E0      		ldi r25,hi8(mySM)
 116 005c 0E94 0000 		call _ZN2SM6updateEv
 117               	.LVL2:
 118               	.L3:
  74:main.cpp      **** 			btn_state=BTN0;
 119               		.loc 1 74 0
 120 0060 89B1      		in r24,0x9
 121 0062 9091 0000 		lds r25,btn_state
 122 0066 8071      		andi r24,lo8(16)
 123 0068 8917      		cp r24,r25
 124 006a 01F0      		breq .L5
  75:main.cpp      **** 			if(btn_state){
 125               		.loc 1 75 0
 126 006c 89B1      		in r24,0x9
 127 006e 8071      		andi r24,lo8(16)
 128 0070 8093 0000 		sts btn_state,r24
  76:main.cpp      **** 				LED0_Toggle;
 129               		.loc 1 76 0
 130 0074 8091 0000 		lds r24,btn_state
 131 0078 8823      		tst r24
 132 007a 01F0      		breq .L5
  77:main.cpp      **** 			}
 133               		.loc 1 77 0
 134 007c 8BB1      		in r24,0xb
 135 007e 8027      		eor r24,r16
 136 0080 8BB9      		out 0xb,r24
 137               	.L5:
 138               	.LBB31:
  80:main.cpp      **** 			char *cmd=uart.retrieve();
 139               		.loc 1 80 0
 140 0082 80E0      		ldi r24,lo8(uart)
 141 0084 90E0      		ldi r25,hi8(uart)
 142 0086 0E94 0000 		call _ZN4UART15isDataAvailableEv
 143               	.LVL3:
 144 008a 8823      		tst r24
 145 008c 01F0      		breq .L7
 146               	.LBB28:
  81:main.cpp      **** 			switch(cmd[0]){
 147               		.loc 1 81 0
 148 008e 80E0      		ldi r24,lo8(uart)
 149 0090 90E0      		ldi r25,hi8(uart)
 150 0092 0E94 0000 		call _ZN4UART8retrieveEv
 151               	.LVL4:
 152 0096 EC01      		movw r28,r24
 153               	.LVL5:
 154               	.LBB27:
  82:main.cpp      **** 				case 'R':
 155               		.loc 1 82 0
 156 0098 8881      		ld r24,Y
 157               	.LVL6:
 158 009a 8435      		cpi r24,lo8(84)
 159 009c 01F0      		breq .L9
 160 009e 00F4      		brsh .L10
 161 00a0 8135      		cpi r24,lo8(81)
 162 00a2 01F0      		breq .L11
 163 00a4 8235      		cpi r24,lo8(82)
 164 00a6 01F0      		breq .L12
 165 00a8 8334      		cpi r24,lo8(67)
 166 00aa 01F0      		breq .+2
 167 00ac 00C0      		rjmp .L8
 168 00ae 00C0      		rjmp .L13
 169               	.L10:
 170 00b0 8137      		cpi r24,lo8(113)
 171 00b2 01F0      		breq .L11
 172 00b4 00F4      		brsh .L14
 173 00b6 8336      		cpi r24,lo8(99)
 174 00b8 01F4      		brne .+2
 175 00ba 00C0      		rjmp .L13
 176 00bc 00C0      		rjmp .L8
 177               	.L14:
 178 00be 8237      		cpi r24,lo8(114)
 179 00c0 01F0      		breq .L15
 180 00c2 8437      		cpi r24,lo8(116)
 181 00c4 01F0      		breq .L9
 182 00c6 00C0      		rjmp .L8
 183               	.L12:
 184               	.LBB26:
  84:main.cpp      **** 					uart.sendString("Start verbose streaming",true);
 185               		.loc 1 84 0
 186 00c8 41E0      		ldi r20,lo8(1)
 187 00ca 61E0      		ldi r22,lo8(1)
 188 00cc 80E0      		ldi r24,lo8(mySM)
 189 00ce 90E0      		ldi r25,hi8(mySM)
 190 00d0 0E94 0000 		call _ZN2SM6streamEbb
 191               	.LVL7:
  85:main.cpp      **** 					break;
 192               		.loc 1 85 0
 193 00d4 41E0      		ldi r20,lo8(1)
 194 00d6 60E0      		ldi r22,lo8(.LC0)
 195 00d8 70E0      		ldi r23,hi8(.LC0)
 196 00da 00C0      		rjmp .L43
 197               	.L15:
  89:main.cpp      **** 					uart.sendString("Start minimal streaming",true);
 198               		.loc 1 89 0
 199 00dc 40E0      		ldi r20,0
 200 00de 61E0      		ldi r22,lo8(1)
 201 00e0 80E0      		ldi r24,lo8(mySM)
 202 00e2 90E0      		ldi r25,hi8(mySM)
 203 00e4 0E94 0000 		call _ZN2SM6streamEbb
 204               	.LVL8:
  90:main.cpp      **** 					break;
 205               		.loc 1 90 0
 206 00e8 41E0      		ldi r20,lo8(1)
 207 00ea 60E0      		ldi r22,lo8(.LC1)
 208 00ec 70E0      		ldi r23,hi8(.LC1)
 209               	.L43:
 210 00ee 80E0      		ldi r24,lo8(uart)
 211 00f0 90E0      		ldi r25,hi8(uart)
 212 00f2 0E94 0000 		call _ZN4UART10sendStringEPcb
 213               	.LVL9:
  91:main.cpp      **** 					
 214               		.loc 1 91 0
 215 00f6 00C0      		rjmp .L7
 216               	.L11:
  95:main.cpp      **** 					uart.sendString("Stop streaming",true);
 217               		.loc 1 95 0
 218 00f8 40E0      		ldi r20,0
 219 00fa 60E0      		ldi r22,0
 220 00fc 80E0      		ldi r24,lo8(mySM)
 221 00fe 90E0      		ldi r25,hi8(mySM)
 222 0100 0E94 0000 		call _ZN2SM6streamEbb
 223               	.LVL10:
  96:main.cpp      **** 					break;
 224               		.loc 1 96 0
 225 0104 41E0      		ldi r20,lo8(1)
 226 0106 60E0      		ldi r22,lo8(.LC2)
 227 0108 70E0      		ldi r23,hi8(.LC2)
 228 010a 00C0      		rjmp .L43
 229               	.L9:
 230               	.LBB23:
 101:main.cpp      **** 						uart.sendString("Current tare is: ");
 231               		.loc 1 101 0
 232 010c 8981      		ldd r24,Y+1
 233 010e 8F33      		cpi r24,lo8(63)
 234 0110 01F4      		brne .L17
 102:main.cpp      **** 						uart.sendNb(mySM.myScale->offset);
 235               		.loc 1 102 0
 236 0112 60E0      		ldi r22,lo8(.LC3)
 237 0114 70E0      		ldi r23,hi8(.LC3)
 238 0116 80E0      		ldi r24,lo8(uart)
 239 0118 90E0      		ldi r25,hi8(uart)
 240 011a 0E94 0000 		call _ZN4UART10sendStringEPc
 241               	.LVL11:
 103:main.cpp      **** 					}else{
 242               		.loc 1 103 0
 243 011e E091 0000 		lds r30,mySM
 244 0122 F091 0000 		lds r31,mySM+1
 245 0126 4481      		ldd r20,Z+4
 246 0128 5581      		ldd r21,Z+5
 247 012a 6681      		ldd r22,Z+6
 248 012c 7781      		ldd r23,Z+7
 249 012e 00C0      		rjmp .L44
 250               	.L17:
 251               	.LBB22:
 105:main.cpp      **** 						cmd[0]=' ';
 252               		.loc 1 105 0
 253 0130 60E0      		ldi r22,lo8(.LC4)
 254 0132 70E0      		ldi r23,hi8(.LC4)
 255 0134 80E0      		ldi r24,lo8(uart)
 256 0136 90E0      		ldi r25,hi8(uart)
 257 0138 0E94 0000 		call _ZN4UART10sendStringEPc
 258               	.LVL12:
 259               		.loc 1 106 0
 260 013c 1883      		st Y,r17
 107:main.cpp      **** 						int32_t tare=strtol(cmd,NULL,10);
 261               		.loc 1 107 0
 262 013e 4AE0      		ldi r20,lo8(10)
 263 0140 50E0      		ldi r21,0
 264 0142 60E0      		ldi r22,0
 265 0144 70E0      		ldi r23,0
 266 0146 CE01      		movw r24,r28
 267 0148 0E94 0000 		call strtol
 268               	.LVL13:
 269 014c 6B01      		movw r12,r22
 270 014e 7C01      		movw r14,r24
 271               	.LVL14:
 108:main.cpp      **** 						if(tare==0)tare=mySM.myScale->value;
 272               		.loc 1 108 0
 273 0150 672B      		or r22,r23
 274 0152 682B      		or r22,r24
 275 0154 692B      		or r22,r25
 276 0156 01F4      		brne .L18
 277               		.loc 1 108 0 is_stmt 0 discriminator 1
 278 0158 E091 0000 		lds r30,mySM
 279 015c F091 0000 		lds r31,mySM+1
 280 0160 C084      		ldd r12,Z+8
 281 0162 D184      		ldd r13,Z+9
 282 0164 E284      		ldd r14,Z+10
 283 0166 F384      		ldd r15,Z+11
 284               	.LVL15:
 285               	.L18:
 109:main.cpp      **** 						uart.sendNb(tare);
 286               		.loc 1 109 0 is_stmt 1
 287 0168 B701      		movw r22,r14
 288 016a A601      		movw r20,r12
 289 016c 80E0      		ldi r24,lo8(uart)
 290 016e 90E0      		ldi r25,hi8(uart)
 291 0170 0E94 0000 		call _ZN4UART6sendNbEl
 292               	.LVL16:
 110:main.cpp      **** 						mySM.myScale->offset=tare;
 293               		.loc 1 110 0
 294 0174 E091 0000 		lds r30,mySM
 295 0178 F091 0000 		lds r31,mySM+1
 296 017c C482      		std Z+4,r12
 297 017e D582      		std Z+5,r13
 298 0180 E682      		std Z+6,r14
 299 0182 F782      		std Z+7,r15
 300 0184 00C0      		rjmp .L7
 301               	.LVL17:
 302               	.L13:
 303               	.LBE22:
 304               	.LBE23:
 305               	.LBB24:
 111:main.cpp      **** 					}
 112:main.cpp      **** 					break;
 113:main.cpp      **** 				
 114:main.cpp      **** 				case 'C':
 115:main.cpp      **** 				case 'c':
 116:main.cpp      **** 					if(cmd[1]=='?'){
 306               		.loc 1 116 0
 307 0186 8981      		ldd r24,Y+1
 308 0188 8F33      		cpi r24,lo8(63)
 309 018a 01F4      		brne .L19
 117:main.cpp      **** 						uart.sendString("Current gain is: ");
 310               		.loc 1 117 0
 311 018c 60E0      		ldi r22,lo8(.LC5)
 312 018e 70E0      		ldi r23,hi8(.LC5)
 313 0190 80E0      		ldi r24,lo8(uart)
 314 0192 90E0      		ldi r25,hi8(uart)
 315 0194 0E94 0000 		call _ZN4UART10sendStringEPc
 316               	.LVL18:
 118:main.cpp      **** 						uart.sendNb(mySM.myScale->gain);
 317               		.loc 1 118 0
 318 0198 E091 0000 		lds r30,mySM
 319 019c F091 0000 		lds r31,mySM+1
 320 01a0 4081      		ld r20,Z
 321 01a2 5181      		ldd r21,Z+1
 322 01a4 6281      		ldd r22,Z+2
 323 01a6 7381      		ldd r23,Z+3
 324               	.L44:
 325 01a8 80E0      		ldi r24,lo8(uart)
 326 01aa 90E0      		ldi r25,hi8(uart)
 327 01ac 0E94 0000 		call _ZN4UART6sendNbEl
 328               	.LVL19:
 329 01b0 00C0      		rjmp .L7
 330               	.L19:
 331               	.LBB25:
 119:main.cpp      **** 					}else{
 120:main.cpp      **** 						uart.sendString("New gain set to: ");
 332               		.loc 1 120 0
 333 01b2 60E0      		ldi r22,lo8(.LC6)
 334 01b4 70E0      		ldi r23,hi8(.LC6)
 335 01b6 80E0      		ldi r24,lo8(uart)
 336 01b8 90E0      		ldi r25,hi8(uart)
 337 01ba 0E94 0000 		call _ZN4UART10sendStringEPc
 338               	.LVL20:
 121:main.cpp      **** 						cmd[0]=' ';
 339               		.loc 1 121 0
 340 01be 1883      		st Y,r17
 122:main.cpp      **** 						int32_t gain=strtol(cmd,NULL,10)/(mySM.myScale->value-mySM.myScale->offset);
 341               		.loc 1 122 0
 342 01c0 4AE0      		ldi r20,lo8(10)
 343 01c2 50E0      		ldi r21,0
 344 01c4 60E0      		ldi r22,0
 345 01c6 70E0      		ldi r23,0
 346 01c8 CE01      		movw r24,r28
 347 01ca 0E94 0000 		call strtol
 348               	.LVL21:
 349 01ce E091 0000 		lds r30,mySM
 350 01d2 F091 0000 		lds r31,mySM+1
 351 01d6 8084      		ldd r8,Z+8
 352 01d8 9184      		ldd r9,Z+9
 353 01da A284      		ldd r10,Z+10
 354 01dc B384      		ldd r11,Z+11
 355 01de C480      		ldd r12,Z+4
 356 01e0 D580      		ldd r13,Z+5
 357 01e2 E680      		ldd r14,Z+6
 358 01e4 F780      		ldd r15,Z+7
 359 01e6 A501      		movw r20,r10
 360 01e8 9401      		movw r18,r8
 361 01ea 2C19      		sub r18,r12
 362 01ec 3D09      		sbc r19,r13
 363 01ee 4E09      		sbc r20,r14
 364 01f0 5F09      		sbc r21,r15
 365 01f2 0E94 0000 		call __divmodsi4
 366 01f6 6901      		movw r12,r18
 367 01f8 7A01      		movw r14,r20
 368               	.LVL22:
 123:main.cpp      **** 						uart.sendNb(gain);
 369               		.loc 1 123 0
 370 01fa BA01      		movw r22,r20
 371 01fc A901      		movw r20,r18
 372 01fe 80E0      		ldi r24,lo8(uart)
 373 0200 90E0      		ldi r25,hi8(uart)
 374 0202 0E94 0000 		call _ZN4UART6sendNbEl
 375               	.LVL23:
 124:main.cpp      **** 						mySM.myScale->gain=gain;
 376               		.loc 1 124 0
 377 0206 E091 0000 		lds r30,mySM
 378 020a F091 0000 		lds r31,mySM+1
 379 020e C082      		st Z,r12
 380 0210 D182      		std Z+1,r13
 381 0212 E282      		std Z+2,r14
 382 0214 F382      		std Z+3,r15
 383 0216 00C0      		rjmp .L7
 384               	.LVL24:
 385               	.L8:
 386               	.LBE25:
 387               	.LBE24:
 125:main.cpp      **** 					}
 126:main.cpp      **** 					break;
 127:main.cpp      **** 					
 128:main.cpp      **** 				default:
 129:main.cpp      **** 					uart.sendString("Command not recognized !",true);
 388               		.loc 1 129 0
 389 0218 41E0      		ldi r20,lo8(1)
 390 021a 60E0      		ldi r22,lo8(.LC7)
 391 021c 70E0      		ldi r23,hi8(.LC7)
 392 021e 00C0      		rjmp .L43
 393               	.LBE26:
 394               	.LBE27:
 395               	.LBE28:
 396               	.LBE31:
 397               	.LBE15:
 398               		.cfi_endproc
 399               	.LFE10:
 401               	.global	__floatunsisf
 402               	.global	__divsf3
 403               	.global	__fixunssfsi
 404               		.text
 405               	.global	__vector_19
 407               	__vector_19:
 408               	.LFB11:
 130:main.cpp      **** 					break;
 131:main.cpp      **** 			}
 132:main.cpp      **** 		}
 133:main.cpp      **** 	}
 134:main.cpp      **** 
 135:main.cpp      **** 	return 0;
 136:main.cpp      **** }
 137:main.cpp      **** 
 138:main.cpp      **** 
 139:main.cpp      **** 
 140:main.cpp      **** 
 141:main.cpp      **** ISR(ADC_vect){
 409               		.loc 1 141 0
 410               		.cfi_startproc
 411 0000 1F92      		push r1
 412               	.LCFI0:
 413               		.cfi_def_cfa_offset 3
 414               		.cfi_offset 1, -2
 415 0002 0F92      		push r0
 416               	.LCFI1:
 417               		.cfi_def_cfa_offset 4
 418               		.cfi_offset 0, -3
 419 0004 0FB6      		in r0,__SREG__
 420 0006 0F92      		push r0
 421 0008 1124      		clr __zero_reg__
 422 000a CF92      		push r12
 423               	.LCFI2:
 424               		.cfi_def_cfa_offset 5
 425               		.cfi_offset 12, -4
 426 000c DF92      		push r13
 427               	.LCFI3:
 428               		.cfi_def_cfa_offset 6
 429               		.cfi_offset 13, -5
 430 000e EF92      		push r14
 431               	.LCFI4:
 432               		.cfi_def_cfa_offset 7
 433               		.cfi_offset 14, -6
 434 0010 FF92      		push r15
 435               	.LCFI5:
 436               		.cfi_def_cfa_offset 8
 437               		.cfi_offset 15, -7
 438 0012 2F93      		push r18
 439               	.LCFI6:
 440               		.cfi_def_cfa_offset 9
 441               		.cfi_offset 18, -8
 442 0014 3F93      		push r19
 443               	.LCFI7:
 444               		.cfi_def_cfa_offset 10
 445               		.cfi_offset 19, -9
 446 0016 4F93      		push r20
 447               	.LCFI8:
 448               		.cfi_def_cfa_offset 11
 449               		.cfi_offset 20, -10
 450 0018 5F93      		push r21
 451               	.LCFI9:
 452               		.cfi_def_cfa_offset 12
 453               		.cfi_offset 21, -11
 454 001a 6F93      		push r22
 455               	.LCFI10:
 456               		.cfi_def_cfa_offset 13
 457               		.cfi_offset 22, -12
 458 001c 7F93      		push r23
 459               	.LCFI11:
 460               		.cfi_def_cfa_offset 14
 461               		.cfi_offset 23, -13
 462 001e 8F93      		push r24
 463               	.LCFI12:
 464               		.cfi_def_cfa_offset 15
 465               		.cfi_offset 24, -14
 466 0020 9F93      		push r25
 467               	.LCFI13:
 468               		.cfi_def_cfa_offset 16
 469               		.cfi_offset 25, -15
 470 0022 AF93      		push r26
 471               	.LCFI14:
 472               		.cfi_def_cfa_offset 17
 473               		.cfi_offset 26, -16
 474 0024 BF93      		push r27
 475               	.LCFI15:
 476               		.cfi_def_cfa_offset 18
 477               		.cfi_offset 27, -17
 478 0026 EF93      		push r30
 479               	.LCFI16:
 480               		.cfi_def_cfa_offset 19
 481               		.cfi_offset 30, -18
 482 0028 FF93      		push r31
 483               	.LCFI17:
 484               		.cfi_def_cfa_offset 20
 485               		.cfi_offset 31, -19
 486               	/* prologue: Signal */
 487               	/* frame size = 0 */
 488               	/* stack size = 19 */
 489               	.L__stack_usage = 19
 142:main.cpp      **** 	uint16_t ADC_val=ADCL;
 490               		.loc 1 142 0
 491 002a 8091 7800 		lds r24,120
 492               	.LVL25:
 143:main.cpp      **** 	ADC_val+=ADCH<<8;
 493               		.loc 1 143 0
 494 002e 6091 7900 		lds r22,121
 495               	.LVL26:
 144:main.cpp      **** 	
 145:main.cpp      **** 	//CNT=1.1*1024/Vref
 146:main.cpp      **** 	//Vref=1.1*1024/CNT
 147:main.cpp      **** 	//1.02578
 148:main.cpp      **** 	//1.0127
 149:main.cpp      **** 	//
 150:main.cpp      **** 	uint32_t cnt=(109875.0)/ADC_val;// in tens of mV, i.e. 330=>3.30V
 496               		.loc 1 150 0
 497 0032 70E0      		ldi r23,0
 498 0034 762F      		mov r23,r22
 499 0036 6627      		clr r22
 500               	.LVL27:
 501 0038 680F      		add r22,r24
 502 003a 711D      		adc r23,__zero_reg__
 503 003c 80E0      		ldi r24,0
 504 003e 90E0      		ldi r25,0
 505 0040 0E94 0000 		call __floatunsisf
 506               	.LVL28:
 507 0044 9B01      		movw r18,r22
 508 0046 AC01      		movw r20,r24
 509 0048 60E8      		ldi r22,lo8(-128)
 510 004a 79E9      		ldi r23,lo8(-103)
 511 004c 86ED      		ldi r24,lo8(-42)
 512 004e 97E4      		ldi r25,lo8(71)
 513 0050 0E94 0000 		call __divsf3
 514               	.LVL29:
 515 0054 0E94 0000 		call __fixunssfsi
 516               	.LVL30:
 517 0058 6B01      		movw r12,r22
 518 005a 7C01      		movw r14,r24
 519               	.LVL31:
 151:main.cpp      **** 	myLCD.setNb(cnt,3);
 520               		.loc 1 151 0
 521 005c 43E0      		ldi r20,lo8(3)
 522 005e 0E94 0000 		call _ZN3LCD5setNbElh
 523               	.LVL32:
 152:main.cpp      **** 	if(cnt>=BATT_FULL){
 524               		.loc 1 152 0
 525 0062 8FE4      		ldi r24,79
 526 0064 C816      		cp r12,r24
 527 0066 81E0      		ldi r24,1
 528 0068 D806      		cpc r13,r24
 529 006a E104      		cpc r14,__zero_reg__
 530 006c F104      		cpc r15,__zero_reg__
 531 006e 00F0      		brlo .L47
 153:main.cpp      **** 		myLCD.setBattery(LCD::FULL);
 532               		.loc 1 153 0
 533 0070 87E0      		ldi r24,lo8(7)
 534 0072 00C0      		rjmp .L52
 535               	.L47:
 154:main.cpp      **** 	}else if(cnt>=BATT_TWOBAR){
 536               		.loc 1 154 0
 537 0074 85E4      		ldi r24,69
 538 0076 C816      		cp r12,r24
 539 0078 81E0      		ldi r24,1
 540 007a D806      		cpc r13,r24
 541 007c E104      		cpc r14,__zero_reg__
 542 007e F104      		cpc r15,__zero_reg__
 543 0080 00F0      		brlo .L49
 155:main.cpp      **** 		myLCD.setBattery(LCD::TWOBAR);
 544               		.loc 1 155 0
 545 0082 86E0      		ldi r24,lo8(6)
 546 0084 00C0      		rjmp .L52
 547               	.L49:
 156:main.cpp      **** 	}else if(cnt>=BATT_ONEBAR){
 548               		.loc 1 156 0
 549 0086 8BE3      		ldi r24,59
 550 0088 C816      		cp r12,r24
 551 008a 81E0      		ldi r24,1
 552 008c D806      		cpc r13,r24
 553 008e E104      		cpc r14,__zero_reg__
 554 0090 F104      		cpc r15,__zero_reg__
 555 0092 00F0      		brlo .L50
 157:main.cpp      **** 		myLCD.setBattery(LCD::ONEBAR);
 556               		.loc 1 157 0
 557 0094 85E0      		ldi r24,lo8(5)
 558 0096 00C0      		rjmp .L52
 559               	.L50:
 158:main.cpp      **** 	}else if(cnt>=BATT_EMPTY){
 560               		.loc 1 158 0
 561 0098 81E3      		ldi r24,49
 562 009a C816      		cp r12,r24
 563 009c 81E0      		ldi r24,1
 564 009e D806      		cpc r13,r24
 565 00a0 E104      		cpc r14,__zero_reg__
 566 00a2 F104      		cpc r15,__zero_reg__
 567 00a4 00F0      		brlo .L51
 159:main.cpp      **** 		myLCD.setBattery(LCD::EMPTY);
 568               		.loc 1 159 0
 569 00a6 81E0      		ldi r24,lo8(1)
 570 00a8 00C0      		rjmp .L52
 571               	.L51:
 160:main.cpp      **** 	}else{
 161:main.cpp      **** 		myLCD.setBattery(LCD::NONE);
 572               		.loc 1 161 0
 573 00aa 80E0      		ldi r24,0
 574               	.L52:
 575 00ac 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 576               	.LVL33:
 577               	/* epilogue start */
 162:main.cpp      **** 		//we should shutdown here
 163:main.cpp      **** 	}
 164:main.cpp      **** }
 578               		.loc 1 164 0
 579 00b0 FF91      		pop r31
 580 00b2 EF91      		pop r30
 581 00b4 BF91      		pop r27
 582 00b6 AF91      		pop r26
 583 00b8 9F91      		pop r25
 584 00ba 8F91      		pop r24
 585 00bc 7F91      		pop r23
 586 00be 6F91      		pop r22
 587 00c0 5F91      		pop r21
 588 00c2 4F91      		pop r20
 589 00c4 3F91      		pop r19
 590 00c6 2F91      		pop r18
 591 00c8 FF90      		pop r15
 592 00ca EF90      		pop r14
 593 00cc DF90      		pop r13
 594 00ce CF90      		pop r12
 595               	.LVL34:
 596 00d0 0F90      		pop r0
 597 00d2 0FBE      		out __SREG__,r0
 598 00d4 0F90      		pop r0
 599 00d6 1F90      		pop r1
 600 00d8 1895      		reti
 601               		.cfi_endproc
 602               	.LFE11:
 604               	.global	__vector_13
 606               	__vector_13:
 607               	.LFB12:
 165:main.cpp      **** 
 166:main.cpp      **** ISR(USART0_RX_vect){
 608               		.loc 1 166 0
 609               		.cfi_startproc
 610 00da 1F92      		push r1
 611               	.LCFI18:
 612               		.cfi_def_cfa_offset 3
 613               		.cfi_offset 1, -2
 614 00dc 0F92      		push r0
 615               	.LCFI19:
 616               		.cfi_def_cfa_offset 4
 617               		.cfi_offset 0, -3
 618 00de 0FB6      		in r0,__SREG__
 619 00e0 0F92      		push r0
 620 00e2 1124      		clr __zero_reg__
 621 00e4 2F93      		push r18
 622               	.LCFI20:
 623               		.cfi_def_cfa_offset 5
 624               		.cfi_offset 18, -4
 625 00e6 3F93      		push r19
 626               	.LCFI21:
 627               		.cfi_def_cfa_offset 6
 628               		.cfi_offset 19, -5
 629 00e8 4F93      		push r20
 630               	.LCFI22:
 631               		.cfi_def_cfa_offset 7
 632               		.cfi_offset 20, -6
 633 00ea 5F93      		push r21
 634               	.LCFI23:
 635               		.cfi_def_cfa_offset 8
 636               		.cfi_offset 21, -7
 637 00ec 6F93      		push r22
 638               	.LCFI24:
 639               		.cfi_def_cfa_offset 9
 640               		.cfi_offset 22, -8
 641 00ee 7F93      		push r23
 642               	.LCFI25:
 643               		.cfi_def_cfa_offset 10
 644               		.cfi_offset 23, -9
 645 00f0 8F93      		push r24
 646               	.LCFI26:
 647               		.cfi_def_cfa_offset 11
 648               		.cfi_offset 24, -10
 649 00f2 9F93      		push r25
 650               	.LCFI27:
 651               		.cfi_def_cfa_offset 12
 652               		.cfi_offset 25, -11
 653 00f4 AF93      		push r26
 654               	.LCFI28:
 655               		.cfi_def_cfa_offset 13
 656               		.cfi_offset 26, -12
 657 00f6 BF93      		push r27
 658               	.LCFI29:
 659               		.cfi_def_cfa_offset 14
 660               		.cfi_offset 27, -13
 661 00f8 EF93      		push r30
 662               	.LCFI30:
 663               		.cfi_def_cfa_offset 15
 664               		.cfi_offset 30, -14
 665 00fa FF93      		push r31
 666               	.LCFI31:
 667               		.cfi_def_cfa_offset 16
 668               		.cfi_offset 31, -15
 669               	/* prologue: Signal */
 670               	/* frame size = 0 */
 671               	/* stack size = 15 */
 672               	.L__stack_usage = 15
 167:main.cpp      **** 	uart.receive();
 673               		.loc 1 167 0
 674 00fc 80E0      		ldi r24,lo8(uart)
 675 00fe 90E0      		ldi r25,hi8(uart)
 676 0100 0E94 0000 		call _ZN4UART7receiveEv
 677               	.LVL35:
 678               	/* epilogue start */
 168:main.cpp      **** }
 679               		.loc 1 168 0
 680 0104 FF91      		pop r31
 681 0106 EF91      		pop r30
 682 0108 BF91      		pop r27
 683 010a AF91      		pop r26
 684 010c 9F91      		pop r25
 685 010e 8F91      		pop r24
 686 0110 7F91      		pop r23
 687 0112 6F91      		pop r22
 688 0114 5F91      		pop r21
 689 0116 4F91      		pop r20
 690 0118 3F91      		pop r19
 691 011a 2F91      		pop r18
 692 011c 0F90      		pop r0
 693 011e 0FBE      		out __SREG__,r0
 694 0120 0F90      		pop r0
 695 0122 1F90      		pop r1
 696 0124 1895      		reti
 697               		.cfi_endproc
 698               	.LFE12:
 700               		.section	.text.startup
 702               	_GLOBAL__sub_I_uart:
 703               	.LFB14:
 704               		.loc 1 168 0
 705               		.cfi_startproc
 706               	/* prologue: function */
 707               	/* frame size = 0 */
 708               	/* stack size = 0 */
 709               	.L__stack_usage = 0
 710               	.LVL36:
 711               	.LBB34:
 712               	.LBB35:
  35:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
 713               		.loc 1 35 0
 714 0220 80E0      		ldi r24,lo8(uart)
 715 0222 90E0      		ldi r25,hi8(uart)
 716 0224 0E94 0000 		call _ZN4UARTC1Ev
 717               	.LVL37:
  36:main.cpp      **** Scale myScale=Scale(&uart);
 718               		.loc 1 36 0
 719 0228 60E0      		ldi r22,0
 720 022a 80E0      		ldi r24,lo8(myLCD)
 721 022c 90E0      		ldi r25,hi8(myLCD)
 722 022e 0E94 0000 		call _ZN3LCDC1Eb
 723               	.LVL38:
  37:main.cpp      **** SM mySM(&uart, &myScale,&myLCD);
 724               		.loc 1 37 0
 725 0232 60E0      		ldi r22,lo8(uart)
 726 0234 70E0      		ldi r23,hi8(uart)
 727 0236 80E0      		ldi r24,lo8(myScale)
 728 0238 90E0      		ldi r25,hi8(myScale)
 729 023a 0E94 0000 		call _ZN5ScaleC1EP4UART
 730               	.LVL39:
  38:main.cpp      **** 
 731               		.loc 1 38 0
 732 023e 20E0      		ldi r18,lo8(myLCD)
 733 0240 30E0      		ldi r19,hi8(myLCD)
 734 0242 40E0      		ldi r20,lo8(myScale)
 735 0244 50E0      		ldi r21,hi8(myScale)
 736 0246 60E0      		ldi r22,lo8(uart)
 737 0248 70E0      		ldi r23,hi8(uart)
 738 024a 80E0      		ldi r24,lo8(mySM)
 739 024c 90E0      		ldi r25,hi8(mySM)
 740 024e 0C94 0000 		jmp _ZN2SMC1EP4UARTP5ScaleP3LCD
 741               	.LVL40:
 742               	.LBE35:
 743               	.LBE34:
 744               		.cfi_endproc
 745               	.LFE14:
 747               		.global __do_global_ctors
 748               		.section .ctors,"a",@progbits
 749               		.p2align	1
 750 0000 0000      		.word	gs(_GLOBAL__sub_I_uart)
 751               		.section	.text.exit,"ax",@progbits
 753               	_GLOBAL__sub_D_uart:
 754               	.LFB15:
 755               		.loc 1 168 0
 756               		.cfi_startproc
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 0 */
 760               	.L__stack_usage = 0
 761               	.LVL41:
 762               	.LBB40:
 763               	.LBB41:
 764               	.LBB42:
  38:main.cpp      **** 
 765               		.loc 1 38 0
 766 0000 80E0      		ldi r24,lo8(mySM)
 767 0002 90E0      		ldi r25,hi8(mySM)
 768 0004 0E94 0000 		call _ZN2SMD1Ev
 769               	.LVL42:
  37:main.cpp      **** SM mySM(&uart, &myScale,&myLCD);
 770               		.loc 1 37 0
 771 0008 80E0      		ldi r24,lo8(myScale)
 772 000a 90E0      		ldi r25,hi8(myScale)
 773 000c 0E94 0000 		call _ZN5ScaleD1Ev
 774               	.LVL43:
  36:main.cpp      **** Scale myScale=Scale(&uart);
 775               		.loc 1 36 0
 776 0010 80E0      		ldi r24,lo8(myLCD)
 777 0012 90E0      		ldi r25,hi8(myLCD)
 778 0014 0E94 0000 		call _ZN3LCDD1Ev
 779               	.LVL44:
  35:main.cpp      **** LCD myLCD=LCD(0);//Use 1 for lowest power LCD mode
 780               		.loc 1 35 0
 781 0018 80E0      		ldi r24,lo8(uart)
 782 001a 90E0      		ldi r25,hi8(uart)
 783 001c 0C94 0000 		jmp _ZN4UARTD1Ev
 784               	.LVL45:
 785               	.LBE42:
 786               	.LBE41:
 787               	.LBE40:
 788               		.cfi_endproc
 789               	.LFE15:
 791               		.global __do_global_dtors
 792               		.section .dtors,"a",@progbits
 793               		.p2align	1
 794 0000 0000      		.word	gs(_GLOBAL__sub_D_uart)
 795               	.global	btn_state
 796               		.section .bss
 799               	btn_state:
 800 0000 00        		.zero	1
 801               	.global	loop_cnt
 804               	loop_cnt:
 805 0001 00        		.zero	1
 806               	.global	mySM
 809               	mySM:
 810 0002 0000 0000 		.zero	9
 810      0000 0000 
 810      00
 811               	.global	myScale
 814               	myScale:
 815 000b 0000 0000 		.zero	19
 815      0000 0000 
 815      0000 0000 
 815      0000 0000 
 815      0000 00
 816               	.global	myLCD
 819               	myLCD:
 820 001e 00        		.zero	1
 821               	.global	uart
 824               	uart:
 825 001f 0000 0000 		.zero	22
 825      0000 0000 
 825      0000 0000 
 825      0000 0000 
 825      0000 0000 
 826               		.text
 827               	.Letext0:
 828               		.file 3 "/usr/lib/avr/include/stdint.h"
 829               		.file 4 "UART.h"
 830               		.file 5 "ADC.h"
 831               		.file 6 "scale.h"
 832               		.file 7 "LCD.h"
 833               		.file 8 "state_machine.h"
 834               		.file 9 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.cpp
     /tmp/cc39Qoqt.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc39Qoqt.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc39Qoqt.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc39Qoqt.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc39Qoqt.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc39Qoqt.s:30     .text.startup:0000000000000000 main
     /tmp/cc39Qoqt.s:804    .bss:0000000000000001 loop_cnt
     /tmp/cc39Qoqt.s:809    .bss:0000000000000002 mySM
     /tmp/cc39Qoqt.s:799    .bss:0000000000000000 btn_state
     /tmp/cc39Qoqt.s:824    .bss:000000000000001f uart
     /tmp/cc39Qoqt.s:407    .text:0000000000000000 __vector_19
     /tmp/cc39Qoqt.s:606    .text:00000000000000da __vector_13
     /tmp/cc39Qoqt.s:702    .text.startup:0000000000000220 _GLOBAL__sub_I_uart
     /tmp/cc39Qoqt.s:819    .bss:000000000000001e myLCD
     /tmp/cc39Qoqt.s:814    .bss:000000000000000b myScale
     /tmp/cc39Qoqt.s:753    .text.exit:0000000000000000 _GLOBAL__sub_D_uart

UNDEFINED SYMBOLS
_ZN2SM6updateEv
_ZN4UART15isDataAvailableEv
_ZN4UART8retrieveEv
_ZN2SM6streamEbb
_ZN4UART10sendStringEPcb
_ZN4UART10sendStringEPc
strtol
_ZN4UART6sendNbEl
__divmodsi4
__floatunsisf
__divsf3
__fixunssfsi
_ZN3LCD5setNbElh
_ZN3LCD10setBatteryENS_7BatteryE
_ZN4UART7receiveEv
_ZN4UARTC1Ev
_ZN3LCDC1Eb
_ZN5ScaleC1EP4UART
_ZN2SMC1EP4UARTP5ScaleP3LCD
__do_global_ctors
_ZN2SMD1Ev
_ZN5ScaleD1Ev
_ZN3LCDD1Ev
_ZN4UARTD1Ev
__do_global_dtors
__do_copy_data
__do_clear_bss
