   1               		.file	"main.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB10:
  15               		.file 1 "main.cpp"
   1:main.cpp      **** #include <avr/io.h>
   2:main.cpp      **** #include <avr/interrupt.h>
   3:main.cpp      **** #include <avr/sleep.h>
   4:main.cpp      **** #include <util/delay.h>
   5:main.cpp      **** #include <stdlib.h> //for itoa
   6:main.cpp      **** 
   7:main.cpp      **** #include "LCD.h"
   8:main.cpp      **** #include "UART.h"
   9:main.cpp      **** #include "ADC.h"
  10:main.cpp      **** #include "state_machine.h"
  11:main.cpp      **** 
  12:main.cpp      **** UART uart;
  13:main.cpp      **** MCP3462 myADC;
  14:main.cpp      **** SM mySM;
  15:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
  16:main.cpp      **** 
  17:main.cpp      **** //Fuses -U lfuse:w:0xe2:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m 
  18:main.cpp      **** //Int RC osc, 6CK+65ms startup time
  19:main.cpp      **** //No Clock div by 8
  20:main.cpp      **** //Brown out detection enabled, 1.8V
  21:main.cpp      **** //For BoD at 2.7V, use Efuse=FB instead of FD
  22:main.cpp      **** 
  23:main.cpp      **** #define LED0_ON (PORTD|=(1<<6))
  24:main.cpp      **** #define LED0_OFF (PORTD&=~(1<<6))
  25:main.cpp      **** #define LED0_Toggle (PORTD^=(1<<6))
  26:main.cpp      **** 
  27:main.cpp      **** #define LED1_ON (PORTD|=(1<<7))
  28:main.cpp      **** #define LED1_OFF (PORTD&=~(1<<7))
  29:main.cpp      **** #define LED1_Toggle (PORTD^=(1<<7))
  30:main.cpp      **** 
  31:main.cpp      **** #define BTN0 (PIND&(1<<4))
  32:main.cpp      **** #define BTN1 (PIND&(1<<5))
  33:main.cpp      **** 
  34:main.cpp      **** #define IRQ_STATE (PINE&(1<<7))
  35:main.cpp      **** 
  36:main.cpp      **** #define PWR_en_ON (PORTE|=(1<<5))
  37:main.cpp      **** #define PWR_en_OFF (PORTE&=~(1<<6))
  38:main.cpp      **** #define LoadCell_en_ON (PORTE|=(1<<7))
  39:main.cpp      **** #define LoadCell_en_OFF (PORTE&=~(1<<7))
  40:main.cpp      **** 
  41:main.cpp      **** #define BATT_CUTOUT 3200
  42:main.cpp      **** #define BATT_EMPTY 3500
  43:main.cpp      **** #define BATT_ONEBAR 3600
  44:main.cpp      **** #define BATT_TWOBAR 3750
  45:main.cpp      **** #define BATT_FULL 3900
  46:main.cpp      **** 
  47:main.cpp      **** 
  48:main.cpp      **** 
  49:main.cpp      **** volatile uint32_t cnt=59650;
  50:main.cpp      **** volatile uint8_t state=1;
  51:main.cpp      **** 
  52:main.cpp      **** int main(void){
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  53:main.cpp      **** 	
  54:main.cpp      **** 	DDRD=0b11000000; 	//LED0, LED1 as outputs, BTN 0/1 as inputs
  42               		.loc 1 54 0
  43 0014 80EC      		ldi r24,lo8(-64)
  44 0016 8AB9      		out 0xa,r24
  55:main.cpp      **** 	PORTD=0b00110000;			//LED initial state:low, enable BTN pullups
  45               		.loc 1 55 0
  46 0018 80E3      		ldi r24,lo8(48)
  47 001a 8BB9      		out 0xb,r24
  56:main.cpp      **** 	
  57:main.cpp      **** 	DDRE=0b01100011;//IRQ as input, LoadCell_en/PWR_en as outputs, TX as output, RX as input
  48               		.loc 1 57 0
  49 001c 83E6      		ldi r24,lo8(99)
  50 001e 8DB9      		out 0xd,r24
  58:main.cpp      **** 	PORTE=0b11100000;//Enable IRQ pullup, set LoadCell_en/PWR_en to 1
  51               		.loc 1 58 0
  52 0020 80EE      		ldi r24,lo8(-32)
  53 0022 8EB9      		out 0xe,r24
  59:main.cpp      **** 	
  60:main.cpp      **** 	
  61:main.cpp      **** 	LED0_ON;
  54               		.loc 1 61 0
  55 0024 5E9A      		sbi 0xb,6
  62:main.cpp      **** 	PRR|=(1<<PRTIM1);//Shut down clock to Timer1
  56               		.loc 1 62 0
  57 0026 8091 6400 		lds r24,100
  58 002a 8860      		ori r24,lo8(8)
  59 002c 8093 6400 		sts 100,r24
  63:main.cpp      **** 	
  64:main.cpp      **** 	ADMUX|=(1<<REFS0)|0b11110;//Set AVCC as reference voltage for ADC, ADC MUX input to 1.1V BG
  60               		.loc 1 64 0
  61 0030 8091 7C00 		lds r24,124
  62 0034 8E65      		ori r24,lo8(94)
  63 0036 8093 7C00 		sts 124,r24
  65:main.cpp      **** 	ADCSRA|=(1<<ADEN)|(1<<ADIE)|(1<<ADPS1);//Enable conversin complete interrupt, Clock prescaler 12MH
  64               		.loc 1 65 0
  65 003a 8091 7A00 		lds r24,122
  66 003e 8A68      		ori r24,lo8(-118)
  67 0040 8093 7A00 		sts 122,r24
  66:main.cpp      **** 	sei();
  68               		.loc 1 66 0
  69               	/* #APP */
  70               	 ;  66 "main.cpp" 1
  71 0044 7894      		sei
  72               	 ;  0 "" 2
  73               	/* #NOAPP */
  74               	.LBB17:
  75               	.LBB18:
  76               	.LBB19:
  77               	.LBB20:
  78               	.LBB21:
  67:main.cpp      **** 	
  68:main.cpp      **** 	
  69:main.cpp      **** 	while(1){
  70:main.cpp      **** 	
  71:main.cpp      **** 		_delay_ms(100);
  72:main.cpp      **** 		switch(state){
  73:main.cpp      **** 			case 0:
  74:main.cpp      **** 				ADCSRA&=~(1<<ADEN);//Disable ADC
  75:main.cpp      **** 				PRR|=(1<<PRTIM1)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRADC);//Shut down clock to Timer1, SPI, UART, AD
  76:main.cpp      **** 				
  77:main.cpp      **** 				set_sleep_mode(SLEEP_MODE_PWR_SAVE);
  78:main.cpp      **** 				//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  79:main.cpp      **** 				cli();
  80:main.cpp      **** 				if (1){
  81:main.cpp      **** 					sleep_enable();
  82:main.cpp      **** 					sei();
  83:main.cpp      **** 					sleep_cpu();
  84:main.cpp      **** 					sleep_disable();
  85:main.cpp      **** 				}
  86:main.cpp      **** 				PRR&=~(1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0);//Enable power to ADC, UART and SPI  again
  87:main.cpp      **** 				ADCSRA|=(1<<ADEN);//Enable ADC again
  88:main.cpp      **** 				sei();
  89:main.cpp      **** 				state=1;
  90:main.cpp      **** 				break;
  91:main.cpp      **** 				
  92:main.cpp      **** 			case 1:
  93:main.cpp      **** 				ADCSRA|=(1<<ADSC); //Start single ADC conversion
  94:main.cpp      **** 				if(myADC.isDataReady()){
  95:main.cpp      **** 					uint32_t d=myADC.getDirectData();
  96:main.cpp      **** 					d=12345;
  97:main.cpp      **** 					char buffer [11];//32 bits in decimal is 4milions, 10 digits
  98:main.cpp      **** 					ultoa(d,buffer,10);
  99:main.cpp      **** 					uart.sendString(buffer);
 100:main.cpp      **** 					LED0_Toggle;
  79               		.loc 1 100 0
  80 0046 10E4      		ldi r17,lo8(64)
  81               	.LBE21:
  82               	.LBE20:
  89:main.cpp      **** 				break;
  83               		.loc 1 89 0
  84 0048 01E0      		ldi r16,lo8(1)
  85               	.L11:
  86               	.LVL0:
  87               	.LBE19:
  88               	.LBE18:
  89               	.LBB27:
  90               	.LBB28:
  91               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  92               		.loc 2 187 0
  93 004a 2FEF      		ldi r18,lo8(159999)
  94 004c 80E7      		ldi r24,hi8(159999)
  95 004e 92E0      		ldi r25,hlo8(159999)
  96 0050 2150      	1:	subi r18,1
  97 0052 8040      		sbci r24,0
  98 0054 9040      		sbci r25,0
  99 0056 01F4      		brne 1b
 100 0058 00C0      		rjmp .
 101 005a 0000      		nop
 102               	.LVL1:
 103               	.LBE28:
 104               	.LBE27:
 105               	.LBB29:
  72:main.cpp      **** 			case 0:
 106               		.loc 1 72 0
 107 005c 8091 0000 		lds r24,state
 108 0060 8823      		tst r24
 109 0062 01F0      		breq .L4
 110 0064 8130      		cpi r24,lo8(1)
 111 0066 01F0      		breq .L5
 112 0068 00C0      		rjmp .L3
 113               	.L4:
 114               	.LBB26:
  74:main.cpp      **** 				PRR|=(1<<PRTIM1)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRADC);//Shut down clock to Timer1, SPI, UART, AD
 115               		.loc 1 74 0
 116 006a 8091 7A00 		lds r24,122
 117 006e 8F77      		andi r24,lo8(127)
 118 0070 8093 7A00 		sts 122,r24
  75:main.cpp      **** 				
 119               		.loc 1 75 0
 120 0074 8091 6400 		lds r24,100
 121 0078 8F60      		ori r24,lo8(15)
 122 007a 8093 6400 		sts 100,r24
  77:main.cpp      **** 				//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 123               		.loc 1 77 0
 124 007e 83B7      		in r24,0x33
 125 0080 817F      		andi r24,lo8(-15)
 126 0082 8660      		ori r24,lo8(6)
 127 0084 83BF      		out 0x33,r24
  79:main.cpp      **** 				if (1){
 128               		.loc 1 79 0
 129               	/* #APP */
 130               	 ;  79 "main.cpp" 1
 131 0086 F894      		cli
 132               	 ;  0 "" 2
  81:main.cpp      **** 					sei();
 133               		.loc 1 81 0
 134               	/* #NOAPP */
 135 0088 83B7      		in r24,0x33
 136 008a 8160      		ori r24,lo8(1)
 137 008c 83BF      		out 0x33,r24
  82:main.cpp      **** 					sleep_cpu();
 138               		.loc 1 82 0
 139               	/* #APP */
 140               	 ;  82 "main.cpp" 1
 141 008e 7894      		sei
 142               	 ;  0 "" 2
  83:main.cpp      **** 					sleep_disable();
 143               		.loc 1 83 0
 144               	 ;  83 "main.cpp" 1
 145 0090 8895      		sleep
 146               		
 147               	 ;  0 "" 2
  84:main.cpp      **** 				}
 148               		.loc 1 84 0
 149               	/* #NOAPP */
 150 0092 83B7      		in r24,0x33
 151 0094 8E7F      		andi r24,lo8(-2)
 152 0096 83BF      		out 0x33,r24
  86:main.cpp      **** 				ADCSRA|=(1<<ADEN);//Enable ADC again
 153               		.loc 1 86 0
 154 0098 8091 6400 		lds r24,100
 155 009c 8E7F      		andi r24,lo8(-2)
 156 009e 8093 6400 		sts 100,r24
  87:main.cpp      **** 				sei();
 157               		.loc 1 87 0
 158 00a2 8091 7A00 		lds r24,122
 159 00a6 8068      		ori r24,lo8(-128)
 160 00a8 8093 7A00 		sts 122,r24
  88:main.cpp      **** 				state=1;
 161               		.loc 1 88 0
 162               	/* #APP */
 163               	 ;  88 "main.cpp" 1
 164 00ac 7894      		sei
 165               	 ;  0 "" 2
  89:main.cpp      **** 				break;
 166               		.loc 1 89 0
 167               	/* #NOAPP */
 168 00ae 0093 0000 		sts state,r16
  90:main.cpp      **** 				
 169               		.loc 1 90 0
 170 00b2 00C0      		rjmp .L3
 171               	.L5:
  93:main.cpp      **** 				if(myADC.isDataReady()){
 172               		.loc 1 93 0
 173 00b4 8091 7A00 		lds r24,122
 174 00b8 8064      		ori r24,lo8(64)
 175 00ba 8093 7A00 		sts 122,r24
 176               	.LBB25:
  94:main.cpp      **** 					uint32_t d=myADC.getDirectData();
 177               		.loc 1 94 0
 178 00be 80E0      		ldi r24,lo8(myADC)
 179 00c0 90E0      		ldi r25,hi8(myADC)
 180 00c2 0E94 0000 		call _ZN7MCP346211isDataReadyEv
 181               	.LVL2:
 182 00c6 8823      		tst r24
 183 00c8 01F0      		breq .L3
 184               	.LBB24:
  95:main.cpp      **** 					d=12345;
 185               		.loc 1 95 0
 186 00ca 80E0      		ldi r24,lo8(myADC)
 187 00cc 90E0      		ldi r25,hi8(myADC)
 188 00ce 0E94 0000 		call _ZN7MCP346213getDirectDataEv
 189               	.LVL3:
 190               	.LBB22:
 191               	.LBB23:
 192               		.file 3 "/usr/lib/avr/include/stdlib.h"
   1:/usr/lib/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/lib/avr/include/stdlib.h **** 
   4:/usr/lib/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/lib/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/lib/avr/include/stdlib.h **** 
   7:/usr/lib/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/lib/avr/include/stdlib.h **** 
   9:/usr/lib/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/lib/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/lib/avr/include/stdlib.h **** 
  12:/usr/lib/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/lib/avr/include/stdlib.h **** 
  15:/usr/lib/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/lib/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/lib/avr/include/stdlib.h ****      distribution.
  19:/usr/lib/avr/include/stdlib.h **** 
  20:/usr/lib/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/lib/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/lib/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/lib/avr/include/stdlib.h **** 
  24:/usr/lib/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/lib/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/lib/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/lib/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/lib/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/lib/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/lib/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/lib/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/lib/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/lib/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/lib/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/lib/avr/include/stdlib.h **** 
  36:/usr/lib/avr/include/stdlib.h ****   $Id$
  37:/usr/lib/avr/include/stdlib.h **** */
  38:/usr/lib/avr/include/stdlib.h **** 
  39:/usr/lib/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/lib/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/lib/avr/include/stdlib.h **** 
  42:/usr/lib/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/lib/avr/include/stdlib.h **** 
  44:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/lib/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/lib/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/lib/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/lib/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/lib/avr/include/stdlib.h **** 
  50:/usr/lib/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/lib/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/lib/avr/include/stdlib.h **** #endif
  53:/usr/lib/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/lib/avr/include/stdlib.h **** 
  55:/usr/lib/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/lib/avr/include/stdlib.h **** extern "C" {
  57:/usr/lib/avr/include/stdlib.h **** #endif
  58:/usr/lib/avr/include/stdlib.h **** 
  59:/usr/lib/avr/include/stdlib.h **** /** \file */
  60:/usr/lib/avr/include/stdlib.h **** 
  61:/usr/lib/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/lib/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/lib/avr/include/stdlib.h **** 
  64:/usr/lib/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/lib/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/lib/avr/include/stdlib.h **** */
  67:/usr/lib/avr/include/stdlib.h **** 
  68:/usr/lib/avr/include/stdlib.h **** /*@{*/
  69:/usr/lib/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/lib/avr/include/stdlib.h **** typedef struct {
  71:/usr/lib/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/lib/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/lib/avr/include/stdlib.h **** } div_t;
  74:/usr/lib/avr/include/stdlib.h **** 
  75:/usr/lib/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/lib/avr/include/stdlib.h **** typedef struct {
  77:/usr/lib/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/lib/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/lib/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/lib/avr/include/stdlib.h **** 
  81:/usr/lib/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/lib/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/lib/avr/include/stdlib.h **** 
  84:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/lib/avr/include/stdlib.h **** 
  86:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/lib/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/lib/avr/include/stdlib.h **** #endif
  89:/usr/lib/avr/include/stdlib.h **** 
  90:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/lib/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/lib/avr/include/stdlib.h **** #endif
  93:/usr/lib/avr/include/stdlib.h **** 
  94:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/lib/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/lib/avr/include/stdlib.h **** #endif
  97:/usr/lib/avr/include/stdlib.h **** 
  98:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/lib/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/lib/avr/include/stdlib.h **** #endif
 101:/usr/lib/avr/include/stdlib.h **** 
 102:/usr/lib/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/lib/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/lib/avr/include/stdlib.h **** # else
 106:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/lib/avr/include/stdlib.h **** # endif
 108:/usr/lib/avr/include/stdlib.h **** #endif
 109:/usr/lib/avr/include/stdlib.h **** 
 110:/usr/lib/avr/include/stdlib.h **** #endif
 111:/usr/lib/avr/include/stdlib.h **** 
 112:/usr/lib/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/lib/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/lib/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/lib/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/lib/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/lib/avr/include/stdlib.h **** 
 118:/usr/lib/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/lib/avr/include/stdlib.h **** */
 121:/usr/lib/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/lib/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/lib/avr/include/stdlib.h **** #endif
 125:/usr/lib/avr/include/stdlib.h **** 
 126:/usr/lib/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/lib/avr/include/stdlib.h ****     \c i.
 128:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/lib/avr/include/stdlib.h **** */
 130:/usr/lib/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/lib/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/lib/avr/include/stdlib.h **** #endif
 134:/usr/lib/avr/include/stdlib.h **** 
 135:/usr/lib/avr/include/stdlib.h **** /**
 136:/usr/lib/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/lib/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/lib/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/lib/avr/include/stdlib.h **** 
 141:/usr/lib/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/lib/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/lib/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/lib/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/lib/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/lib/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/lib/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/lib/avr/include/stdlib.h **** 
 149:/usr/lib/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/lib/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/lib/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/lib/avr/include/stdlib.h **** */
 153:/usr/lib/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/lib/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/lib/avr/include/stdlib.h **** 
 156:/usr/lib/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/lib/avr/include/stdlib.h **** /**
 158:/usr/lib/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/lib/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/lib/avr/include/stdlib.h **** */
 162:/usr/lib/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/lib/avr/include/stdlib.h **** /**
 164:/usr/lib/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/lib/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/lib/avr/include/stdlib.h **** */
 168:/usr/lib/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/lib/avr/include/stdlib.h **** 
 170:/usr/lib/avr/include/stdlib.h **** /**
 171:/usr/lib/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/lib/avr/include/stdlib.h ****      quicksort.
 173:/usr/lib/avr/include/stdlib.h **** 
 174:/usr/lib/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/lib/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/lib/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/lib/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/lib/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/lib/avr/include/stdlib.h **** 
 181:/usr/lib/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/lib/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/lib/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/lib/avr/include/stdlib.h **** */
 185:/usr/lib/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/lib/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/lib/avr/include/stdlib.h **** 
 188:/usr/lib/avr/include/stdlib.h **** /**
 189:/usr/lib/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/lib/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/lib/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/lib/avr/include/stdlib.h **** 
 193:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/lib/avr/include/stdlib.h **** 
 200:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/lib/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/lib/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/lib/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/lib/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/lib/avr/include/stdlib.h **** 
 206:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/lib/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/lib/avr/include/stdlib.h **** 
 212:/usr/lib/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/lib/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/lib/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/lib/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/lib/avr/include/stdlib.h **** */
 218:/usr/lib/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/lib/avr/include/stdlib.h **** 
 220:/usr/lib/avr/include/stdlib.h **** /**
 221:/usr/lib/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/lib/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/lib/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/lib/avr/include/stdlib.h ****     special value 0.
 225:/usr/lib/avr/include/stdlib.h **** 
 226:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/lib/avr/include/stdlib.h **** 
 233:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/lib/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/lib/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/lib/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/lib/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/lib/avr/include/stdlib.h **** 
 239:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/lib/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/lib/avr/include/stdlib.h **** 
 245:/usr/lib/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/lib/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/lib/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/lib/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/lib/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/lib/avr/include/stdlib.h **** */
 252:/usr/lib/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/lib/avr/include/stdlib.h **** 
 254:/usr/lib/avr/include/stdlib.h **** /**
 255:/usr/lib/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/lib/avr/include/stdlib.h **** 
 258:/usr/lib/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/lib/avr/include/stdlib.h **** 
 260:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/lib/avr/include/stdlib.h **** */
 264:/usr/lib/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/lib/avr/include/stdlib.h **** 
 266:/usr/lib/avr/include/stdlib.h **** /**
 267:/usr/lib/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/lib/avr/include/stdlib.h **** 
 270:/usr/lib/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/lib/avr/include/stdlib.h **** 
 272:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/lib/avr/include/stdlib.h **** */
 276:/usr/lib/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/lib/avr/include/stdlib.h **** 
 278:/usr/lib/avr/include/stdlib.h **** /**
 279:/usr/lib/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/lib/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/lib/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/lib/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/lib/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/lib/avr/include/stdlib.h **** 
 285:/usr/lib/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/lib/avr/include/stdlib.h ****    execution.
 287:/usr/lib/avr/include/stdlib.h **** */
 288:/usr/lib/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/lib/avr/include/stdlib.h **** 
 290:/usr/lib/avr/include/stdlib.h **** /**
 291:/usr/lib/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/lib/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/lib/avr/include/stdlib.h **** 
 294:/usr/lib/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/lib/avr/include/stdlib.h ****    zero bytes.
 296:/usr/lib/avr/include/stdlib.h **** 
 297:/usr/lib/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/lib/avr/include/stdlib.h ****    details.
 299:/usr/lib/avr/include/stdlib.h **** */
 300:/usr/lib/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/lib/avr/include/stdlib.h **** 
 302:/usr/lib/avr/include/stdlib.h **** /**
 303:/usr/lib/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/lib/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/lib/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/lib/avr/include/stdlib.h **** */
 307:/usr/lib/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/lib/avr/include/stdlib.h **** 
 309:/usr/lib/avr/include/stdlib.h **** /**
 310:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/lib/avr/include/stdlib.h **** */
 312:/usr/lib/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/lib/avr/include/stdlib.h **** 
 314:/usr/lib/avr/include/stdlib.h **** /**
 315:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/lib/avr/include/stdlib.h **** */
 317:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/lib/avr/include/stdlib.h **** 
 319:/usr/lib/avr/include/stdlib.h **** /**
 320:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/lib/avr/include/stdlib.h **** */
 322:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/lib/avr/include/stdlib.h **** 
 324:/usr/lib/avr/include/stdlib.h **** /**
 325:/usr/lib/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/lib/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/lib/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/lib/avr/include/stdlib.h **** */
 329:/usr/lib/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/lib/avr/include/stdlib.h **** 
 331:/usr/lib/avr/include/stdlib.h **** /**
 332:/usr/lib/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/lib/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/lib/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/lib/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/lib/avr/include/stdlib.h ****    region.
 337:/usr/lib/avr/include/stdlib.h **** 
 338:/usr/lib/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/lib/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/lib/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/lib/avr/include/stdlib.h **** 
 342:/usr/lib/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/lib/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/lib/avr/include/stdlib.h **** 
 345:/usr/lib/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/lib/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/lib/avr/include/stdlib.h **** */
 348:/usr/lib/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/lib/avr/include/stdlib.h **** 
 350:/usr/lib/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/lib/avr/include/stdlib.h **** 
 352:/usr/lib/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/lib/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/lib/avr/include/stdlib.h **** 
 355:/usr/lib/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/lib/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/lib/avr/include/stdlib.h **** 
 358:/usr/lib/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/lib/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/lib/avr/include/stdlib.h ****  */
 361:/usr/lib/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/lib/avr/include/stdlib.h **** 
 363:/usr/lib/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/lib/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/lib/avr/include/stdlib.h **** 
 366:/usr/lib/avr/include/stdlib.h **** /**
 367:/usr/lib/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/lib/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/lib/avr/include/stdlib.h **** 
 370:/usr/lib/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/lib/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/lib/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/lib/avr/include/stdlib.h **** 
 374:/usr/lib/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/lib/avr/include/stdlib.h ****      a value of 1.
 376:/usr/lib/avr/include/stdlib.h **** 
 377:/usr/lib/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/lib/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/lib/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/lib/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/lib/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/lib/avr/include/stdlib.h **** */
 383:/usr/lib/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/lib/avr/include/stdlib.h **** /**
 385:/usr/lib/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/lib/avr/include/stdlib.h **** */
 387:/usr/lib/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/lib/avr/include/stdlib.h **** 
 389:/usr/lib/avr/include/stdlib.h **** /**
 390:/usr/lib/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/lib/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/lib/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/lib/avr/include/stdlib.h **** */
 394:/usr/lib/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/lib/avr/include/stdlib.h **** /*@}*/
 396:/usr/lib/avr/include/stdlib.h **** 
 397:/usr/lib/avr/include/stdlib.h **** /*@{*/
 398:/usr/lib/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/lib/avr/include/stdlib.h **** */
 401:/usr/lib/avr/include/stdlib.h **** /**
 402:/usr/lib/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/lib/avr/include/stdlib.h **** 
 404:/usr/lib/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/lib/avr/include/stdlib.h **** 
 408:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/lib/avr/include/stdlib.h **** 
 414:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/lib/avr/include/stdlib.h **** 
 416:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/lib/avr/include/stdlib.h ****     
 421:/usr/lib/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/lib/avr/include/stdlib.h **** 
 423:/usr/lib/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/lib/avr/include/stdlib.h **** */
 425:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/lib/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/lib/avr/include/stdlib.h **** #else
 428:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/lib/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/lib/avr/include/stdlib.h **** {
 431:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/lib/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/lib/avr/include/stdlib.h **** 	return __s;
 437:/usr/lib/avr/include/stdlib.h ****     } else {
 438:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/lib/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/lib/avr/include/stdlib.h ****     }
 441:/usr/lib/avr/include/stdlib.h **** }
 442:/usr/lib/avr/include/stdlib.h **** #endif
 443:/usr/lib/avr/include/stdlib.h **** 
 444:/usr/lib/avr/include/stdlib.h **** /**
 445:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/lib/avr/include/stdlib.h ****  
 447:/usr/lib/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/lib/avr/include/stdlib.h **** 
 449:/usr/lib/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/lib/avr/include/stdlib.h **** 
 453:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/lib/avr/include/stdlib.h **** 
 459:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/lib/avr/include/stdlib.h **** 
 461:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/lib/avr/include/stdlib.h **** 
 466:/usr/lib/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/lib/avr/include/stdlib.h **** 
 468:/usr/lib/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/lib/avr/include/stdlib.h **** */
 470:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/lib/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/lib/avr/include/stdlib.h **** #else
 473:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/lib/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/lib/avr/include/stdlib.h **** {
 476:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/lib/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/lib/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/lib/avr/include/stdlib.h **** 	return __s;
 482:/usr/lib/avr/include/stdlib.h ****     } else {
 483:/usr/lib/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/lib/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/lib/avr/include/stdlib.h ****     }
 486:/usr/lib/avr/include/stdlib.h **** }
 487:/usr/lib/avr/include/stdlib.h **** #endif
 488:/usr/lib/avr/include/stdlib.h **** 
 489:/usr/lib/avr/include/stdlib.h **** /**
 490:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/lib/avr/include/stdlib.h **** 
 492:/usr/lib/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/lib/avr/include/stdlib.h **** 
 494:/usr/lib/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/lib/avr/include/stdlib.h **** 
 498:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/lib/avr/include/stdlib.h **** 
 504:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/lib/avr/include/stdlib.h **** 
 506:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/lib/avr/include/stdlib.h **** 
 511:/usr/lib/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/lib/avr/include/stdlib.h **** */
 513:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/lib/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/lib/avr/include/stdlib.h **** #else
 516:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/lib/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/lib/avr/include/stdlib.h **** {
 519:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/lib/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/lib/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/lib/avr/include/stdlib.h **** 	return __s;
 525:/usr/lib/avr/include/stdlib.h ****     } else {
 526:/usr/lib/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/lib/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 528:/usr/lib/avr/include/stdlib.h ****     }
 529:/usr/lib/avr/include/stdlib.h **** }
 530:/usr/lib/avr/include/stdlib.h **** #endif
 531:/usr/lib/avr/include/stdlib.h **** 
 532:/usr/lib/avr/include/stdlib.h **** /**
 533:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 534:/usr/lib/avr/include/stdlib.h ****    \brief Convert an unsigned long integer to a string.
 535:/usr/lib/avr/include/stdlib.h **** 
 536:/usr/lib/avr/include/stdlib.h ****    The function ultoa() converts the unsigned long integer value from
 537:/usr/lib/avr/include/stdlib.h ****    \c val into an ASCII representation that will be stored under \c s.
 538:/usr/lib/avr/include/stdlib.h ****    The caller is responsible for providing sufficient storage in \c s.
 539:/usr/lib/avr/include/stdlib.h **** 
 540:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 541:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 542:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned long int) + 1 characters,
 543:/usr/lib/avr/include/stdlib.h ****    i.e. one character for each bit plus one for the string terminator. Using a
 544:/usr/lib/avr/include/stdlib.h ****    larger radix will require a smaller minimal buffer size.
 545:/usr/lib/avr/include/stdlib.h **** 
 546:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 547:/usr/lib/avr/include/stdlib.h **** 
 548:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 549:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 550:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 551:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 552:/usr/lib/avr/include/stdlib.h **** 
 553:/usr/lib/avr/include/stdlib.h ****    The ultoa() function returns the pointer passed as \c s.
 554:/usr/lib/avr/include/stdlib.h **** */
 555:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 556:/usr/lib/avr/include/stdlib.h **** extern char *ultoa(unsigned long val, char *s, int radix);
 557:/usr/lib/avr/include/stdlib.h **** #else
 558:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 559:/usr/lib/avr/include/stdlib.h **** char *ultoa (unsigned long __val, char *__s, int __radix)
 560:/usr/lib/avr/include/stdlib.h **** {
 561:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 562:/usr/lib/avr/include/stdlib.h **** 	extern char *__ultoa (unsigned long, char *, int);
 563:/usr/lib/avr/include/stdlib.h **** 	return __ultoa (__val, __s, __radix);
 564:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 565:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 566:/usr/lib/avr/include/stdlib.h **** 	return __s;
 567:/usr/lib/avr/include/stdlib.h ****     } else {
 568:/usr/lib/avr/include/stdlib.h **** 	extern char *__ultoa_ncheck (unsigned long, char *, unsigned char);
 569:/usr/lib/avr/include/stdlib.h **** 	return __ultoa_ncheck (__val, __s, __radix);
 193               		.loc 3 569 0
 194 00d2 2AE0      		ldi r18,lo8(10)
 195 00d4 AE01      		movw r20,r28
 196 00d6 4F5F      		subi r20,-1
 197 00d8 5F4F      		sbci r21,-1
 198 00da 69E3      		ldi r22,lo8(57)
 199 00dc 70E3      		ldi r23,lo8(48)
 200 00de 80E0      		ldi r24,0
 201 00e0 90E0      		ldi r25,0
 202 00e2 0E94 0000 		call __ultoa_ncheck
 203               	.LVL4:
 204               	.LBE23:
 205               	.LBE22:
  99:main.cpp      **** 					LED0_Toggle;
 206               		.loc 1 99 0
 207 00e6 BE01      		movw r22,r28
 208 00e8 6F5F      		subi r22,-1
 209 00ea 7F4F      		sbci r23,-1
 210 00ec 80E0      		ldi r24,lo8(uart)
 211 00ee 90E0      		ldi r25,hi8(uart)
 212 00f0 0E94 0000 		call _ZN4UART10sendStringEPc
 213               	.LVL5:
 214               		.loc 1 100 0
 215 00f4 8BB1      		in r24,0xb
 216 00f6 8127      		eor r24,r17
 217 00f8 8BB9      		out 0xb,r24
 218               	.LVL6:
 219               	.L3:
 220               	.LBE24:
 221               	.LBE25:
 222               	.LBE26:
 223               	.LBE29:
 101:main.cpp      **** 				}
 102:main.cpp      **** 		}
 103:main.cpp      **** 		
 104:main.cpp      **** 		if(cnt>=BATT_FULL){
 224               		.loc 1 104 0
 225 00fa 8091 0000 		lds r24,cnt
 226 00fe 9091 0000 		lds r25,cnt+1
 227 0102 A091 0000 		lds r26,cnt+2
 228 0106 B091 0000 		lds r27,cnt+3
 229 010a 8C33      		cpi r24,60
 230 010c 9F40      		sbci r25,15
 231 010e A105      		cpc r26,__zero_reg__
 232 0110 B105      		cpc r27,__zero_reg__
 233 0112 00F0      		brlo .L6
 105:main.cpp      **** 			myLCD.setBattery(LCD::FULL);
 234               		.loc 1 105 0
 235 0114 87E0      		ldi r24,lo8(7)
 236 0116 00C0      		rjmp .L18
 237               	.L6:
 106:main.cpp      **** 		}else if(cnt>=BATT_TWOBAR){
 238               		.loc 1 106 0
 239 0118 8091 0000 		lds r24,cnt
 240 011c 9091 0000 		lds r25,cnt+1
 241 0120 A091 0000 		lds r26,cnt+2
 242 0124 B091 0000 		lds r27,cnt+3
 243 0128 863A      		cpi r24,-90
 244 012a 9E40      		sbci r25,14
 245 012c A105      		cpc r26,__zero_reg__
 246 012e B105      		cpc r27,__zero_reg__
 247 0130 00F0      		brlo .L8
 107:main.cpp      **** 			myLCD.setBattery(LCD::TWOBAR);
 248               		.loc 1 107 0
 249 0132 86E0      		ldi r24,lo8(6)
 250 0134 00C0      		rjmp .L18
 251               	.L8:
 108:main.cpp      **** 		}else if(cnt>=BATT_ONEBAR){
 252               		.loc 1 108 0
 253 0136 8091 0000 		lds r24,cnt
 254 013a 9091 0000 		lds r25,cnt+1
 255 013e A091 0000 		lds r26,cnt+2
 256 0142 B091 0000 		lds r27,cnt+3
 257 0146 8031      		cpi r24,16
 258 0148 9E40      		sbci r25,14
 259 014a A105      		cpc r26,__zero_reg__
 260 014c B105      		cpc r27,__zero_reg__
 261 014e 00F0      		brlo .L9
 109:main.cpp      **** 			myLCD.setBattery(LCD::ONEBAR);
 262               		.loc 1 109 0
 263 0150 85E0      		ldi r24,lo8(5)
 264 0152 00C0      		rjmp .L18
 265               	.L9:
 110:main.cpp      **** 		}else if(cnt>=BATT_EMPTY){
 266               		.loc 1 110 0
 267 0154 8091 0000 		lds r24,cnt
 268 0158 9091 0000 		lds r25,cnt+1
 269 015c A091 0000 		lds r26,cnt+2
 270 0160 B091 0000 		lds r27,cnt+3
 271 0164 8C3A      		cpi r24,-84
 272 0166 9D40      		sbci r25,13
 273 0168 A105      		cpc r26,__zero_reg__
 274 016a B105      		cpc r27,__zero_reg__
 275 016c 00F0      		brlo .L10
 111:main.cpp      **** 			myLCD.setBattery(LCD::EMPTY);
 276               		.loc 1 111 0
 277 016e 81E0      		ldi r24,lo8(1)
 278 0170 00C0      		rjmp .L18
 279               	.L10:
 112:main.cpp      **** 		}else{
 113:main.cpp      **** 			myLCD.setBattery(LCD::NONE);
 280               		.loc 1 113 0
 281 0172 80E0      		ldi r24,0
 282               	.L18:
 283 0174 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 284               	.LVL7:
 114:main.cpp      **** 			//we should shutdown here
 115:main.cpp      **** 		}
 116:main.cpp      **** 		
 117:main.cpp      **** 		if(!BTN0){
 285               		.loc 1 117 0
 286 0178 4C99      		sbic 0x9,4
 287 017a 00C0      		rjmp .L11
 118:main.cpp      **** 			if(state==1){
 288               		.loc 1 118 0
 289 017c 8091 0000 		lds r24,state
 290 0180 8130      		cpi r24,lo8(1)
 291 0182 01F4      		brne .L12
 119:main.cpp      **** 				LED0_OFF;
 292               		.loc 1 119 0
 293 0184 5E98      		cbi 0xb,6
 294 0186 00C0      		rjmp .L11
 295               	.L12:
 120:main.cpp      **** 			//	state=0;
 121:main.cpp      **** 			}else{
 122:main.cpp      **** 				LED0_ON;
 296               		.loc 1 122 0
 297 0188 5E9A      		sbi 0xb,6
 298 018a 00C0      		rjmp .L11
 299               	.LBE17:
 300               		.cfi_endproc
 301               	.LFE10:
 303               	.global	__floatunsisf
 304               	.global	__divsf3
 305               	.global	__fixunssfsi
 306               		.text
 307               	.global	__vector_19
 309               	__vector_19:
 310               	.LFB11:
 123:main.cpp      **** 			}
 124:main.cpp      **** 		}
 125:main.cpp      **** 	}
 126:main.cpp      **** 
 127:main.cpp      **** 	return 0;
 128:main.cpp      **** }
 129:main.cpp      **** 
 130:main.cpp      **** 
 131:main.cpp      **** 
 132:main.cpp      **** 
 133:main.cpp      **** ISR(ADC_vect){
 311               		.loc 1 133 0
 312               		.cfi_startproc
 313 0000 1F92      		push r1
 314               	.LCFI4:
 315               		.cfi_def_cfa_offset 3
 316               		.cfi_offset 1, -2
 317 0002 0F92      		push r0
 318               	.LCFI5:
 319               		.cfi_def_cfa_offset 4
 320               		.cfi_offset 0, -3
 321 0004 0FB6      		in r0,__SREG__
 322 0006 0F92      		push r0
 323 0008 1124      		clr __zero_reg__
 324 000a 2F93      		push r18
 325               	.LCFI6:
 326               		.cfi_def_cfa_offset 5
 327               		.cfi_offset 18, -4
 328 000c 3F93      		push r19
 329               	.LCFI7:
 330               		.cfi_def_cfa_offset 6
 331               		.cfi_offset 19, -5
 332 000e 4F93      		push r20
 333               	.LCFI8:
 334               		.cfi_def_cfa_offset 7
 335               		.cfi_offset 20, -6
 336 0010 5F93      		push r21
 337               	.LCFI9:
 338               		.cfi_def_cfa_offset 8
 339               		.cfi_offset 21, -7
 340 0012 6F93      		push r22
 341               	.LCFI10:
 342               		.cfi_def_cfa_offset 9
 343               		.cfi_offset 22, -8
 344 0014 7F93      		push r23
 345               	.LCFI11:
 346               		.cfi_def_cfa_offset 10
 347               		.cfi_offset 23, -9
 348 0016 8F93      		push r24
 349               	.LCFI12:
 350               		.cfi_def_cfa_offset 11
 351               		.cfi_offset 24, -10
 352 0018 9F93      		push r25
 353               	.LCFI13:
 354               		.cfi_def_cfa_offset 12
 355               		.cfi_offset 25, -11
 356 001a AF93      		push r26
 357               	.LCFI14:
 358               		.cfi_def_cfa_offset 13
 359               		.cfi_offset 26, -12
 360 001c BF93      		push r27
 361               	.LCFI15:
 362               		.cfi_def_cfa_offset 14
 363               		.cfi_offset 27, -13
 364 001e EF93      		push r30
 365               	.LCFI16:
 366               		.cfi_def_cfa_offset 15
 367               		.cfi_offset 30, -14
 368 0020 FF93      		push r31
 369               	.LCFI17:
 370               		.cfi_def_cfa_offset 16
 371               		.cfi_offset 31, -15
 372               	/* prologue: Signal */
 373               	/* frame size = 0 */
 374               	/* stack size = 15 */
 375               	.L__stack_usage = 15
 134:main.cpp      **** 	uint16_t ADC_val=ADCL;
 376               		.loc 1 134 0
 377 0022 8091 7800 		lds r24,120
 378               	.LVL8:
 135:main.cpp      **** 	ADC_val+=ADCH<<8;
 379               		.loc 1 135 0
 380 0026 6091 7900 		lds r22,121
 381               	.LVL9:
 136:main.cpp      **** 	
 137:main.cpp      **** 	//CNT=1.1*1024/Vref
 138:main.cpp      **** 	//Vref=1.1*1024/CNT
 139:main.cpp      **** 	//1.02578
 140:main.cpp      **** 	//1.0127
 141:main.cpp      **** 	//
 142:main.cpp      **** 	cnt=(1024.0*1073.0)/ADC_val;
 382               		.loc 1 142 0
 383 002a 70E0      		ldi r23,0
 384 002c 762F      		mov r23,r22
 385 002e 6627      		clr r22
 386               	.LVL10:
 387 0030 680F      		add r22,r24
 388 0032 711D      		adc r23,__zero_reg__
 389 0034 80E0      		ldi r24,0
 390 0036 90E0      		ldi r25,0
 391 0038 0E94 0000 		call __floatunsisf
 392               	.LVL11:
 393 003c 9B01      		movw r18,r22
 394 003e AC01      		movw r20,r24
 395 0040 60E0      		ldi r22,0
 396 0042 70E2      		ldi r23,lo8(32)
 397 0044 86E8      		ldi r24,lo8(-122)
 398 0046 99E4      		ldi r25,lo8(73)
 399 0048 0E94 0000 		call __divsf3
 400               	.LVL12:
 401 004c 0E94 0000 		call __fixunssfsi
 402               	.LVL13:
 403 0050 6093 0000 		sts cnt,r22
 404 0054 7093 0000 		sts cnt+1,r23
 405 0058 8093 0000 		sts cnt+2,r24
 406 005c 9093 0000 		sts cnt+3,r25
 143:main.cpp      **** 	myLCD.setNb(cnt);
 407               		.loc 1 143 0
 408 0060 6091 0000 		lds r22,cnt
 409 0064 7091 0000 		lds r23,cnt+1
 410 0068 8091 0000 		lds r24,cnt+2
 411 006c 9091 0000 		lds r25,cnt+3
 412 0070 0E94 0000 		call _ZN3LCD5setNbEl
 413               	.LVL14:
 414               	/* epilogue start */
 144:main.cpp      **** }
 415               		.loc 1 144 0
 416 0074 FF91      		pop r31
 417 0076 EF91      		pop r30
 418 0078 BF91      		pop r27
 419 007a AF91      		pop r26
 420 007c 9F91      		pop r25
 421 007e 8F91      		pop r24
 422 0080 7F91      		pop r23
 423 0082 6F91      		pop r22
 424 0084 5F91      		pop r21
 425 0086 4F91      		pop r20
 426 0088 3F91      		pop r19
 427 008a 2F91      		pop r18
 428 008c 0F90      		pop r0
 429 008e 0FBE      		out __SREG__,r0
 430 0090 0F90      		pop r0
 431 0092 1F90      		pop r1
 432 0094 1895      		reti
 433               		.cfi_endproc
 434               	.LFE11:
 436               	.global	USART_RX_vect
 438               	USART_RX_vect:
 439               	.LFB12:
 145:main.cpp      **** 
 146:main.cpp      **** ISR(USART_RX_vect){
 440               		.loc 1 146 0
 441               		.cfi_startproc
 442 0096 1F92      		push r1
 443               	.LCFI18:
 444               		.cfi_def_cfa_offset 3
 445               		.cfi_offset 1, -2
 446 0098 0F92      		push r0
 447               	.LCFI19:
 448               		.cfi_def_cfa_offset 4
 449               		.cfi_offset 0, -3
 450 009a 0FB6      		in r0,__SREG__
 451 009c 0F92      		push r0
 452 009e 1124      		clr __zero_reg__
 453 00a0 2F93      		push r18
 454               	.LCFI20:
 455               		.cfi_def_cfa_offset 5
 456               		.cfi_offset 18, -4
 457 00a2 3F93      		push r19
 458               	.LCFI21:
 459               		.cfi_def_cfa_offset 6
 460               		.cfi_offset 19, -5
 461 00a4 4F93      		push r20
 462               	.LCFI22:
 463               		.cfi_def_cfa_offset 7
 464               		.cfi_offset 20, -6
 465 00a6 5F93      		push r21
 466               	.LCFI23:
 467               		.cfi_def_cfa_offset 8
 468               		.cfi_offset 21, -7
 469 00a8 6F93      		push r22
 470               	.LCFI24:
 471               		.cfi_def_cfa_offset 9
 472               		.cfi_offset 22, -8
 473 00aa 7F93      		push r23
 474               	.LCFI25:
 475               		.cfi_def_cfa_offset 10
 476               		.cfi_offset 23, -9
 477 00ac 8F93      		push r24
 478               	.LCFI26:
 479               		.cfi_def_cfa_offset 11
 480               		.cfi_offset 24, -10
 481 00ae 9F93      		push r25
 482               	.LCFI27:
 483               		.cfi_def_cfa_offset 12
 484               		.cfi_offset 25, -11
 485 00b0 AF93      		push r26
 486               	.LCFI28:
 487               		.cfi_def_cfa_offset 13
 488               		.cfi_offset 26, -12
 489 00b2 BF93      		push r27
 490               	.LCFI29:
 491               		.cfi_def_cfa_offset 14
 492               		.cfi_offset 27, -13
 493 00b4 EF93      		push r30
 494               	.LCFI30:
 495               		.cfi_def_cfa_offset 15
 496               		.cfi_offset 30, -14
 497 00b6 FF93      		push r31
 498               	.LCFI31:
 499               		.cfi_def_cfa_offset 16
 500               		.cfi_offset 31, -15
 501               	/* prologue: Signal */
 502               	/* frame size = 0 */
 503               	/* stack size = 15 */
 504               	.L__stack_usage = 15
 147:main.cpp      **** 	uint8_t data=uart.getChar();
 505               		.loc 1 147 0
 506 00b8 80E0      		ldi r24,lo8(uart)
 507 00ba 90E0      		ldi r25,hi8(uart)
 508 00bc 0E94 0000 		call _ZN4UART7getCharEv
 509               	.LVL15:
 510               	/* epilogue start */
 148:main.cpp      **** }
 511               		.loc 1 148 0
 512 00c0 FF91      		pop r31
 513 00c2 EF91      		pop r30
 514 00c4 BF91      		pop r27
 515 00c6 AF91      		pop r26
 516 00c8 9F91      		pop r25
 517 00ca 8F91      		pop r24
 518 00cc 7F91      		pop r23
 519 00ce 6F91      		pop r22
 520 00d0 5F91      		pop r21
 521 00d2 4F91      		pop r20
 522 00d4 3F91      		pop r19
 523 00d6 2F91      		pop r18
 524 00d8 0F90      		pop r0
 525 00da 0FBE      		out __SREG__,r0
 526 00dc 0F90      		pop r0
 527 00de 1F90      		pop r1
 528 00e0 1895      		reti
 529               		.cfi_endproc
 530               	.LFE12:
 532               		.section	.text.startup
 534               	_GLOBAL__sub_I_uart:
 535               	.LFB14:
 536               		.loc 1 148 0
 537               		.cfi_startproc
 538               	/* prologue: function */
 539               	/* frame size = 0 */
 540               	/* stack size = 0 */
 541               	.L__stack_usage = 0
 542               	.LVL16:
 543               	.LBB32:
 544               	.LBB33:
  12:main.cpp      **** MCP3462 myADC;
 545               		.loc 1 12 0
 546 018c 80E0      		ldi r24,lo8(uart)
 547 018e 90E0      		ldi r25,hi8(uart)
 548 0190 0E94 0000 		call _ZN4UARTC1Ev
 549               	.LVL17:
  13:main.cpp      **** SM mySM;
 550               		.loc 1 13 0
 551 0194 80E0      		ldi r24,lo8(myADC)
 552 0196 90E0      		ldi r25,hi8(myADC)
 553 0198 0E94 0000 		call _ZN7MCP3462C1Ev
 554               	.LVL18:
  14:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
 555               		.loc 1 14 0
 556 019c 80E0      		ldi r24,lo8(mySM)
 557 019e 90E0      		ldi r25,hi8(mySM)
 558 01a0 0E94 0000 		call _ZN2SMC1Ev
 559               	.LVL19:
  15:main.cpp      **** 
 560               		.loc 1 15 0
 561 01a4 60E0      		ldi r22,0
 562 01a6 80E0      		ldi r24,lo8(myLCD)
 563 01a8 90E0      		ldi r25,hi8(myLCD)
 564 01aa 0C94 0000 		jmp _ZN3LCDC1Eb
 565               	.LVL20:
 566               	.LBE33:
 567               	.LBE32:
 568               		.cfi_endproc
 569               	.LFE14:
 571               		.global __do_global_ctors
 572               		.section .ctors,"a",@progbits
 573               		.p2align	1
 574 0000 0000      		.word	gs(_GLOBAL__sub_I_uart)
 575               		.section	.text.exit,"ax",@progbits
 577               	_GLOBAL__sub_D_uart:
 578               	.LFB15:
 579               		.loc 1 148 0
 580               		.cfi_startproc
 581               	/* prologue: function */
 582               	/* frame size = 0 */
 583               	/* stack size = 0 */
 584               	.L__stack_usage = 0
 585               	.LVL21:
 586               	.LBB38:
 587               	.LBB39:
 588               	.LBB40:
  15:main.cpp      **** 
 589               		.loc 1 15 0
 590 0000 80E0      		ldi r24,lo8(myLCD)
 591 0002 90E0      		ldi r25,hi8(myLCD)
 592 0004 0E94 0000 		call _ZN3LCDD1Ev
 593               	.LVL22:
  14:main.cpp      **** LCD myLCD(0);//Use 1 for lowest power LCD mode
 594               		.loc 1 14 0
 595 0008 80E0      		ldi r24,lo8(mySM)
 596 000a 90E0      		ldi r25,hi8(mySM)
 597 000c 0E94 0000 		call _ZN2SMD1Ev
 598               	.LVL23:
  13:main.cpp      **** SM mySM;
 599               		.loc 1 13 0
 600 0010 80E0      		ldi r24,lo8(myADC)
 601 0012 90E0      		ldi r25,hi8(myADC)
 602 0014 0E94 0000 		call _ZN7MCP3462D1Ev
 603               	.LVL24:
  12:main.cpp      **** MCP3462 myADC;
 604               		.loc 1 12 0
 605 0018 80E0      		ldi r24,lo8(uart)
 606 001a 90E0      		ldi r25,hi8(uart)
 607 001c 0C94 0000 		jmp _ZN4UARTD1Ev
 608               	.LVL25:
 609               	.LBE40:
 610               	.LBE39:
 611               	.LBE38:
 612               		.cfi_endproc
 613               	.LFE15:
 615               		.global __do_global_dtors
 616               		.section .dtors,"a",@progbits
 617               		.p2align	1
 618 0000 0000      		.word	gs(_GLOBAL__sub_D_uart)
 619               	.global	state
 620               		.data
 623               	state:
 624 0000 01        		.byte	1
 625               	.global	cnt
 628               	cnt:
 629 0001 02        		.byte	2
 630 0002 E9        		.byte	-23
 631 0003 00        		.byte	0
 632 0004 00        		.byte	0
 633               	.global	myLCD
 634               		.section .bss
 637               	myLCD:
 638 0000 00        		.zero	1
 639               	.global	mySM
 642               	mySM:
 643 0001 0000      		.zero	2
 644               	.global	myADC
 647               	myADC:
 648 0003 00        		.zero	1
 649               	.global	uart
 652               	uart:
 653 0004 00        		.zero	1
 654               		.text
 655               	.Letext0:
 656               		.file 4 "/usr/lib/avr/include/stdint.h"
 657               		.file 5 "LCD.h"
 658               		.file 6 "UART.h"
 659               		.file 7 "ADC.h"
 660               		.file 8 "state_machine.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.cpp
     /tmp/ccxz8uuY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccxz8uuY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccxz8uuY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccxz8uuY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccxz8uuY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccxz8uuY.s:13     .text.startup:0000000000000000 main
     /tmp/ccxz8uuY.s:623    .data:0000000000000000 state
     /tmp/ccxz8uuY.s:647    .bss:0000000000000003 myADC
     /tmp/ccxz8uuY.s:652    .bss:0000000000000004 uart
     /tmp/ccxz8uuY.s:628    .data:0000000000000001 cnt
     /tmp/ccxz8uuY.s:309    .text:0000000000000000 __vector_19
     /tmp/ccxz8uuY.s:438    .text:0000000000000096 USART_RX_vect
     /tmp/ccxz8uuY.s:534    .text.startup:000000000000018c _GLOBAL__sub_I_uart
     /tmp/ccxz8uuY.s:642    .bss:0000000000000001 mySM
     /tmp/ccxz8uuY.s:637    .bss:0000000000000000 myLCD
     /tmp/ccxz8uuY.s:577    .text.exit:0000000000000000 _GLOBAL__sub_D_uart

UNDEFINED SYMBOLS
_ZN7MCP346211isDataReadyEv
_ZN7MCP346213getDirectDataEv
__ultoa_ncheck
_ZN4UART10sendStringEPc
_ZN3LCD10setBatteryENS_7BatteryE
__floatunsisf
__divsf3
__fixunssfsi
_ZN3LCD5setNbEl
_ZN4UART7getCharEv
_ZN4UARTC1Ev
_ZN7MCP3462C1Ev
_ZN2SMC1Ev
_ZN3LCDC1Eb
__do_global_ctors
_ZN3LCDD1Ev
_ZN2SMD1Ev
_ZN7MCP3462D1Ev
_ZN4UARTD1Ev
__do_global_dtors
__do_copy_data
__do_clear_bss
