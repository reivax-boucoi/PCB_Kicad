   1               		.file	"LCD.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	_ZN3LCDC2Eb
  12               	_ZN3LCDC2Eb:
  13               	.LFB7:
  14               		.file 1 "LCD.cpp"
   1:LCD.cpp       **** #include "LCD.h"
   2:LCD.cpp       **** 
   3:LCD.cpp       **** const uint8_t LCD::NbMap[]={0x3F,0x6,0x5B,0x4F,0x66,0x6D,0x7D,0x7,0x7F,0x6F};
   4:LCD.cpp       **** LCD::digit LCD::digits[]={
   5:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   6:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   7:LCD.cpp       **** 		{{6,6,6,7,7,7,7},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   8:LCD.cpp       **** 		{{4,4,4,5,5,5,5},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   9:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
  10:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}}};
  11:LCD.cpp       **** 
  12:LCD.cpp       **** LCD::LCD(bool lowP){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LBB10:
  13:LCD.cpp       **** 	DDRB |= (1 << PB0);
  23               		.loc 1 13 0
  24 0000 209A      		sbi 0x4,0
  14:LCD.cpp       **** 	PORTB |= (1<<PB0);
  25               		.loc 1 14 0
  26 0002 289A      		sbi 0x5,0
  15:LCD.cpp       **** 	LCDCRB|=(1<<LCDMUX1)|(1<<LCDMUX0);
  27               		.loc 1 15 0
  28 0004 8091 E500 		lds r24,229
  29               	.LVL1:
  30 0008 8063      		ori r24,lo8(48)
  31 000a 8093 E500 		sts 229,r24
  32               	.LBE10:
  33               	.LBB11:
  34               	.LBB12:
  16:LCD.cpp       **** 	
  17:LCD.cpp       **** 	if(lowP){
  18:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  35               		.loc 1 18 0
  36 000e 8091 E600 		lds r24,230
  37               	.LBE12:
  38               	.LBE11:
  39               	.LBB14:
  17:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  40               		.loc 1 17 0
  41 0012 6623      		tst r22
  42 0014 01F0      		breq .L2
  43               	.LVL2:
  44               	.LBE14:
  45               	.LBB15:
  46               	.LBB13:
  47               		.loc 1 18 0
  48 0016 8767      		ori r24,lo8(119)
  49 0018 8093 E600 		sts 230,r24
  19:LCD.cpp       **** 		LCDCCR|=(1<<LCDDC0);// 2.6V 70µs
  50               		.loc 1 19 0
  51 001c 8091 E700 		lds r24,231
  52 0020 8062      		ori r24,lo8(32)
  53 0022 8093 E700 		sts 231,r24
  20:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN)|(1<<LCDAB);//LCDAB=low power waveform
  54               		.loc 1 20 0
  55 0026 8091 E400 		lds r24,228
  56 002a 806C      		ori r24,lo8(-64)
  57 002c 00C0      		rjmp .L4
  58               	.LVL3:
  59               	.L2:
  60               	.LBE13:
  61               	.LBE15:
  62               	.LBB16:
  21:LCD.cpp       **** 	}else{
  22:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD2)|(1<<LCDCD0); // prescaler 409
  63               		.loc 1 22 0
  64 002e 8567      		ori r24,lo8(117)
  65 0030 8093 E600 		sts 230,r24
  23:LCD.cpp       **** 		LCDCCR|=(1<<LCDCC1)|(1<<LCDCC2)|(1<<LCDDC1);//2.7V 1150µs
  66               		.loc 1 23 0
  67 0034 8091 E700 		lds r24,231
  68 0038 8664      		ori r24,lo8(70)
  69 003a 8093 E700 		sts 231,r24
  24:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN);
  70               		.loc 1 24 0
  71 003e 8091 E400 		lds r24,228
  72 0042 8068      		ori r24,lo8(-128)
  73               	.L4:
  74 0044 8093 E400 		sts 228,r24
  75 0048 0895      		ret
  76               	.LBE16:
  77               		.cfi_endproc
  78               	.LFE7:
  80               	.global	_ZN3LCDC1Eb
  81               		.set	_ZN3LCDC1Eb,_ZN3LCDC2Eb
  82               	.global	_ZN3LCDD2Ev
  84               	_ZN3LCDD2Ev:
  85               	.LFB10:
  25:LCD.cpp       **** 	}
  26:LCD.cpp       **** }
  27:LCD.cpp       **** 
  28:LCD.cpp       **** LCD::~LCD() {
  86               		.loc 1 28 0
  87               		.cfi_startproc
  88               	.LVL4:
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 0 */
  92               	.L__stack_usage = 0
  93               	.LBB17:
  29:LCD.cpp       **** 	LCDCRA|=(1<<LCDBL);
  94               		.loc 1 29 0
  95 004a E4EE      		ldi r30,lo8(-28)
  96 004c F0E0      		ldi r31,0
  97 004e 8081      		ld r24,Z
  98               	.LVL5:
  99 0050 8160      		ori r24,lo8(1)
 100 0052 8083      		st Z,r24
 101               	.LVL6:
 102               	.LBB18:
 103               	.LBB19:
 104               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 105               		.loc 2 187 0
 106 0054 2FEF      		ldi r18,lo8(799999)
 107 0056 84E3      		ldi r24,hi8(799999)
 108 0058 9CE0      		ldi r25,hlo8(799999)
 109 005a 2150      	1:	subi r18,1
 110 005c 8040      		sbci r24,0
 111 005e 9040      		sbci r25,0
 112 0060 01F4      		brne 1b
 113 0062 00C0      		rjmp .
 114 0064 0000      		nop
 115               	.LVL7:
 116               	.LBE19:
 117               	.LBE18:
  30:LCD.cpp       **** 	_delay_ms(500);
  31:LCD.cpp       **** 	LCDCRA&=~(1<<LCDEN);
 118               		.loc 1 31 0
 119 0066 8081      		ld r24,Z
 120 0068 8F77      		andi r24,lo8(127)
 121 006a 8083      		st Z,r24
 122 006c 0895      		ret
 123               	.LBE17:
 124               		.cfi_endproc
 125               	.LFE10:
 127               	.global	_ZN3LCDD1Ev
 128               		.set	_ZN3LCDD1Ev,_ZN3LCDD2Ev
 129               	.global	_ZN3LCD8setDigitEhh
 131               	_ZN3LCD8setDigitEhh:
 132               	.LFB12:
  32:LCD.cpp       **** }
  33:LCD.cpp       **** 
  34:LCD.cpp       **** void LCD::setDigit(uint8_t dig, uint8_t nb) {
 133               		.loc 1 34 0
 134               		.cfi_startproc
 135               	.LVL8:
 136 006e CF92      		push r12
 137               	.LCFI0:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 12, -2
 140 0070 DF92      		push r13
 141               	.LCFI1:
 142               		.cfi_def_cfa_offset 4
 143               		.cfi_offset 13, -3
 144 0072 EF92      		push r14
 145               	.LCFI2:
 146               		.cfi_def_cfa_offset 5
 147               		.cfi_offset 14, -4
 148 0074 FF92      		push r15
 149               	.LCFI3:
 150               		.cfi_def_cfa_offset 6
 151               		.cfi_offset 15, -5
 152 0076 0F93      		push r16
 153               	.LCFI4:
 154               		.cfi_def_cfa_offset 7
 155               		.cfi_offset 16, -6
 156 0078 1F93      		push r17
 157               	.LCFI5:
 158               		.cfi_def_cfa_offset 8
 159               		.cfi_offset 17, -7
 160 007a CF93      		push r28
 161               	.LCFI6:
 162               		.cfi_def_cfa_offset 9
 163               		.cfi_offset 28, -8
 164 007c DF93      		push r29
 165               	.LCFI7:
 166               		.cfi_def_cfa_offset 10
 167               		.cfi_offset 29, -9
 168               	/* prologue: function */
 169               	/* frame size = 0 */
 170               	/* stack size = 8 */
 171               	.L__stack_usage = 8
 172               	.LVL9:
 173               	.LBB20:
  35:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  36:LCD.cpp       **** 		if(NbMap[nb] & (1<<j)){
 174               		.loc 1 36 0
 175 007e E62F      		mov r30,r22
 176 0080 F0E0      		ldi r31,0
 177 0082 E050      		subi r30,lo8(-(_ZN3LCD5NbMapE))
 178 0084 F040      		sbci r31,hi8(-(_ZN3LCD5NbMapE))
 179 0086 4081      		ld r20,Z
 180 0088 50E0      		ldi r21,0
 181 008a 25E1      		ldi r18,lo8(21)
 182 008c 829F      		mul r24,r18
 183 008e C001      		movw r24,r0
 184 0090 1124      		clr __zero_reg__
 185               	.LVL10:
 186 0092 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 187 0094 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 188 0096 FC01      		movw r30,r24
 189 0098 20E0      		ldi r18,0
 190 009a 30E0      		ldi r19,0
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
  38:LCD.cpp       **** 		}else{
  39:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 191               		.loc 1 39 0
 192 009c C1E0      		ldi r28,lo8(1)
 193 009e D0E0      		ldi r29,0
 194               	.LVL11:
 195               	.L10:
 196 00a0 6C01      		movw r12,r24
 197 00a2 C20E      		add r12,r18
 198 00a4 D31E      		adc r13,r19
  36:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 199               		.loc 1 36 0
 200 00a6 BA01      		movw r22,r20
 201 00a8 022E      		mov r0,r18
 202 00aa 00C0      		rjmp 2f
 203               		1:
 204 00ac 7595      		asr r23
 205 00ae 6795      		ror r22
 206               		2:
 207 00b0 0A94      		dec r0
 208 00b2 02F4      		brpl 1b
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 209               		.loc 1 37 0
 210 00b4 0781      		ldd r16,Z+7
 211 00b6 1085      		ldd r17,Z+8
 212 00b8 D801      		movw r26,r16
  36:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 213               		.loc 1 36 0
 214 00ba 60FF      		sbrs r22,0
 215 00bc 00C0      		rjmp .L8
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 216               		.loc 1 37 0
 217 00be FC90      		ld r15,X
 218 00c0 BE01      		movw r22,r28
 219 00c2 D601      		movw r26,r12
 220 00c4 0C90      		ld r0,X
 221 00c6 00C0      		rjmp 2f
 222               		1:
 223 00c8 660F      		lsl r22
 224 00ca 771F      		rol r23
 225               		2:
 226 00cc 0A94      		dec r0
 227 00ce 02F4      		brpl 1b
 228 00d0 6F29      		or r22,r15
 229 00d2 00C0      		rjmp .L12
 230               	.L8:
 231               		.loc 1 39 0
 232 00d4 7C91      		ld r23,X
 233 00d6 7E01      		movw r14,r28
 234 00d8 D601      		movw r26,r12
 235 00da 0C90      		ld r0,X
 236 00dc 00C0      		rjmp 2f
 237               		1:
 238 00de EE0C      		lsl r14
 239 00e0 FF1C      		rol r15
 240               		2:
 241 00e2 0A94      		dec r0
 242 00e4 02F4      		brpl 1b
 243 00e6 6E2D      		mov r22,r14
 244 00e8 6095      		com r22
 245 00ea 6723      		and r22,r23
 246               	.L12:
 247 00ec D801      		movw r26,r16
 248 00ee 6C93      		st X,r22
 249               	.LVL12:
 250 00f0 2F5F      		subi r18,-1
 251 00f2 3F4F      		sbci r19,-1
 252               	.LVL13:
 253 00f4 3296      		adiw r30,2
  35:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
 254               		.loc 1 35 0
 255 00f6 2830      		cpi r18,8
 256 00f8 3105      		cpc r19,__zero_reg__
 257 00fa 01F4      		brne .L10
 258               	/* epilogue start */
 259               	.LBE20:
  40:LCD.cpp       **** 		}	
  41:LCD.cpp       **** 	}
  42:LCD.cpp       **** }
 260               		.loc 1 42 0
 261 00fc DF91      		pop r29
 262 00fe CF91      		pop r28
 263 0100 1F91      		pop r17
 264 0102 0F91      		pop r16
 265 0104 FF90      		pop r15
 266 0106 EF90      		pop r14
 267 0108 DF90      		pop r13
 268 010a CF90      		pop r12
 269 010c 0895      		ret
 270               		.cfi_endproc
 271               	.LFE12:
 273               	.global	_ZN3LCD8setDigitEhNS_6SymbolE
 275               	_ZN3LCD8setDigitEhNS_6SymbolE:
 276               	.LFB13:
  43:LCD.cpp       **** 
  44:LCD.cpp       **** void LCD::setDigit(uint8_t dig, Symbol sy) {
 277               		.loc 1 44 0
 278               		.cfi_startproc
 279               	.LVL14:
 280 010e CF92      		push r12
 281               	.LCFI8:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 12, -2
 284 0110 DF92      		push r13
 285               	.LCFI9:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 13, -3
 288 0112 EF92      		push r14
 289               	.LCFI10:
 290               		.cfi_def_cfa_offset 5
 291               		.cfi_offset 14, -4
 292 0114 FF92      		push r15
 293               	.LCFI11:
 294               		.cfi_def_cfa_offset 6
 295               		.cfi_offset 15, -5
 296 0116 0F93      		push r16
 297               	.LCFI12:
 298               		.cfi_def_cfa_offset 7
 299               		.cfi_offset 16, -6
 300 0118 1F93      		push r17
 301               	.LCFI13:
 302               		.cfi_def_cfa_offset 8
 303               		.cfi_offset 17, -7
 304 011a CF93      		push r28
 305               	.LCFI14:
 306               		.cfi_def_cfa_offset 9
 307               		.cfi_offset 28, -8
 308 011c DF93      		push r29
 309               	.LCFI15:
 310               		.cfi_def_cfa_offset 10
 311               		.cfi_offset 29, -9
 312               	/* prologue: function */
 313               	/* frame size = 0 */
 314               	/* stack size = 8 */
 315               	.L__stack_usage = 8
 316               	.LVL15:
 317 011e 25E1      		ldi r18,lo8(21)
 318 0120 829F      		mul r24,r18
 319 0122 C001      		movw r24,r0
 320 0124 1124      		clr __zero_reg__
 321               	.LVL16:
 322 0126 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 323 0128 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 324 012a FC01      		movw r30,r24
 325               		.loc 1 44 0
 326 012c 20E0      		ldi r18,0
 327 012e 30E0      		ldi r19,0
 328               	.LBB21:
  45:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  46:LCD.cpp       **** 		if(sy & (1<<j)){
 329               		.loc 1 46 0
 330 0130 70E0      		ldi r23,0
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
  48:LCD.cpp       **** 		}else{
  49:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 331               		.loc 1 49 0
 332 0132 C1E0      		ldi r28,lo8(1)
 333 0134 D0E0      		ldi r29,0
 334               	.LVL17:
 335               	.L16:
 336 0136 6C01      		movw r12,r24
 337 0138 C20E      		add r12,r18
 338 013a D31E      		adc r13,r19
  46:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 339               		.loc 1 46 0
 340 013c AB01      		movw r20,r22
 341 013e 022E      		mov r0,r18
 342 0140 00C0      		rjmp 2f
 343               		1:
 344 0142 5595      		asr r21
 345 0144 4795      		ror r20
 346               		2:
 347 0146 0A94      		dec r0
 348 0148 02F4      		brpl 1b
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 349               		.loc 1 47 0
 350 014a 0781      		ldd r16,Z+7
 351 014c 1085      		ldd r17,Z+8
 352 014e D801      		movw r26,r16
  46:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 353               		.loc 1 46 0
 354 0150 40FF      		sbrs r20,0
 355 0152 00C0      		rjmp .L14
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 356               		.loc 1 47 0
 357 0154 FC90      		ld r15,X
 358 0156 AE01      		movw r20,r28
 359 0158 D601      		movw r26,r12
 360 015a 0C90      		ld r0,X
 361 015c 00C0      		rjmp 2f
 362               		1:
 363 015e 440F      		lsl r20
 364 0160 551F      		rol r21
 365               		2:
 366 0162 0A94      		dec r0
 367 0164 02F4      		brpl 1b
 368 0166 4F29      		or r20,r15
 369 0168 00C0      		rjmp .L18
 370               	.L14:
 371               		.loc 1 49 0
 372 016a 5C91      		ld r21,X
 373 016c 7E01      		movw r14,r28
 374 016e D601      		movw r26,r12
 375 0170 0C90      		ld r0,X
 376 0172 00C0      		rjmp 2f
 377               		1:
 378 0174 EE0C      		lsl r14
 379 0176 FF1C      		rol r15
 380               		2:
 381 0178 0A94      		dec r0
 382 017a 02F4      		brpl 1b
 383 017c 4E2D      		mov r20,r14
 384 017e 4095      		com r20
 385 0180 4523      		and r20,r21
 386               	.L18:
 387 0182 D801      		movw r26,r16
 388 0184 4C93      		st X,r20
 389               	.LVL18:
 390 0186 2F5F      		subi r18,-1
 391 0188 3F4F      		sbci r19,-1
 392               	.LVL19:
 393 018a 3296      		adiw r30,2
  45:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
 394               		.loc 1 45 0
 395 018c 2830      		cpi r18,8
 396 018e 3105      		cpc r19,__zero_reg__
 397 0190 01F4      		brne .L16
 398               	/* epilogue start */
 399               	.LBE21:
  50:LCD.cpp       **** 		}
  51:LCD.cpp       **** 	}
  52:LCD.cpp       **** }
 400               		.loc 1 52 0
 401 0192 DF91      		pop r29
 402 0194 CF91      		pop r28
 403 0196 1F91      		pop r17
 404 0198 0F91      		pop r16
 405 019a FF90      		pop r15
 406 019c EF90      		pop r14
 407 019e DF90      		pop r13
 408 01a0 CF90      		pop r12
 409 01a2 0895      		ret
 410               		.cfi_endproc
 411               	.LFE13:
 413               	.global	_ZN3LCD10setBatteryENS_7BatteryE
 415               	_ZN3LCD10setBatteryENS_7BatteryE:
 416               	.LFB14:
  53:LCD.cpp       **** 
  54:LCD.cpp       **** void LCD::setBattery(Battery b) {
 417               		.loc 1 54 0
 418               		.cfi_startproc
 419               	.LVL20:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
  55:LCD.cpp       **** 	switch(b){
 424               		.loc 1 55 0
 425 01a4 90E0      		ldi r25,0
 426 01a6 8830      		cpi r24,8
 427 01a8 9105      		cpc r25,__zero_reg__
 428 01aa 00F0      		brlo .+2
 429 01ac 00C0      		rjmp .L19
 430 01ae FC01      		movw r30,r24
 431 01b0 E050      		subi r30,lo8(-(gs(.L22)))
 432 01b2 F040      		sbci r31,hi8(-(gs(.L22)))
  56:LCD.cpp       **** 	case NONE:
  57:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  58:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  59:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  60:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  61:LCD.cpp       **** 		break;
  62:LCD.cpp       **** 	case EMPTY:
  63:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  64:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  65:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  66:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  67:LCD.cpp       **** 		break;
  68:LCD.cpp       **** 	case FIRST:
  69:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  70:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  71:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  72:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  73:LCD.cpp       **** 		break;
  74:LCD.cpp       **** 	case SECOND:
  75:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  76:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  77:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  78:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  79:LCD.cpp       **** 		break;
  80:LCD.cpp       **** 	case THIRD:
  81:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  82:LCD.cpp       **** 		LCDDR6 |=(1<<4);
  83:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  84:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  85:LCD.cpp       **** 		break;
  86:LCD.cpp       **** 	case ONEBAR:
  87:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  88:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  89:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  90:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  91:LCD.cpp       **** 		break;
  92:LCD.cpp       **** 	case TWOBAR:
  93:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  94:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  95:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  96:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  97:LCD.cpp       **** 		break;
  98:LCD.cpp       **** 	case FULL:
  99:LCD.cpp       **** 		LCDDR1 |=(1<<4);
 433               		.loc 1 99 0
 434 01b4 8091 ED00 		lds r24,237
 435               	.LVL21:
  55:LCD.cpp       **** 	switch(b){
 436               		.loc 1 55 0
 437 01b8 0C94 0000 		jmp __tablejump2__
 438               	.LVL22:
 439               		.section	.progmem.gcc_sw_table,"a",@progbits
 440               		.p2align	1
 441               	.L22:
 442 0000 0000      		.word gs(.L21)
 443 0002 0000      		.word gs(.L23)
 444 0004 0000      		.word gs(.L24)
 445 0006 0000      		.word gs(.L25)
 446 0008 0000      		.word gs(.L26)
 447 000a 0000      		.word gs(.L27)
 448 000c 0000      		.word gs(.L28)
 449 000e 0000      		.word gs(.L29)
 450               		.text
 451               	.L21:
  57:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 452               		.loc 1 57 0
 453 01bc 8F7E      		andi r24,lo8(-17)
 454 01be 00C0      		rjmp .L36
 455               	.L23:
  63:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 456               		.loc 1 63 0
 457 01c0 8061      		ori r24,lo8(16)
 458               	.L36:
 459 01c2 8093 ED00 		sts 237,r24
  64:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 460               		.loc 1 64 0
 461 01c6 8091 F200 		lds r24,242
 462 01ca 8F7E      		andi r24,lo8(-17)
 463 01cc 00C0      		rjmp .L35
 464               	.L24:
  69:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 465               		.loc 1 69 0
 466 01ce 8F7E      		andi r24,lo8(-17)
 467 01d0 00C0      		rjmp .L33
 468               	.L25:
  75:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 469               		.loc 1 75 0
 470 01d2 8F7E      		andi r24,lo8(-17)
 471 01d4 8093 ED00 		sts 237,r24
  76:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 472               		.loc 1 76 0
 473 01d8 8091 F200 		lds r24,242
 474 01dc 8F7E      		andi r24,lo8(-17)
 475 01de 8093 F200 		sts 242,r24
  77:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 476               		.loc 1 77 0
 477 01e2 8091 F700 		lds r24,247
 478 01e6 8061      		ori r24,lo8(16)
 479 01e8 00C0      		rjmp .L34
 480               	.L26:
  81:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 481               		.loc 1 81 0
 482 01ea 8F7E      		andi r24,lo8(-17)
 483 01ec 8093 ED00 		sts 237,r24
  82:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 484               		.loc 1 82 0
 485 01f0 8091 F200 		lds r24,242
 486 01f4 8061      		ori r24,lo8(16)
 487               	.L35:
 488 01f6 8093 F200 		sts 242,r24
  83:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 489               		.loc 1 83 0
 490 01fa 8091 F700 		lds r24,247
 491 01fe 8F7E      		andi r24,lo8(-17)
 492               	.L34:
 493 0200 8093 F700 		sts 247,r24
  84:LCD.cpp       **** 		break;
 494               		.loc 1 84 0
 495 0204 8091 FC00 		lds r24,252
 496 0208 8F7E      		andi r24,lo8(-17)
 497 020a 00C0      		rjmp .L32
 498               	.L27:
  87:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 499               		.loc 1 87 0
 500 020c 8061      		ori r24,lo8(16)
 501               	.L33:
 502 020e 8093 ED00 		sts 237,r24
  88:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 503               		.loc 1 88 0
 504 0212 8091 F200 		lds r24,242
 505 0216 8F7E      		andi r24,lo8(-17)
 506 0218 8093 F200 		sts 242,r24
  89:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 507               		.loc 1 89 0
 508 021c 8091 F700 		lds r24,247
 509 0220 8F7E      		andi r24,lo8(-17)
 510 0222 00C0      		rjmp .L30
 511               	.L28:
  93:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 512               		.loc 1 93 0
 513 0224 8061      		ori r24,lo8(16)
 514 0226 8093 ED00 		sts 237,r24
  94:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 515               		.loc 1 94 0
 516 022a 8091 F200 		lds r24,242
 517 022e 8F7E      		andi r24,lo8(-17)
 518 0230 00C0      		rjmp .L31
 519               	.L29:
 520               		.loc 1 99 0
 521 0232 8061      		ori r24,lo8(16)
 522 0234 8093 ED00 		sts 237,r24
 100:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 523               		.loc 1 100 0
 524 0238 8091 F200 		lds r24,242
 525 023c 8061      		ori r24,lo8(16)
 526               	.L31:
 527 023e 8093 F200 		sts 242,r24
 101:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 528               		.loc 1 101 0
 529 0242 8091 F700 		lds r24,247
 530 0246 8061      		ori r24,lo8(16)
 531               	.L30:
 532 0248 8093 F700 		sts 247,r24
 102:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 533               		.loc 1 102 0
 534 024c 8091 FC00 		lds r24,252
 535 0250 8061      		ori r24,lo8(16)
 536               	.L32:
 537 0252 8093 FC00 		sts 252,r24
 538               	.L19:
 539 0256 0895      		ret
 540               		.cfi_endproc
 541               	.LFE14:
 543               	.global	_ZN3LCD5setDPEb
 545               	_ZN3LCD5setDPEb:
 546               	.LFB15:
 103:LCD.cpp       **** 		break;
 104:LCD.cpp       **** 	}
 105:LCD.cpp       **** }
 106:LCD.cpp       **** 
 107:LCD.cpp       **** void LCD::setDP(bool b) {
 547               		.loc 1 107 0
 548               		.cfi_startproc
 549               	.LVL23:
 550               	/* prologue: function */
 551               	/* frame size = 0 */
 552               	/* stack size = 0 */
 553               	.L__stack_usage = 0
 108:LCD.cpp       **** 	if(b){
 554               		.loc 1 108 0
 555 0258 8823      		tst r24
 556 025a 01F0      		breq .L38
 557               	.LVL24:
 558               	.LBB24:
 559               	.LBB25:
 109:LCD.cpp       **** 		LCDDR15|=(1<<4);
 560               		.loc 1 109 0
 561 025c 8091 FB00 		lds r24,251
 562               	.LVL25:
 563 0260 8061      		ori r24,lo8(16)
 564 0262 00C0      		rjmp .L40
 565               	.LVL26:
 566               	.L38:
 567               	.LBE25:
 568               	.LBE24:
 110:LCD.cpp       **** 	}else{
 111:LCD.cpp       **** 		LCDDR15&=~(1<<4);
 569               		.loc 1 111 0
 570 0264 8091 FB00 		lds r24,251
 571               	.LVL27:
 572 0268 8F7E      		andi r24,lo8(-17)
 573               	.L40:
 574 026a 8093 FB00 		sts 251,r24
 575 026e 0895      		ret
 576               		.cfi_endproc
 577               	.LFE15:
 579               	.global	_ZN3LCD6setClkEb
 581               	_ZN3LCD6setClkEb:
 582               	.LFB16:
 112:LCD.cpp       **** 	}
 113:LCD.cpp       **** }
 114:LCD.cpp       **** 
 115:LCD.cpp       **** void LCD::setClk(bool b) {
 583               		.loc 1 115 0
 584               		.cfi_startproc
 585               	.LVL28:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 116:LCD.cpp       **** 	if(b){
 590               		.loc 1 116 0
 591 0270 8823      		tst r24
 592 0272 01F0      		breq .L42
 593               	.LVL29:
 594               	.LBB28:
 595               	.LBB29:
 117:LCD.cpp       **** 		LCDDR16|=1;
 596               		.loc 1 117 0
 597 0274 8091 FC00 		lds r24,252
 598               	.LVL30:
 599 0278 8160      		ori r24,lo8(1)
 600 027a 00C0      		rjmp .L44
 601               	.LVL31:
 602               	.L42:
 603               	.LBE29:
 604               	.LBE28:
 118:LCD.cpp       **** 	}else{
 119:LCD.cpp       **** 		LCDDR16&=~1;
 605               		.loc 1 119 0
 606 027c 8091 FC00 		lds r24,252
 607               	.LVL32:
 608 0280 8E7F      		andi r24,lo8(-2)
 609               	.L44:
 610 0282 8093 FC00 		sts 252,r24
 611 0286 0895      		ret
 612               		.cfi_endproc
 613               	.LFE16:
 615               	.global	_ZN3LCD5getDPEv
 617               	_ZN3LCD5getDPEv:
 618               	.LFB17:
 120:LCD.cpp       **** 	}
 121:LCD.cpp       **** }
 122:LCD.cpp       **** 
 123:LCD.cpp       **** bool LCD::getDP(void) {
 619               		.loc 1 123 0
 620               		.cfi_startproc
 621               	/* prologue: function */
 622               	/* frame size = 0 */
 623               	/* stack size = 0 */
 624               	.L__stack_usage = 0
 124:LCD.cpp       **** 	return (LCDDR15 & (1<<4));
 625               		.loc 1 124 0
 626 0288 8091 FB00 		lds r24,251
 125:LCD.cpp       **** }
 627               		.loc 1 125 0
 628 028c 8295      		swap r24
 629 028e 8170      		andi r24,1
 630 0290 0895      		ret
 631               		.cfi_endproc
 632               	.LFE17:
 634               	.global	_ZN3LCD6getClkEv
 636               	_ZN3LCD6getClkEv:
 637               	.LFB18:
 126:LCD.cpp       **** 
 127:LCD.cpp       **** bool LCD::getClk(void) {
 638               		.loc 1 127 0
 639               		.cfi_startproc
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 128:LCD.cpp       **** 	return (LCDDR16 & 1);
 644               		.loc 1 128 0
 645 0292 8091 FC00 		lds r24,252
 129:LCD.cpp       **** }
 646               		.loc 1 129 0
 647 0296 8170      		andi r24,lo8(1)
 648 0298 0895      		ret
 649               		.cfi_endproc
 650               	.LFE18:
 652               	.global	_ZN3LCD5setNbElh
 654               	_ZN3LCD5setNbElh:
 655               	.LFB19:
 130:LCD.cpp       **** 
 131:LCD.cpp       **** 
 132:LCD.cpp       **** 
 133:LCD.cpp       **** uint8_t LCD::setNb(int32_t nb, uint8_t dig) {
 656               		.loc 1 133 0
 657               		.cfi_startproc
 658               	.LVL33:
 659 029a 4F92      		push r4
 660               	.LCFI16:
 661               		.cfi_def_cfa_offset 3
 662               		.cfi_offset 4, -2
 663 029c 5F92      		push r5
 664               	.LCFI17:
 665               		.cfi_def_cfa_offset 4
 666               		.cfi_offset 5, -3
 667 029e 6F92      		push r6
 668               	.LCFI18:
 669               		.cfi_def_cfa_offset 5
 670               		.cfi_offset 6, -4
 671 02a0 7F92      		push r7
 672               	.LCFI19:
 673               		.cfi_def_cfa_offset 6
 674               		.cfi_offset 7, -5
 675 02a2 8F92      		push r8
 676               	.LCFI20:
 677               		.cfi_def_cfa_offset 7
 678               		.cfi_offset 8, -6
 679 02a4 9F92      		push r9
 680               	.LCFI21:
 681               		.cfi_def_cfa_offset 8
 682               		.cfi_offset 9, -7
 683 02a6 AF92      		push r10
 684               	.LCFI22:
 685               		.cfi_def_cfa_offset 9
 686               		.cfi_offset 10, -8
 687 02a8 BF92      		push r11
 688               	.LCFI23:
 689               		.cfi_def_cfa_offset 10
 690               		.cfi_offset 11, -9
 691 02aa CF92      		push r12
 692               	.LCFI24:
 693               		.cfi_def_cfa_offset 11
 694               		.cfi_offset 12, -10
 695 02ac DF92      		push r13
 696               	.LCFI25:
 697               		.cfi_def_cfa_offset 12
 698               		.cfi_offset 13, -11
 699 02ae EF92      		push r14
 700               	.LCFI26:
 701               		.cfi_def_cfa_offset 13
 702               		.cfi_offset 14, -12
 703 02b0 FF92      		push r15
 704               	.LCFI27:
 705               		.cfi_def_cfa_offset 14
 706               		.cfi_offset 15, -13
 707 02b2 0F93      		push r16
 708               	.LCFI28:
 709               		.cfi_def_cfa_offset 15
 710               		.cfi_offset 16, -14
 711 02b4 1F93      		push r17
 712               	.LCFI29:
 713               		.cfi_def_cfa_offset 16
 714               		.cfi_offset 17, -15
 715 02b6 CF93      		push r28
 716               	.LCFI30:
 717               		.cfi_def_cfa_offset 17
 718               		.cfi_offset 28, -16
 719 02b8 DF93      		push r29
 720               	.LCFI31:
 721               		.cfi_def_cfa_offset 18
 722               		.cfi_offset 29, -17
 723               	/* prologue: function */
 724               	/* frame size = 0 */
 725               	/* stack size = 16 */
 726               	.L__stack_usage = 16
 727 02ba 6B01      		movw r12,r22
 728 02bc 7C01      		movw r14,r24
 729 02be C42F      		mov r28,r20
 134:LCD.cpp       **** 	if(nb>999999 || nb <-99999){
 730               		.loc 1 134 0
 731 02c0 DC01      		movw r26,r24
 732 02c2 CB01      		movw r24,r22
 733 02c4 8156      		subi r24,97
 734 02c6 9947      		sbci r25,121
 735 02c8 AE4F      		sbci r26,-2
 736 02ca BF4F      		sbci r27,-1
 737 02cc 8F3D      		cpi r24,-33
 738 02ce 984C      		sbci r25,-56
 739 02d0 A041      		sbci r26,16
 740 02d2 B105      		cpc r27,__zero_reg__
 741 02d4 00F0      		brlo .+2
 742 02d6 00C0      		rjmp .L54
 743               	.LVL34:
 744               	.LBB32:
 745               	.LBB33:
 135:LCD.cpp       **** 		return 1;
 136:LCD.cpp       **** 	}
 137:LCD.cpp       **** 	int8_t d=5;
 138:LCD.cpp       **** 	uint8_t min=6-dig;
 746               		.loc 1 138 0
 747 02d8 86E0      		ldi r24,lo8(6)
 748 02da 841B      		sub r24,r20
 749               	.LVL35:
 139:LCD.cpp       **** 	if(nb<0){
 750               		.loc 1 139 0
 751 02dc F7FE      		sbrs r15,7
 752 02de 00C0      		rjmp .L49
 140:LCD.cpp       **** 		setDigit(min,Minus);
 753               		.loc 1 140 0
 754 02e0 60E4      		ldi r22,lo8(64)
 755               	.LVL36:
 756 02e2 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 757               	.LVL37:
 141:LCD.cpp       **** 		min++;
 758               		.loc 1 141 0
 759 02e6 87E0      		ldi r24,lo8(7)
 760               	.LVL38:
 761 02e8 8C1B      		sub r24,r28
 762               	.LVL39:
 142:LCD.cpp       **** 		nb=(~nb)+1;
 763               		.loc 1 142 0
 764 02ea F094      		com r15
 765 02ec E094      		com r14
 766 02ee D094      		com r13
 767 02f0 C094      		com r12
 768 02f2 C11C      		adc r12,__zero_reg__
 769 02f4 D11C      		adc r13,__zero_reg__
 770 02f6 E11C      		adc r14,__zero_reg__
 771 02f8 F11C      		adc r15,__zero_reg__
 772               	.LVL40:
 773               	.L49:
 774               	.LBE33:
 775               	.LBE32:
 133:LCD.cpp       **** 	if(nb>999999 || nb <-99999){
 776               		.loc 1 133 0
 777 02fa 15E0      		ldi r17,lo8(5)
 778               	.LBB36:
 779               	.LBB34:
 143:LCD.cpp       **** 	}
 144:LCD.cpp       **** 	while(d>=min){
 780               		.loc 1 144 0
 781 02fc C82F      		mov r28,r24
 782               	.LVL41:
 783 02fe D0E0      		ldi r29,0
 145:LCD.cpp       **** 		setDigit(d--,nb%10);
 784               		.loc 1 145 0
 785 0300 8AE0      		ldi r24,lo8(10)
 786 0302 482E      		mov r4,r24
 787 0304 512C      		mov r5,__zero_reg__
 788 0306 612C      		mov r6,__zero_reg__
 789 0308 712C      		mov r7,__zero_reg__
 790               	.LVL42:
 791               	.L51:
 144:LCD.cpp       **** 		setDigit(d--,nb%10);
 792               		.loc 1 144 0
 793 030a 812F      		mov r24,r17
 794 030c 012E      		mov __tmp_reg__,r17
 795 030e 000C      		lsl r0
 796 0310 990B      		sbc r25,r25
 797 0312 8C17      		cp r24,r28
 798 0314 9D07      		cpc r25,r29
 799 0316 04F4      		brge .L50
 800               	.LVL43:
 801               	.L52:
 802               	.LBE34:
 803               	.LBE36:
 135:LCD.cpp       **** 	}
 804               		.loc 1 135 0
 805 0318 80E0      		ldi r24,0
 806 031a 00C0      		rjmp .L48
 807               	.LVL44:
 808               	.L50:
 809               	.LBB37:
 810               	.LBB35:
 811               		.loc 1 145 0
 812 031c C701      		movw r24,r14
 813 031e B601      		movw r22,r12
 814 0320 A301      		movw r20,r6
 815 0322 9201      		movw r18,r4
 816 0324 0E94 0000 		call __divmodsi4
 817 0328 4901      		movw r8,r18
 818 032a 5A01      		movw r10,r20
 819 032c 812F      		mov r24,r17
 820 032e 1150      		subi r17,lo8(-(-1))
 821               	.LVL45:
 822 0330 0E94 0000 		call _ZN3LCD8setDigitEhh
 823               	.LVL46:
 146:LCD.cpp       **** 		nb/=10;
 824               		.loc 1 146 0
 825 0334 6401      		movw r12,r8
 826               	.LVL47:
 827 0336 7501      		movw r14,r10
 828               	.LVL48:
 147:LCD.cpp       **** 		if(nb==0)break;
 829               		.loc 1 147 0
 830 0338 C114      		cp r12,__zero_reg__
 831 033a D104      		cpc r13,__zero_reg__
 832 033c E104      		cpc r14,__zero_reg__
 833 033e F104      		cpc r15,__zero_reg__
 834 0340 01F4      		brne .L51
 835               	.LVL49:
 836               	.L53:
 148:LCD.cpp       **** 	}
 149:LCD.cpp       **** 	while(d>=min)setDigit(d--,Blank);
 837               		.loc 1 149 0
 838 0342 812F      		mov r24,r17
 839 0344 012E      		mov __tmp_reg__,r17
 840 0346 000C      		lsl r0
 841 0348 990B      		sbc r25,r25
 842 034a 8C17      		cp r24,r28
 843 034c 9D07      		cpc r25,r29
 844 034e 04F0      		brlt .L52
 845 0350 812F      		mov r24,r17
 846 0352 60E0      		ldi r22,0
 847 0354 1150      		subi r17,lo8(-(-1))
 848               	.LVL50:
 849 0356 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 850               	.LVL51:
 851 035a 00C0      		rjmp .L53
 852               	.LVL52:
 853               	.L54:
 854               	.LBE35:
 855               	.LBE37:
 135:LCD.cpp       **** 	}
 856               		.loc 1 135 0
 857 035c 81E0      		ldi r24,lo8(1)
 858               	.LVL53:
 859               	.L48:
 860               	/* epilogue start */
 150:LCD.cpp       **** 	return 0;
 151:LCD.cpp       **** }
 861               		.loc 1 151 0
 862 035e DF91      		pop r29
 863 0360 CF91      		pop r28
 864 0362 1F91      		pop r17
 865 0364 0F91      		pop r16
 866 0366 FF90      		pop r15
 867 0368 EF90      		pop r14
 868 036a DF90      		pop r13
 869 036c CF90      		pop r12
 870 036e BF90      		pop r11
 871 0370 AF90      		pop r10
 872 0372 9F90      		pop r9
 873 0374 8F90      		pop r8
 874 0376 7F90      		pop r7
 875 0378 6F90      		pop r6
 876 037a 5F90      		pop r5
 877 037c 4F90      		pop r4
 878 037e 0895      		ret
 879               		.cfi_endproc
 880               	.LFE19:
 882               	.global	_ZN3LCD5setNbEl
 884               	_ZN3LCD5setNbEl:
 885               	.LFB20:
 152:LCD.cpp       **** 
 153:LCD.cpp       **** uint8_t LCD::setNb(int32_t nb) {
 886               		.loc 1 153 0
 887               		.cfi_startproc
 888               	.LVL54:
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 0 */
 892               	.L__stack_usage = 0
 154:LCD.cpp       **** 	return setNb(nb,6);
 893               		.loc 1 154 0
 894 0380 46E0      		ldi r20,lo8(6)
 895 0382 0C94 0000 		jmp _ZN3LCD5setNbElh
 896               	.LVL55:
 897               		.cfi_endproc
 898               	.LFE20:
 900               	.global	_ZN3LCD5clearEb
 902               	_ZN3LCD5clearEb:
 903               	.LFB22:
 155:LCD.cpp       **** }
 156:LCD.cpp       **** 
 157:LCD.cpp       **** void LCD::clear(void) {
 158:LCD.cpp       **** 	clear(true);
 159:LCD.cpp       **** }
 160:LCD.cpp       **** void LCD::clear(bool clearBatt) {
 904               		.loc 1 160 0
 905               		.cfi_startproc
 906               	.LVL56:
 907 0386 CF93      		push r28
 908               	.LCFI32:
 909               		.cfi_def_cfa_offset 3
 910               		.cfi_offset 28, -2
 911               	/* prologue: function */
 912               	/* frame size = 0 */
 913               	/* stack size = 1 */
 914               	.L__stack_usage = 1
 161:LCD.cpp       **** 	if(clearBatt)setBattery(NONE);
 915               		.loc 1 161 0
 916 0388 8823      		tst r24
 917 038a 01F0      		breq .L58
 918               		.loc 1 161 0 is_stmt 0 discriminator 1
 919 038c 80E0      		ldi r24,0
 920               	.LVL57:
 921 038e 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 922               	.LVL58:
 923               	.L58:
 162:LCD.cpp       **** 	setClk(false);
 924               		.loc 1 162 0 is_stmt 1
 925 0392 80E0      		ldi r24,0
 926 0394 0E94 0000 		call _ZN3LCD6setClkEb
 927               	.LVL59:
 163:LCD.cpp       **** 	setDP(false);
 928               		.loc 1 163 0
 929 0398 80E0      		ldi r24,0
 930 039a 0E94 0000 		call _ZN3LCD5setDPEb
 931               	.LVL60:
 932               	.LBB38:
 164:LCD.cpp       **** 	for(int8_t i=5;i>=0;i--)setDigit(i,Blank);
 933               		.loc 1 164 0
 934 039e C5E0      		ldi r28,lo8(5)
 935               	.LVL61:
 936               	.L59:
 937               		.loc 1 164 0 is_stmt 0 discriminator 2
 938 03a0 60E0      		ldi r22,0
 939 03a2 8C2F      		mov r24,r28
 940 03a4 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 941               	.LVL62:
 942               	.LVL63:
 943 03a8 C150      		subi r28,1
 944 03aa 00F4      		brcc .L59
 945               	/* epilogue start */
 946               	.LBE38:
 165:LCD.cpp       **** }
 947               		.loc 1 165 0 is_stmt 1
 948 03ac CF91      		pop r28
 949               	.LVL64:
 950 03ae 0895      		ret
 951               		.cfi_endproc
 952               	.LFE22:
 954               	.global	_ZN3LCD5clearEv
 956               	_ZN3LCD5clearEv:
 957               	.LFB21:
 157:LCD.cpp       **** 	clear(true);
 958               		.loc 1 157 0
 959               		.cfi_startproc
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
 158:LCD.cpp       **** }
 964               		.loc 1 158 0
 965 03b0 81E0      		ldi r24,lo8(1)
 966 03b2 0C94 0000 		jmp _ZN3LCD5clearEb
 967               	.LVL65:
 968               		.cfi_endproc
 969               	.LFE21:
 971               	.global	_ZN3LCD6digitsE
 972               		.data
 975               	_ZN3LCD6digitsE:
 976 0000 02        		.byte	2
 977 0001 02        		.byte	2
 978 0002 02        		.byte	2
 979 0003 03        		.byte	3
 980 0004 03        		.byte	3
 981 0005 03        		.byte	3
 982 0006 03        		.byte	3
 983 0007 ED00      		.word	237
 984 0009 F200      		.word	242
 985 000b F700      		.word	247
 986 000d FC00      		.word	252
 987 000f F700      		.word	247
 988 0011 ED00      		.word	237
 989 0013 F200      		.word	242
 990 0015 00        		.byte	0
 991 0016 00        		.byte	0
 992 0017 00        		.byte	0
 993 0018 01        		.byte	1
 994 0019 01        		.byte	1
 995 001a 01        		.byte	1
 996 001b 01        		.byte	1
 997 001c ED00      		.word	237
 998 001e F200      		.word	242
 999 0020 F700      		.word	247
 1000 0022 FC00      		.word	252
 1001 0024 F700      		.word	247
 1002 0026 ED00      		.word	237
 1003 0028 F200      		.word	242
 1004 002a 06        		.byte	6
 1005 002b 06        		.byte	6
 1006 002c 06        		.byte	6
 1007 002d 07        		.byte	7
 1008 002e 07        		.byte	7
 1009 002f 07        		.byte	7
 1010 0030 07        		.byte	7
 1011 0031 EC00      		.word	236
 1012 0033 F100      		.word	241
 1013 0035 F600      		.word	246
 1014 0037 FB00      		.word	251
 1015 0039 F600      		.word	246
 1016 003b EC00      		.word	236
 1017 003d F100      		.word	241
 1018 003f 04        		.byte	4
 1019 0040 04        		.byte	4
 1020 0041 04        		.byte	4
 1021 0042 05        		.byte	5
 1022 0043 05        		.byte	5
 1023 0044 05        		.byte	5
 1024 0045 05        		.byte	5
 1025 0046 EC00      		.word	236
 1026 0048 F100      		.word	241
 1027 004a F600      		.word	246
 1028 004c FB00      		.word	251
 1029 004e F600      		.word	246
 1030 0050 EC00      		.word	236
 1031 0052 F100      		.word	241
 1032 0054 02        		.byte	2
 1033 0055 02        		.byte	2
 1034 0056 02        		.byte	2
 1035 0057 03        		.byte	3
 1036 0058 03        		.byte	3
 1037 0059 03        		.byte	3
 1038 005a 03        		.byte	3
 1039 005b EC00      		.word	236
 1040 005d F100      		.word	241
 1041 005f F600      		.word	246
 1042 0061 FB00      		.word	251
 1043 0063 F600      		.word	246
 1044 0065 EC00      		.word	236
 1045 0067 F100      		.word	241
 1046 0069 00        		.byte	0
 1047 006a 00        		.byte	0
 1048 006b 00        		.byte	0
 1049 006c 01        		.byte	1
 1050 006d 01        		.byte	1
 1051 006e 01        		.byte	1
 1052 006f 01        		.byte	1
 1053 0070 EC00      		.word	236
 1054 0072 F100      		.word	241
 1055 0074 F600      		.word	246
 1056 0076 FB00      		.word	251
 1057 0078 F600      		.word	246
 1058 007a EC00      		.word	236
 1059 007c F100      		.word	241
 1060               	.global	_ZN3LCD5NbMapE
 1061               		.section	.rodata
 1064               	_ZN3LCD5NbMapE:
 1065 0000 3F        		.byte	63
 1066 0001 06        		.byte	6
 1067 0002 5B        		.byte	91
 1068 0003 4F        		.byte	79
 1069 0004 66        		.byte	102
 1070 0005 6D        		.byte	109
 1071 0006 7D        		.byte	125
 1072 0007 07        		.byte	7
 1073 0008 7F        		.byte	127
 1074 0009 6F        		.byte	111
 1075               		.text
 1076               	.Letext0:
 1077               		.file 3 "/usr/lib/avr/include/stdint.h"
 1078               		.file 4 "LCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD.cpp
     /tmp/ccziwQC8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccziwQC8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccziwQC8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccziwQC8.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccziwQC8.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccziwQC8.s:12     .text:0000000000000000 _ZN3LCDC2Eb
     /tmp/ccziwQC8.s:12     .text:0000000000000000 _ZN3LCDC1Eb
     /tmp/ccziwQC8.s:84     .text:000000000000004a _ZN3LCDD2Ev
     /tmp/ccziwQC8.s:84     .text:000000000000004a _ZN3LCDD1Ev
     /tmp/ccziwQC8.s:131    .text:000000000000006e _ZN3LCD8setDigitEhh
     /tmp/ccziwQC8.s:1064   .rodata:0000000000000000 _ZN3LCD5NbMapE
     /tmp/ccziwQC8.s:975    .data:0000000000000000 _ZN3LCD6digitsE
     /tmp/ccziwQC8.s:275    .text:000000000000010e _ZN3LCD8setDigitEhNS_6SymbolE
     /tmp/ccziwQC8.s:415    .text:00000000000001a4 _ZN3LCD10setBatteryENS_7BatteryE
     /tmp/ccziwQC8.s:545    .text:0000000000000258 _ZN3LCD5setDPEb
     /tmp/ccziwQC8.s:581    .text:0000000000000270 _ZN3LCD6setClkEb
     /tmp/ccziwQC8.s:617    .text:0000000000000288 _ZN3LCD5getDPEv
     /tmp/ccziwQC8.s:636    .text:0000000000000292 _ZN3LCD6getClkEv
     /tmp/ccziwQC8.s:654    .text:000000000000029a _ZN3LCD5setNbElh
     /tmp/ccziwQC8.s:884    .text:0000000000000380 _ZN3LCD5setNbEl
     /tmp/ccziwQC8.s:902    .text:0000000000000386 _ZN3LCD5clearEb
     /tmp/ccziwQC8.s:956    .text:00000000000003b0 _ZN3LCD5clearEv

UNDEFINED SYMBOLS
__tablejump2__
__divmodsi4
__do_copy_data
