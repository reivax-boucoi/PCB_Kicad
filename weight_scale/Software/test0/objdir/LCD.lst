   1               		.file	"LCD.cpp"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	_ZN3LCDC2Eb
  12               	_ZN3LCDC2Eb:
  13               	.LFB7:
  14               		.file 1 "LCD.cpp"
   1:LCD.cpp       **** #include "LCD.h"
   2:LCD.cpp       **** 
   3:LCD.cpp       **** const uint8_t LCD::NbMap[]={0x3F,0x6,0x5B,0x4F,0x66,0x6D,0x7D,0x7,0x7F,0x6F};
   4:LCD.cpp       **** LCD::digit LCD::digits[]={
   5:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   6:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR1,&LCDDR6,&LCDDR11,&LCDDR16,&LCDDR11,&LCDDR1,&LCDDR6}},
   7:LCD.cpp       **** 		{{6,6,6,7,7,7,7},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   8:LCD.cpp       **** 		{{4,4,4,5,5,5,5},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
   9:LCD.cpp       **** 		{{2,2,2,3,3,3,3},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}},
  10:LCD.cpp       **** 		{{0,0,0,1,1,1,1},{&LCDDR0,&LCDDR5,&LCDDR10,&LCDDR15,&LCDDR10,&LCDDR0,&LCDDR5}}};
  11:LCD.cpp       **** 
  12:LCD.cpp       **** LCD::LCD(bool lowP){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LBB15:
  13:LCD.cpp       **** 	DDRB |= (1 << PB0);
  23               		.loc 1 13 0
  24 0000 209A      		sbi 0x4,0
  14:LCD.cpp       **** 	PORTB |= (1<<PB0);
  25               		.loc 1 14 0
  26 0002 289A      		sbi 0x5,0
  15:LCD.cpp       **** 	LCDCRB|=(1<<LCDMUX1)|(1<<LCDMUX0);
  27               		.loc 1 15 0
  28 0004 8091 E500 		lds r24,229
  29               	.LVL1:
  30 0008 8063      		ori r24,lo8(48)
  31 000a 8093 E500 		sts 229,r24
  32               	.LBE15:
  33               	.LBB16:
  34               	.LBB17:
  16:LCD.cpp       **** 	
  17:LCD.cpp       **** 	if(lowP){
  18:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  35               		.loc 1 18 0
  36 000e 8091 E600 		lds r24,230
  37               	.LBE17:
  38               	.LBE16:
  39               	.LBB19:
  17:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD1)|(1<<LCDCD0); // prescaler 409
  40               		.loc 1 17 0
  41 0012 6623      		tst r22
  42 0014 01F0      		breq .L2
  43               	.LVL2:
  44               	.LBE19:
  45               	.LBB20:
  46               	.LBB18:
  47               		.loc 1 18 0
  48 0016 8767      		ori r24,lo8(119)
  49 0018 8093 E600 		sts 230,r24
  19:LCD.cpp       **** 		LCDCCR|=(1<<LCDDC0);// 2.6V 70µs
  50               		.loc 1 19 0
  51 001c 8091 E700 		lds r24,231
  52 0020 8062      		ori r24,lo8(32)
  53 0022 8093 E700 		sts 231,r24
  20:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN)|(1<<LCDAB);//LCDAB=low power waveform
  54               		.loc 1 20 0
  55 0026 8091 E400 		lds r24,228
  56 002a 806C      		ori r24,lo8(-64)
  57 002c 00C0      		rjmp .L4
  58               	.LVL3:
  59               	.L2:
  60               	.LBE18:
  61               	.LBE20:
  62               	.LBB21:
  21:LCD.cpp       **** 	}else{
  22:LCD.cpp       **** 		LCDFRR|=(1<<LCDPS2)|(1<<LCDPS1)|(1<<LCDPS0)|(1<<LCDCD2)|(1<<LCDCD2)|(1<<LCDCD0); // prescaler 409
  63               		.loc 1 22 0
  64 002e 8567      		ori r24,lo8(117)
  65 0030 8093 E600 		sts 230,r24
  23:LCD.cpp       **** 		LCDCCR|=(1<<LCDCC1)|(1<<LCDCC2)|(1<<LCDDC1);//2.7V 1150µs
  66               		.loc 1 23 0
  67 0034 8091 E700 		lds r24,231
  68 0038 8664      		ori r24,lo8(70)
  69 003a 8093 E700 		sts 231,r24
  24:LCD.cpp       **** 		LCDCRA|=(1<<LCDEN);
  70               		.loc 1 24 0
  71 003e 8091 E400 		lds r24,228
  72 0042 8068      		ori r24,lo8(-128)
  73               	.L4:
  74 0044 8093 E400 		sts 228,r24
  75 0048 0895      		ret
  76               	.LBE21:
  77               		.cfi_endproc
  78               	.LFE7:
  80               	.global	_ZN3LCDC1Eb
  81               		.set	_ZN3LCDC1Eb,_ZN3LCDC2Eb
  82               	.global	_ZN3LCDD2Ev
  84               	_ZN3LCDD2Ev:
  85               	.LFB10:
  25:LCD.cpp       **** 	}
  26:LCD.cpp       **** }
  27:LCD.cpp       **** 
  28:LCD.cpp       **** LCD::~LCD() {
  86               		.loc 1 28 0
  87               		.cfi_startproc
  88               	.LVL4:
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 0 */
  92               	.L__stack_usage = 0
  93               	.LBB22:
  29:LCD.cpp       **** 	LCDCRA|=(1<<LCDBL);
  94               		.loc 1 29 0
  95 004a E4EE      		ldi r30,lo8(-28)
  96 004c F0E0      		ldi r31,0
  97 004e 8081      		ld r24,Z
  98               	.LVL5:
  99 0050 8160      		ori r24,lo8(1)
 100 0052 8083      		st Z,r24
 101               	.LVL6:
 102               	.LBB23:
 103               	.LBB24:
 104               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 105               		.loc 2 187 0
 106 0054 2FEF      		ldi r18,lo8(799999)
 107 0056 84E3      		ldi r24,hi8(799999)
 108 0058 9CE0      		ldi r25,hlo8(799999)
 109 005a 2150      	1:	subi r18,1
 110 005c 8040      		sbci r24,0
 111 005e 9040      		sbci r25,0
 112 0060 01F4      		brne 1b
 113 0062 00C0      		rjmp .
 114 0064 0000      		nop
 115               	.LVL7:
 116               	.LBE24:
 117               	.LBE23:
  30:LCD.cpp       **** 	_delay_ms(500);
  31:LCD.cpp       **** 	LCDCRA&=~(1<<LCDEN);
 118               		.loc 1 31 0
 119 0066 8081      		ld r24,Z
 120 0068 8F77      		andi r24,lo8(127)
 121 006a 8083      		st Z,r24
 122 006c 0895      		ret
 123               	.LBE22:
 124               		.cfi_endproc
 125               	.LFE10:
 127               	.global	_ZN3LCDD1Ev
 128               		.set	_ZN3LCDD1Ev,_ZN3LCDD2Ev
 129               	.global	_ZN3LCD8setDigitEhh
 131               	_ZN3LCD8setDigitEhh:
 132               	.LFB12:
  32:LCD.cpp       **** }
  33:LCD.cpp       **** 
  34:LCD.cpp       **** void LCD::setDigit(uint8_t dig, uint8_t nb) {
 133               		.loc 1 34 0
 134               		.cfi_startproc
 135               	.LVL8:
 136 006e CF92      		push r12
 137               	.LCFI0:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 12, -2
 140 0070 DF92      		push r13
 141               	.LCFI1:
 142               		.cfi_def_cfa_offset 4
 143               		.cfi_offset 13, -3
 144 0072 EF92      		push r14
 145               	.LCFI2:
 146               		.cfi_def_cfa_offset 5
 147               		.cfi_offset 14, -4
 148 0074 FF92      		push r15
 149               	.LCFI3:
 150               		.cfi_def_cfa_offset 6
 151               		.cfi_offset 15, -5
 152 0076 0F93      		push r16
 153               	.LCFI4:
 154               		.cfi_def_cfa_offset 7
 155               		.cfi_offset 16, -6
 156 0078 1F93      		push r17
 157               	.LCFI5:
 158               		.cfi_def_cfa_offset 8
 159               		.cfi_offset 17, -7
 160 007a CF93      		push r28
 161               	.LCFI6:
 162               		.cfi_def_cfa_offset 9
 163               		.cfi_offset 28, -8
 164 007c DF93      		push r29
 165               	.LCFI7:
 166               		.cfi_def_cfa_offset 10
 167               		.cfi_offset 29, -9
 168               	/* prologue: function */
 169               	/* frame size = 0 */
 170               	/* stack size = 8 */
 171               	.L__stack_usage = 8
 172               	.LVL9:
 173               	.LBB25:
  35:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  36:LCD.cpp       **** 		if(NbMap[nb] & (1<<j)){
 174               		.loc 1 36 0
 175 007e E62F      		mov r30,r22
 176 0080 F0E0      		ldi r31,0
 177 0082 E050      		subi r30,lo8(-(_ZN3LCD5NbMapE))
 178 0084 F040      		sbci r31,hi8(-(_ZN3LCD5NbMapE))
 179 0086 4081      		ld r20,Z
 180 0088 50E0      		ldi r21,0
 181 008a 25E1      		ldi r18,lo8(21)
 182 008c 829F      		mul r24,r18
 183 008e C001      		movw r24,r0
 184 0090 1124      		clr __zero_reg__
 185               	.LVL10:
 186 0092 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 187 0094 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 188 0096 FC01      		movw r30,r24
 189 0098 20E0      		ldi r18,0
 190 009a 30E0      		ldi r19,0
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
  38:LCD.cpp       **** 		}else{
  39:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 191               		.loc 1 39 0
 192 009c C1E0      		ldi r28,lo8(1)
 193 009e D0E0      		ldi r29,0
 194               	.LVL11:
 195               	.L10:
 196 00a0 6C01      		movw r12,r24
 197 00a2 C20E      		add r12,r18
 198 00a4 D31E      		adc r13,r19
  36:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 199               		.loc 1 36 0
 200 00a6 BA01      		movw r22,r20
 201 00a8 022E      		mov r0,r18
 202 00aa 00C0      		rjmp 2f
 203               		1:
 204 00ac 7595      		asr r23
 205 00ae 6795      		ror r22
 206               		2:
 207 00b0 0A94      		dec r0
 208 00b2 02F4      		brpl 1b
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 209               		.loc 1 37 0
 210 00b4 0781      		ldd r16,Z+7
 211 00b6 1085      		ldd r17,Z+8
 212 00b8 D801      		movw r26,r16
  36:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 213               		.loc 1 36 0
 214 00ba 60FF      		sbrs r22,0
 215 00bc 00C0      		rjmp .L8
  37:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 216               		.loc 1 37 0
 217 00be FC90      		ld r15,X
 218 00c0 BE01      		movw r22,r28
 219 00c2 D601      		movw r26,r12
 220 00c4 0C90      		ld r0,X
 221 00c6 00C0      		rjmp 2f
 222               		1:
 223 00c8 660F      		lsl r22
 224 00ca 771F      		rol r23
 225               		2:
 226 00cc 0A94      		dec r0
 227 00ce 02F4      		brpl 1b
 228 00d0 6F29      		or r22,r15
 229 00d2 00C0      		rjmp .L12
 230               	.L8:
 231               		.loc 1 39 0
 232 00d4 7C91      		ld r23,X
 233 00d6 7E01      		movw r14,r28
 234 00d8 D601      		movw r26,r12
 235 00da 0C90      		ld r0,X
 236 00dc 00C0      		rjmp 2f
 237               		1:
 238 00de EE0C      		lsl r14
 239 00e0 FF1C      		rol r15
 240               		2:
 241 00e2 0A94      		dec r0
 242 00e4 02F4      		brpl 1b
 243 00e6 6E2D      		mov r22,r14
 244 00e8 6095      		com r22
 245 00ea 6723      		and r22,r23
 246               	.L12:
 247 00ec D801      		movw r26,r16
 248 00ee 6C93      		st X,r22
 249               	.LVL12:
 250 00f0 2F5F      		subi r18,-1
 251 00f2 3F4F      		sbci r19,-1
 252               	.LVL13:
 253 00f4 3296      		adiw r30,2
  35:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
 254               		.loc 1 35 0
 255 00f6 2830      		cpi r18,8
 256 00f8 3105      		cpc r19,__zero_reg__
 257 00fa 01F4      		brne .L10
 258               	/* epilogue start */
 259               	.LBE25:
  40:LCD.cpp       **** 		}	
  41:LCD.cpp       **** 	}
  42:LCD.cpp       **** }
 260               		.loc 1 42 0
 261 00fc DF91      		pop r29
 262 00fe CF91      		pop r28
 263 0100 1F91      		pop r17
 264 0102 0F91      		pop r16
 265 0104 FF90      		pop r15
 266 0106 EF90      		pop r14
 267 0108 DF90      		pop r13
 268 010a CF90      		pop r12
 269 010c 0895      		ret
 270               		.cfi_endproc
 271               	.LFE12:
 273               	.global	_ZN3LCD8setDigitEhNS_6SymbolE
 275               	_ZN3LCD8setDigitEhNS_6SymbolE:
 276               	.LFB13:
  43:LCD.cpp       **** 
  44:LCD.cpp       **** void LCD::setDigit(uint8_t dig, Symbol sy) {
 277               		.loc 1 44 0
 278               		.cfi_startproc
 279               	.LVL14:
 280 010e CF92      		push r12
 281               	.LCFI8:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 12, -2
 284 0110 DF92      		push r13
 285               	.LCFI9:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 13, -3
 288 0112 EF92      		push r14
 289               	.LCFI10:
 290               		.cfi_def_cfa_offset 5
 291               		.cfi_offset 14, -4
 292 0114 FF92      		push r15
 293               	.LCFI11:
 294               		.cfi_def_cfa_offset 6
 295               		.cfi_offset 15, -5
 296 0116 0F93      		push r16
 297               	.LCFI12:
 298               		.cfi_def_cfa_offset 7
 299               		.cfi_offset 16, -6
 300 0118 1F93      		push r17
 301               	.LCFI13:
 302               		.cfi_def_cfa_offset 8
 303               		.cfi_offset 17, -7
 304 011a CF93      		push r28
 305               	.LCFI14:
 306               		.cfi_def_cfa_offset 9
 307               		.cfi_offset 28, -8
 308 011c DF93      		push r29
 309               	.LCFI15:
 310               		.cfi_def_cfa_offset 10
 311               		.cfi_offset 29, -9
 312               	/* prologue: function */
 313               	/* frame size = 0 */
 314               	/* stack size = 8 */
 315               	.L__stack_usage = 8
 316               	.LVL15:
 317 011e 25E1      		ldi r18,lo8(21)
 318 0120 829F      		mul r24,r18
 319 0122 C001      		movw r24,r0
 320 0124 1124      		clr __zero_reg__
 321               	.LVL16:
 322 0126 8050      		subi r24,lo8(-(_ZN3LCD6digitsE))
 323 0128 9040      		sbci r25,hi8(-(_ZN3LCD6digitsE))
 324 012a FC01      		movw r30,r24
 325               		.loc 1 44 0
 326 012c 20E0      		ldi r18,0
 327 012e 30E0      		ldi r19,0
 328               	.LBB26:
  45:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
  46:LCD.cpp       **** 		if(sy & (1<<j)){
 329               		.loc 1 46 0
 330 0130 70E0      		ldi r23,0
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
  48:LCD.cpp       **** 		}else{
  49:LCD.cpp       **** 			*(digits[dig].dr[j]) &= ~(1<<digits[dig].s[j]);
 331               		.loc 1 49 0
 332 0132 C1E0      		ldi r28,lo8(1)
 333 0134 D0E0      		ldi r29,0
 334               	.LVL17:
 335               	.L16:
 336 0136 6C01      		movw r12,r24
 337 0138 C20E      		add r12,r18
 338 013a D31E      		adc r13,r19
  46:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 339               		.loc 1 46 0
 340 013c AB01      		movw r20,r22
 341 013e 022E      		mov r0,r18
 342 0140 00C0      		rjmp 2f
 343               		1:
 344 0142 5595      		asr r21
 345 0144 4795      		ror r20
 346               		2:
 347 0146 0A94      		dec r0
 348 0148 02F4      		brpl 1b
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 349               		.loc 1 47 0
 350 014a 0781      		ldd r16,Z+7
 351 014c 1085      		ldd r17,Z+8
 352 014e D801      		movw r26,r16
  46:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 353               		.loc 1 46 0
 354 0150 40FF      		sbrs r20,0
 355 0152 00C0      		rjmp .L14
  47:LCD.cpp       **** 			*(digits[dig].dr[j]) |= (1<<digits[dig].s[j]);
 356               		.loc 1 47 0
 357 0154 FC90      		ld r15,X
 358 0156 AE01      		movw r20,r28
 359 0158 D601      		movw r26,r12
 360 015a 0C90      		ld r0,X
 361 015c 00C0      		rjmp 2f
 362               		1:
 363 015e 440F      		lsl r20
 364 0160 551F      		rol r21
 365               		2:
 366 0162 0A94      		dec r0
 367 0164 02F4      		brpl 1b
 368 0166 4F29      		or r20,r15
 369 0168 00C0      		rjmp .L18
 370               	.L14:
 371               		.loc 1 49 0
 372 016a 5C91      		ld r21,X
 373 016c 7E01      		movw r14,r28
 374 016e D601      		movw r26,r12
 375 0170 0C90      		ld r0,X
 376 0172 00C0      		rjmp 2f
 377               		1:
 378 0174 EE0C      		lsl r14
 379 0176 FF1C      		rol r15
 380               		2:
 381 0178 0A94      		dec r0
 382 017a 02F4      		brpl 1b
 383 017c 4E2D      		mov r20,r14
 384 017e 4095      		com r20
 385 0180 4523      		and r20,r21
 386               	.L18:
 387 0182 D801      		movw r26,r16
 388 0184 4C93      		st X,r20
 389               	.LVL18:
 390 0186 2F5F      		subi r18,-1
 391 0188 3F4F      		sbci r19,-1
 392               	.LVL19:
 393 018a 3296      		adiw r30,2
  45:LCD.cpp       **** 	for(uint8_t j=0;j<8;j++){
 394               		.loc 1 45 0
 395 018c 2830      		cpi r18,8
 396 018e 3105      		cpc r19,__zero_reg__
 397 0190 01F4      		brne .L16
 398               	/* epilogue start */
 399               	.LBE26:
  50:LCD.cpp       **** 		}
  51:LCD.cpp       **** 	}
  52:LCD.cpp       **** }
 400               		.loc 1 52 0
 401 0192 DF91      		pop r29
 402 0194 CF91      		pop r28
 403 0196 1F91      		pop r17
 404 0198 0F91      		pop r16
 405 019a FF90      		pop r15
 406 019c EF90      		pop r14
 407 019e DF90      		pop r13
 408 01a0 CF90      		pop r12
 409 01a2 0895      		ret
 410               		.cfi_endproc
 411               	.LFE13:
 413               	.global	_ZN3LCD10setBatteryENS_7BatteryE
 415               	_ZN3LCD10setBatteryENS_7BatteryE:
 416               	.LFB14:
  53:LCD.cpp       **** 
  54:LCD.cpp       **** void LCD::setBattery(Battery b) {
 417               		.loc 1 54 0
 418               		.cfi_startproc
 419               	.LVL20:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
  55:LCD.cpp       **** 	switch(b){
 424               		.loc 1 55 0
 425 01a4 90E0      		ldi r25,0
 426 01a6 8830      		cpi r24,8
 427 01a8 9105      		cpc r25,__zero_reg__
 428 01aa 00F0      		brlo .+2
 429 01ac 00C0      		rjmp .L19
 430 01ae FC01      		movw r30,r24
 431 01b0 E050      		subi r30,lo8(-(gs(.L22)))
 432 01b2 F040      		sbci r31,hi8(-(gs(.L22)))
  56:LCD.cpp       **** 	case NONE:
  57:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  58:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  59:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  60:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  61:LCD.cpp       **** 		break;
  62:LCD.cpp       **** 	case EMPTY:
  63:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  64:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  65:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  66:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  67:LCD.cpp       **** 		break;
  68:LCD.cpp       **** 	case FIRST:
  69:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  70:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  71:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  72:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  73:LCD.cpp       **** 		break;
  74:LCD.cpp       **** 	case SECOND:
  75:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  76:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  77:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  78:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  79:LCD.cpp       **** 		break;
  80:LCD.cpp       **** 	case THIRD:
  81:LCD.cpp       **** 		LCDDR1 &=~(1<<4);
  82:LCD.cpp       **** 		LCDDR6 |=(1<<4);
  83:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  84:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
  85:LCD.cpp       **** 		break;
  86:LCD.cpp       **** 	case ONEBAR:
  87:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  88:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  89:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
  90:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  91:LCD.cpp       **** 		break;
  92:LCD.cpp       **** 	case TWOBAR:
  93:LCD.cpp       **** 		LCDDR1 |=(1<<4);
  94:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
  95:LCD.cpp       **** 		LCDDR11 |=(1<<4);
  96:LCD.cpp       **** 		LCDDR16 |=(1<<4);
  97:LCD.cpp       **** 		break;
  98:LCD.cpp       **** 	case FULL:
  99:LCD.cpp       **** 		LCDDR1 |=(1<<4);
 433               		.loc 1 99 0
 434 01b4 8091 ED00 		lds r24,237
 435               	.LVL21:
  55:LCD.cpp       **** 	switch(b){
 436               		.loc 1 55 0
 437 01b8 0C94 0000 		jmp __tablejump2__
 438               	.LVL22:
 439               		.section	.progmem.gcc_sw_table,"a",@progbits
 440               		.p2align	1
 441               	.L22:
 442 0000 0000      		.word gs(.L21)
 443 0002 0000      		.word gs(.L23)
 444 0004 0000      		.word gs(.L24)
 445 0006 0000      		.word gs(.L25)
 446 0008 0000      		.word gs(.L26)
 447 000a 0000      		.word gs(.L27)
 448 000c 0000      		.word gs(.L28)
 449 000e 0000      		.word gs(.L29)
 450               		.text
 451               	.L21:
  57:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 452               		.loc 1 57 0
 453 01bc 8F7E      		andi r24,lo8(-17)
 454 01be 00C0      		rjmp .L36
 455               	.L23:
  63:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 456               		.loc 1 63 0
 457 01c0 8061      		ori r24,lo8(16)
 458               	.L36:
 459 01c2 8093 ED00 		sts 237,r24
  64:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 460               		.loc 1 64 0
 461 01c6 8091 F200 		lds r24,242
 462 01ca 8F7E      		andi r24,lo8(-17)
 463 01cc 00C0      		rjmp .L35
 464               	.L24:
  69:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 465               		.loc 1 69 0
 466 01ce 8F7E      		andi r24,lo8(-17)
 467 01d0 00C0      		rjmp .L33
 468               	.L25:
  75:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 469               		.loc 1 75 0
 470 01d2 8F7E      		andi r24,lo8(-17)
 471 01d4 8093 ED00 		sts 237,r24
  76:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 472               		.loc 1 76 0
 473 01d8 8091 F200 		lds r24,242
 474 01dc 8F7E      		andi r24,lo8(-17)
 475 01de 8093 F200 		sts 242,r24
  77:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 476               		.loc 1 77 0
 477 01e2 8091 F700 		lds r24,247
 478 01e6 8061      		ori r24,lo8(16)
 479 01e8 00C0      		rjmp .L34
 480               	.L26:
  81:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 481               		.loc 1 81 0
 482 01ea 8F7E      		andi r24,lo8(-17)
 483 01ec 8093 ED00 		sts 237,r24
  82:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 484               		.loc 1 82 0
 485 01f0 8091 F200 		lds r24,242
 486 01f4 8061      		ori r24,lo8(16)
 487               	.L35:
 488 01f6 8093 F200 		sts 242,r24
  83:LCD.cpp       **** 		LCDDR16 &=~(1<<4);
 489               		.loc 1 83 0
 490 01fa 8091 F700 		lds r24,247
 491 01fe 8F7E      		andi r24,lo8(-17)
 492               	.L34:
 493 0200 8093 F700 		sts 247,r24
  84:LCD.cpp       **** 		break;
 494               		.loc 1 84 0
 495 0204 8091 FC00 		lds r24,252
 496 0208 8F7E      		andi r24,lo8(-17)
 497 020a 00C0      		rjmp .L32
 498               	.L27:
  87:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 499               		.loc 1 87 0
 500 020c 8061      		ori r24,lo8(16)
 501               	.L33:
 502 020e 8093 ED00 		sts 237,r24
  88:LCD.cpp       **** 		LCDDR11 &=~(1<<4);
 503               		.loc 1 88 0
 504 0212 8091 F200 		lds r24,242
 505 0216 8F7E      		andi r24,lo8(-17)
 506 0218 8093 F200 		sts 242,r24
  89:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 507               		.loc 1 89 0
 508 021c 8091 F700 		lds r24,247
 509 0220 8F7E      		andi r24,lo8(-17)
 510 0222 00C0      		rjmp .L30
 511               	.L28:
  93:LCD.cpp       **** 		LCDDR6 &=~(1<<4);
 512               		.loc 1 93 0
 513 0224 8061      		ori r24,lo8(16)
 514 0226 8093 ED00 		sts 237,r24
  94:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 515               		.loc 1 94 0
 516 022a 8091 F200 		lds r24,242
 517 022e 8F7E      		andi r24,lo8(-17)
 518 0230 00C0      		rjmp .L31
 519               	.L29:
 520               		.loc 1 99 0
 521 0232 8061      		ori r24,lo8(16)
 522 0234 8093 ED00 		sts 237,r24
 100:LCD.cpp       **** 		LCDDR6 |=(1<<4);
 523               		.loc 1 100 0
 524 0238 8091 F200 		lds r24,242
 525 023c 8061      		ori r24,lo8(16)
 526               	.L31:
 527 023e 8093 F200 		sts 242,r24
 101:LCD.cpp       **** 		LCDDR11 |=(1<<4);
 528               		.loc 1 101 0
 529 0242 8091 F700 		lds r24,247
 530 0246 8061      		ori r24,lo8(16)
 531               	.L30:
 532 0248 8093 F700 		sts 247,r24
 102:LCD.cpp       **** 		LCDDR16 |=(1<<4);
 533               		.loc 1 102 0
 534 024c 8091 FC00 		lds r24,252
 535 0250 8061      		ori r24,lo8(16)
 536               	.L32:
 537 0252 8093 FC00 		sts 252,r24
 538               	.L19:
 539 0256 0895      		ret
 540               		.cfi_endproc
 541               	.LFE14:
 543               	.global	_ZN3LCD5setDPEb
 545               	_ZN3LCD5setDPEb:
 546               	.LFB15:
 103:LCD.cpp       **** 		break;
 104:LCD.cpp       **** 	}
 105:LCD.cpp       **** }
 106:LCD.cpp       **** 
 107:LCD.cpp       **** void LCD::setDP(bool b) {
 547               		.loc 1 107 0
 548               		.cfi_startproc
 549               	.LVL23:
 550               	/* prologue: function */
 551               	/* frame size = 0 */
 552               	/* stack size = 0 */
 553               	.L__stack_usage = 0
 108:LCD.cpp       **** 	if(b){
 554               		.loc 1 108 0
 555 0258 8823      		tst r24
 556 025a 01F0      		breq .L38
 557               	.LVL24:
 558               	.LBB29:
 559               	.LBB30:
 109:LCD.cpp       **** 		LCDDR15|=(1<<4);
 560               		.loc 1 109 0
 561 025c 8091 FB00 		lds r24,251
 562               	.LVL25:
 563 0260 8061      		ori r24,lo8(16)
 564 0262 00C0      		rjmp .L40
 565               	.LVL26:
 566               	.L38:
 567               	.LBE30:
 568               	.LBE29:
 110:LCD.cpp       **** 	}else{
 111:LCD.cpp       **** 		LCDDR15&=~(1<<4);
 569               		.loc 1 111 0
 570 0264 8091 FB00 		lds r24,251
 571               	.LVL27:
 572 0268 8F7E      		andi r24,lo8(-17)
 573               	.L40:
 574 026a 8093 FB00 		sts 251,r24
 575 026e 0895      		ret
 576               		.cfi_endproc
 577               	.LFE15:
 579               	.global	_ZN3LCD6setClkEb
 581               	_ZN3LCD6setClkEb:
 582               	.LFB16:
 112:LCD.cpp       **** 	}
 113:LCD.cpp       **** }
 114:LCD.cpp       **** 
 115:LCD.cpp       **** void LCD::setClk(bool b) {
 583               		.loc 1 115 0
 584               		.cfi_startproc
 585               	.LVL28:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 116:LCD.cpp       **** 	if(b){
 590               		.loc 1 116 0
 591 0270 8823      		tst r24
 592 0272 01F0      		breq .L42
 593               	.LVL29:
 594               	.LBB33:
 595               	.LBB34:
 117:LCD.cpp       **** 		LCDDR16|=1;
 596               		.loc 1 117 0
 597 0274 8091 FC00 		lds r24,252
 598               	.LVL30:
 599 0278 8160      		ori r24,lo8(1)
 600 027a 00C0      		rjmp .L44
 601               	.LVL31:
 602               	.L42:
 603               	.LBE34:
 604               	.LBE33:
 118:LCD.cpp       **** 	}else{
 119:LCD.cpp       **** 		LCDDR16&=~1;
 605               		.loc 1 119 0
 606 027c 8091 FC00 		lds r24,252
 607               	.LVL32:
 608 0280 8E7F      		andi r24,lo8(-2)
 609               	.L44:
 610 0282 8093 FC00 		sts 252,r24
 611 0286 0895      		ret
 612               		.cfi_endproc
 613               	.LFE16:
 615               	.global	_ZN3LCD5getDPEv
 617               	_ZN3LCD5getDPEv:
 618               	.LFB17:
 120:LCD.cpp       **** 	}
 121:LCD.cpp       **** }
 122:LCD.cpp       **** 
 123:LCD.cpp       **** bool LCD::getDP(void) {
 619               		.loc 1 123 0
 620               		.cfi_startproc
 621               	/* prologue: function */
 622               	/* frame size = 0 */
 623               	/* stack size = 0 */
 624               	.L__stack_usage = 0
 124:LCD.cpp       **** 	return (LCDDR15 & (1<<4));
 625               		.loc 1 124 0
 626 0288 8091 FB00 		lds r24,251
 125:LCD.cpp       **** }
 627               		.loc 1 125 0
 628 028c 8295      		swap r24
 629 028e 8170      		andi r24,1
 630 0290 0895      		ret
 631               		.cfi_endproc
 632               	.LFE17:
 634               	.global	_ZN3LCD6getClkEv
 636               	_ZN3LCD6getClkEv:
 637               	.LFB18:
 126:LCD.cpp       **** 
 127:LCD.cpp       **** bool LCD::getClk(void) {
 638               		.loc 1 127 0
 639               		.cfi_startproc
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 128:LCD.cpp       **** 	return (LCDDR16 & 1);
 644               		.loc 1 128 0
 645 0292 8091 FC00 		lds r24,252
 129:LCD.cpp       **** }
 646               		.loc 1 129 0
 647 0296 8170      		andi r24,lo8(1)
 648 0298 0895      		ret
 649               		.cfi_endproc
 650               	.LFE18:
 652               	.global	_ZN3LCD5blinkEj
 654               	_ZN3LCD5blinkEj:
 655               	.LFB19:
 130:LCD.cpp       **** 
 131:LCD.cpp       **** void LCD::blink(uint16_t t) {
 656               		.loc 1 131 0
 657               		.cfi_startproc
 658               	.LVL33:
 659               	/* prologue: function */
 660               	/* frame size = 0 */
 661               	/* stack size = 0 */
 662               	.L__stack_usage = 0
 663               	.LBB35:
 132:LCD.cpp       **** 	for(uint16_t i=0;i<t;i++){
 664               		.loc 1 132 0
 665 029a 20E0      		ldi r18,0
 666 029c 30E0      		ldi r19,0
 667               	.LVL34:
 668               	.L49:
 669               		.loc 1 132 0 is_stmt 0 discriminator 3
 670 029e 2817      		cp r18,r24
 671 02a0 3907      		cpc r19,r25
 672 02a2 01F0      		breq .L47
 133:LCD.cpp       **** 		PORTB|=(1<<PB0);
 673               		.loc 1 133 0 is_stmt 1 discriminator 2
 674 02a4 289A      		sbi 0x5,0
 675               	.LVL35:
 676               	.LBB36:
 677               	.LBB37:
 678               		.loc 2 187 0 discriminator 2
 679 02a6 EFE2      		ldi r30,lo8(29999)
 680 02a8 F5E7      		ldi r31,hi8(29999)
 681 02aa 3197      	1:	sbiw r30,1
 682 02ac 01F4      		brne 1b
 683 02ae 00C0      		rjmp .
 684 02b0 0000      		nop
 685               	.LVL36:
 686               	.LBE37:
 687               	.LBE36:
 134:LCD.cpp       **** 		_delay_ms(15);
 135:LCD.cpp       **** 		PORTB&=~(1<<PB0);
 688               		.loc 1 135 0 discriminator 2
 689 02b2 2898      		cbi 0x5,0
 690               	.LVL37:
 691               	.LBB38:
 692               	.LBB39:
 693               		.loc 2 187 0 discriminator 2
 694 02b4 EFE2      		ldi r30,lo8(29999)
 695 02b6 F5E7      		ldi r31,hi8(29999)
 696 02b8 3197      	1:	sbiw r30,1
 697 02ba 01F4      		brne 1b
 698 02bc 00C0      		rjmp .
 699 02be 0000      		nop
 700               	.LVL38:
 701               	.LBE39:
 702               	.LBE38:
 132:LCD.cpp       **** 		PORTB|=(1<<PB0);
 703               		.loc 1 132 0 discriminator 2
 704 02c0 2F5F      		subi r18,-1
 705 02c2 3F4F      		sbci r19,-1
 706               	.LVL39:
 707 02c4 00C0      		rjmp .L49
 708               	.L47:
 709 02c6 0895      		ret
 710               	.LBE35:
 711               		.cfi_endproc
 712               	.LFE19:
 714               	.global	_ZN3LCD5setNbEl
 716               	_ZN3LCD5setNbEl:
 717               	.LFB20:
 136:LCD.cpp       **** 		_delay_ms(15);
 137:LCD.cpp       **** 	}
 138:LCD.cpp       **** }
 139:LCD.cpp       **** 
 140:LCD.cpp       **** uint8_t LCD::setNb(int32_t nb) {// TODO 10ms !
 718               		.loc 1 140 0
 719               		.cfi_startproc
 720               	.LVL40:
 721 02c8 4F92      		push r4
 722               	.LCFI16:
 723               		.cfi_def_cfa_offset 3
 724               		.cfi_offset 4, -2
 725 02ca 5F92      		push r5
 726               	.LCFI17:
 727               		.cfi_def_cfa_offset 4
 728               		.cfi_offset 5, -3
 729 02cc 6F92      		push r6
 730               	.LCFI18:
 731               		.cfi_def_cfa_offset 5
 732               		.cfi_offset 6, -4
 733 02ce 7F92      		push r7
 734               	.LCFI19:
 735               		.cfi_def_cfa_offset 6
 736               		.cfi_offset 7, -5
 737 02d0 8F92      		push r8
 738               	.LCFI20:
 739               		.cfi_def_cfa_offset 7
 740               		.cfi_offset 8, -6
 741 02d2 9F92      		push r9
 742               	.LCFI21:
 743               		.cfi_def_cfa_offset 8
 744               		.cfi_offset 9, -7
 745 02d4 AF92      		push r10
 746               	.LCFI22:
 747               		.cfi_def_cfa_offset 9
 748               		.cfi_offset 10, -8
 749 02d6 BF92      		push r11
 750               	.LCFI23:
 751               		.cfi_def_cfa_offset 10
 752               		.cfi_offset 11, -9
 753 02d8 CF92      		push r12
 754               	.LCFI24:
 755               		.cfi_def_cfa_offset 11
 756               		.cfi_offset 12, -10
 757 02da DF92      		push r13
 758               	.LCFI25:
 759               		.cfi_def_cfa_offset 12
 760               		.cfi_offset 13, -11
 761 02dc EF92      		push r14
 762               	.LCFI26:
 763               		.cfi_def_cfa_offset 13
 764               		.cfi_offset 14, -12
 765 02de FF92      		push r15
 766               	.LCFI27:
 767               		.cfi_def_cfa_offset 14
 768               		.cfi_offset 15, -13
 769 02e0 0F93      		push r16
 770               	.LCFI28:
 771               		.cfi_def_cfa_offset 15
 772               		.cfi_offset 16, -14
 773 02e2 1F93      		push r17
 774               	.LCFI29:
 775               		.cfi_def_cfa_offset 16
 776               		.cfi_offset 17, -15
 777 02e4 CF93      		push r28
 778               	.LCFI30:
 779               		.cfi_def_cfa_offset 17
 780               		.cfi_offset 28, -16
 781 02e6 DF93      		push r29
 782               	.LCFI31:
 783               		.cfi_def_cfa_offset 18
 784               		.cfi_offset 29, -17
 785               	/* prologue: function */
 786               	/* frame size = 0 */
 787               	/* stack size = 16 */
 788               	.L__stack_usage = 16
 789 02e8 6B01      		movw r12,r22
 790 02ea 7C01      		movw r14,r24
 141:LCD.cpp       **** 	if(nb>999999 || nb <-99999){
 791               		.loc 1 141 0
 792 02ec DC01      		movw r26,r24
 793 02ee CB01      		movw r24,r22
 794 02f0 8156      		subi r24,97
 795 02f2 9947      		sbci r25,121
 796 02f4 AE4F      		sbci r26,-2
 797 02f6 BF4F      		sbci r27,-1
 798 02f8 8F3D      		cpi r24,-33
 799 02fa 984C      		sbci r25,-56
 800 02fc A041      		sbci r26,16
 801 02fe B105      		cpc r27,__zero_reg__
 802 0300 00F0      		brlo .+2
 803 0302 00C0      		rjmp .L57
 804               	.LVL41:
 142:LCD.cpp       **** 		return 1;
 143:LCD.cpp       **** 	}
 144:LCD.cpp       **** 	int8_t d=5;
 145:LCD.cpp       **** 	uint8_t min=0;
 146:LCD.cpp       **** 	if(nb<0){
 805               		.loc 1 146 0
 806 0304 F7FE      		sbrs r15,7
 807 0306 00C0      		rjmp .L58
 147:LCD.cpp       **** 		setDigit(0,Minus);
 808               		.loc 1 147 0
 809 0308 60E4      		ldi r22,lo8(64)
 810               	.LVL42:
 811 030a 80E0      		ldi r24,0
 812 030c 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 813               	.LVL43:
 148:LCD.cpp       **** 		min++;
 149:LCD.cpp       **** 		nb=(~nb)+1;
 814               		.loc 1 149 0
 815 0310 F094      		com r15
 816 0312 E094      		com r14
 817 0314 D094      		com r13
 818 0316 C094      		com r12
 819 0318 C11C      		adc r12,__zero_reg__
 820 031a D11C      		adc r13,__zero_reg__
 821 031c E11C      		adc r14,__zero_reg__
 822 031e F11C      		adc r15,__zero_reg__
 823               	.LVL44:
 148:LCD.cpp       **** 		min++;
 824               		.loc 1 148 0
 825 0320 01E0      		ldi r16,lo8(1)
 826 0322 00C0      		rjmp .L52
 827               	.LVL45:
 828               	.L58:
 145:LCD.cpp       **** 	if(nb<0){
 829               		.loc 1 145 0
 830 0324 00E0      		ldi r16,0
 831               	.LVL46:
 832               	.L52:
 148:LCD.cpp       **** 		min++;
 833               		.loc 1 148 0
 834 0326 C5E0      		ldi r28,lo8(5)
 150:LCD.cpp       **** 	}
 151:LCD.cpp       **** 	while(d>=min){
 835               		.loc 1 151 0
 836 0328 10E0      		ldi r17,0
 152:LCD.cpp       **** 		setDigit(d--,nb%10);
 837               		.loc 1 152 0
 838 032a 8AE0      		ldi r24,lo8(10)
 839 032c 482E      		mov r4,r24
 840 032e 512C      		mov r5,__zero_reg__
 841 0330 612C      		mov r6,__zero_reg__
 842 0332 712C      		mov r7,__zero_reg__
 843               	.LVL47:
 844               	.L54:
 151:LCD.cpp       **** 		setDigit(d--,nb%10);
 845               		.loc 1 151 0
 846 0334 8C2F      		mov r24,r28
 847 0336 0C2E      		mov __tmp_reg__,r28
 848 0338 000C      		lsl r0
 849 033a 990B      		sbc r25,r25
 850 033c 8017      		cp r24,r16
 851 033e 9107      		cpc r25,r17
 852 0340 04F4      		brge .L53
 853               	.LVL48:
 854               	.L55:
 153:LCD.cpp       **** 		nb/=10;
 154:LCD.cpp       **** 		if(nb==0)break;
 155:LCD.cpp       **** 	}
 156:LCD.cpp       **** 	while(d>=min)setDigit(d--,Blank);
 157:LCD.cpp       **** 	return 0;
 855               		.loc 1 157 0
 856 0342 80E0      		ldi r24,0
 857 0344 00C0      		rjmp .L51
 858               	.LVL49:
 859               	.L53:
 152:LCD.cpp       **** 		nb/=10;
 860               		.loc 1 152 0
 861 0346 C701      		movw r24,r14
 862 0348 B601      		movw r22,r12
 863 034a A301      		movw r20,r6
 864 034c 9201      		movw r18,r4
 865 034e 0E94 0000 		call __divmodsi4
 866 0352 4901      		movw r8,r18
 867 0354 5A01      		movw r10,r20
 868 0356 8C2F      		mov r24,r28
 869 0358 C150      		subi r28,lo8(-(-1))
 870               	.LVL50:
 871 035a 0E94 0000 		call _ZN3LCD8setDigitEhh
 872               	.LVL51:
 153:LCD.cpp       **** 		nb/=10;
 873               		.loc 1 153 0
 874 035e 6401      		movw r12,r8
 875               	.LVL52:
 876 0360 7501      		movw r14,r10
 877               	.LVL53:
 154:LCD.cpp       **** 	}
 878               		.loc 1 154 0
 879 0362 C114      		cp r12,__zero_reg__
 880 0364 D104      		cpc r13,__zero_reg__
 881 0366 E104      		cpc r14,__zero_reg__
 882 0368 F104      		cpc r15,__zero_reg__
 883 036a 01F4      		brne .L54
 884               	.LVL54:
 885               	.L56:
 156:LCD.cpp       **** 	return 0;
 886               		.loc 1 156 0 discriminator 2
 887 036c 8C2F      		mov r24,r28
 888 036e 0C2E      		mov __tmp_reg__,r28
 889 0370 000C      		lsl r0
 890 0372 990B      		sbc r25,r25
 891 0374 8017      		cp r24,r16
 892 0376 9107      		cpc r25,r17
 893 0378 04F0      		brlt .L55
 156:LCD.cpp       **** 	return 0;
 894               		.loc 1 156 0 is_stmt 0 discriminator 1
 895 037a 8C2F      		mov r24,r28
 896 037c 60E0      		ldi r22,0
 897 037e C150      		subi r28,lo8(-(-1))
 898               	.LVL55:
 899 0380 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 900               	.LVL56:
 901 0384 00C0      		rjmp .L56
 902               	.LVL57:
 903               	.L57:
 142:LCD.cpp       **** 	}
 904               		.loc 1 142 0 is_stmt 1
 905 0386 81E0      		ldi r24,lo8(1)
 906               	.LVL58:
 907               	.L51:
 908               	/* epilogue start */
 158:LCD.cpp       **** }
 909               		.loc 1 158 0
 910 0388 DF91      		pop r29
 911 038a CF91      		pop r28
 912 038c 1F91      		pop r17
 913 038e 0F91      		pop r16
 914 0390 FF90      		pop r15
 915 0392 EF90      		pop r14
 916 0394 DF90      		pop r13
 917 0396 CF90      		pop r12
 918 0398 BF90      		pop r11
 919 039a AF90      		pop r10
 920 039c 9F90      		pop r9
 921 039e 8F90      		pop r8
 922 03a0 7F90      		pop r7
 923 03a2 6F90      		pop r6
 924 03a4 5F90      		pop r5
 925 03a6 4F90      		pop r4
 926 03a8 0895      		ret
 927               		.cfi_endproc
 928               	.LFE20:
 930               	.global	_ZN3LCD5clearEv
 932               	_ZN3LCD5clearEv:
 933               	.LFB21:
 159:LCD.cpp       **** 
 160:LCD.cpp       **** void LCD::clear(void) {
 934               		.loc 1 160 0
 935               		.cfi_startproc
 936 03aa CF93      		push r28
 937               	.LCFI32:
 938               		.cfi_def_cfa_offset 3
 939               		.cfi_offset 28, -2
 940               	/* prologue: function */
 941               	/* frame size = 0 */
 942               	/* stack size = 1 */
 943               	.L__stack_usage = 1
 161:LCD.cpp       **** 	setBattery(NONE);
 944               		.loc 1 161 0
 945 03ac 80E0      		ldi r24,0
 946 03ae 0E94 0000 		call _ZN3LCD10setBatteryENS_7BatteryE
 947               	.LVL59:
 162:LCD.cpp       **** 	setClk(false);
 948               		.loc 1 162 0
 949 03b2 80E0      		ldi r24,0
 950 03b4 0E94 0000 		call _ZN3LCD6setClkEb
 951               	.LVL60:
 163:LCD.cpp       **** 	setDP(false);
 952               		.loc 1 163 0
 953 03b8 80E0      		ldi r24,0
 954 03ba 0E94 0000 		call _ZN3LCD5setDPEb
 955               	.LVL61:
 956               	.LBB40:
 164:LCD.cpp       **** 	for(int8_t i=5;i>=0;i--)setDigit(i,Blank);
 957               		.loc 1 164 0
 958 03be C5E0      		ldi r28,lo8(5)
 959               	.LVL62:
 960               	.L61:
 961               		.loc 1 164 0 is_stmt 0 discriminator 2
 962 03c0 60E0      		ldi r22,0
 963 03c2 8C2F      		mov r24,r28
 964 03c4 0E94 0000 		call _ZN3LCD8setDigitEhNS_6SymbolE
 965               	.LVL63:
 966               	.LVL64:
 967 03c8 C150      		subi r28,1
 968 03ca 00F4      		brcc .L61
 969               	/* epilogue start */
 970               	.LBE40:
 165:LCD.cpp       **** }
 971               		.loc 1 165 0 is_stmt 1
 972 03cc CF91      		pop r28
 973               	.LVL65:
 974 03ce 0895      		ret
 975               		.cfi_endproc
 976               	.LFE21:
 978               	.global	_ZN3LCD6digitsE
 979               		.data
 982               	_ZN3LCD6digitsE:
 983 0000 02        		.byte	2
 984 0001 02        		.byte	2
 985 0002 02        		.byte	2
 986 0003 03        		.byte	3
 987 0004 03        		.byte	3
 988 0005 03        		.byte	3
 989 0006 03        		.byte	3
 990 0007 ED00      		.word	237
 991 0009 F200      		.word	242
 992 000b F700      		.word	247
 993 000d FC00      		.word	252
 994 000f F700      		.word	247
 995 0011 ED00      		.word	237
 996 0013 F200      		.word	242
 997 0015 00        		.byte	0
 998 0016 00        		.byte	0
 999 0017 00        		.byte	0
 1000 0018 01        		.byte	1
 1001 0019 01        		.byte	1
 1002 001a 01        		.byte	1
 1003 001b 01        		.byte	1
 1004 001c ED00      		.word	237
 1005 001e F200      		.word	242
 1006 0020 F700      		.word	247
 1007 0022 FC00      		.word	252
 1008 0024 F700      		.word	247
 1009 0026 ED00      		.word	237
 1010 0028 F200      		.word	242
 1011 002a 06        		.byte	6
 1012 002b 06        		.byte	6
 1013 002c 06        		.byte	6
 1014 002d 07        		.byte	7
 1015 002e 07        		.byte	7
 1016 002f 07        		.byte	7
 1017 0030 07        		.byte	7
 1018 0031 EC00      		.word	236
 1019 0033 F100      		.word	241
 1020 0035 F600      		.word	246
 1021 0037 FB00      		.word	251
 1022 0039 F600      		.word	246
 1023 003b EC00      		.word	236
 1024 003d F100      		.word	241
 1025 003f 04        		.byte	4
 1026 0040 04        		.byte	4
 1027 0041 04        		.byte	4
 1028 0042 05        		.byte	5
 1029 0043 05        		.byte	5
 1030 0044 05        		.byte	5
 1031 0045 05        		.byte	5
 1032 0046 EC00      		.word	236
 1033 0048 F100      		.word	241
 1034 004a F600      		.word	246
 1035 004c FB00      		.word	251
 1036 004e F600      		.word	246
 1037 0050 EC00      		.word	236
 1038 0052 F100      		.word	241
 1039 0054 02        		.byte	2
 1040 0055 02        		.byte	2
 1041 0056 02        		.byte	2
 1042 0057 03        		.byte	3
 1043 0058 03        		.byte	3
 1044 0059 03        		.byte	3
 1045 005a 03        		.byte	3
 1046 005b EC00      		.word	236
 1047 005d F100      		.word	241
 1048 005f F600      		.word	246
 1049 0061 FB00      		.word	251
 1050 0063 F600      		.word	246
 1051 0065 EC00      		.word	236
 1052 0067 F100      		.word	241
 1053 0069 00        		.byte	0
 1054 006a 00        		.byte	0
 1055 006b 00        		.byte	0
 1056 006c 01        		.byte	1
 1057 006d 01        		.byte	1
 1058 006e 01        		.byte	1
 1059 006f 01        		.byte	1
 1060 0070 EC00      		.word	236
 1061 0072 F100      		.word	241
 1062 0074 F600      		.word	246
 1063 0076 FB00      		.word	251
 1064 0078 F600      		.word	246
 1065 007a EC00      		.word	236
 1066 007c F100      		.word	241
 1067               	.global	_ZN3LCD5NbMapE
 1068               		.section	.rodata
 1071               	_ZN3LCD5NbMapE:
 1072 0000 3F        		.byte	63
 1073 0001 06        		.byte	6
 1074 0002 5B        		.byte	91
 1075 0003 4F        		.byte	79
 1076 0004 66        		.byte	102
 1077 0005 6D        		.byte	109
 1078 0006 7D        		.byte	125
 1079 0007 07        		.byte	7
 1080 0008 7F        		.byte	127
 1081 0009 6F        		.byte	111
 1082               		.text
 1083               	.Letext0:
 1084               		.file 3 "/usr/lib/avr/include/stdint.h"
 1085               		.file 4 "LCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD.cpp
     /tmp/cc3tsMRs.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc3tsMRs.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc3tsMRs.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc3tsMRs.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc3tsMRs.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc3tsMRs.s:12     .text:0000000000000000 _ZN3LCDC2Eb
     /tmp/cc3tsMRs.s:12     .text:0000000000000000 _ZN3LCDC1Eb
     /tmp/cc3tsMRs.s:84     .text:000000000000004a _ZN3LCDD2Ev
     /tmp/cc3tsMRs.s:84     .text:000000000000004a _ZN3LCDD1Ev
     /tmp/cc3tsMRs.s:131    .text:000000000000006e _ZN3LCD8setDigitEhh
     /tmp/cc3tsMRs.s:1071   .rodata:0000000000000000 _ZN3LCD5NbMapE
     /tmp/cc3tsMRs.s:982    .data:0000000000000000 _ZN3LCD6digitsE
     /tmp/cc3tsMRs.s:275    .text:000000000000010e _ZN3LCD8setDigitEhNS_6SymbolE
     /tmp/cc3tsMRs.s:415    .text:00000000000001a4 _ZN3LCD10setBatteryENS_7BatteryE
     /tmp/cc3tsMRs.s:545    .text:0000000000000258 _ZN3LCD5setDPEb
     /tmp/cc3tsMRs.s:581    .text:0000000000000270 _ZN3LCD6setClkEb
     /tmp/cc3tsMRs.s:617    .text:0000000000000288 _ZN3LCD5getDPEv
     /tmp/cc3tsMRs.s:636    .text:0000000000000292 _ZN3LCD6getClkEv
     /tmp/cc3tsMRs.s:654    .text:000000000000029a _ZN3LCD5blinkEj
     /tmp/cc3tsMRs.s:716    .text:00000000000002c8 _ZN3LCD5setNbEl
     /tmp/cc3tsMRs.s:932    .text:00000000000003aa _ZN3LCD5clearEv

UNDEFINED SYMBOLS
__tablejump2__
__divmodsi4
__do_copy_data
